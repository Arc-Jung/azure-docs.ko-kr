---
title: Azure Cosmos DB의 분할 및 수평적 크기 조정
description: 파티션 키를 선택 하는 경우 Azure Cosmos DB의 분할, 논리적, 물리적 파티션 및 파티션 키를 선택 하는 방법에 대 한 자세한 내용 및 논리 파티션을 관리 하는 방법을 알아봅니다.
author: deborahc
ms.author: dech
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 10/12/2020
ms.openlocfilehash: 7c05ca6462d49d1d41791e5b93b7723ac681d448
ms.sourcegitcommit: 3bdeb546890a740384a8ef383cf915e84bd7e91e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/30/2020
ms.locfileid: "93080835"
---
# <a name="partitioning-and-horizontal-scaling-in-azure-cosmos-db"></a>Azure Cosmos DB의 분할 및 수평적 크기 조정
[!INCLUDE[appliesto-all-apis](includes/appliesto-all-apis.md)]

Azure Cosmos DB는 분할을 사용 하 여 응용 프로그램의 성능 요구에 맞게 데이터베이스의 개별 컨테이너를 확장 합니다. 분할에서 컨테이너의 항목은 *논리적 파티션* 이라는 별개의 하위 집합으로 나뉩니다. 논리적 파티션은 컨테이너의 각 항목과 연결 된 *파티션 키* 의 값에 따라 형성 됩니다. 논리적 파티션의 모든 항목에는 동일한 파티션 키 값이 있습니다.

예를 들어 컨테이너는 항목을 포함 합니다. 각 항목에는 속성에 대 한 고유한 값이 있습니다 `UserID` . `UserID`가 컨테이너의 항목에 대 한 파티션 키로 사용 되 고 고유 값이 1000 `UserID` 인 경우 해당 컨테이너에 대해 1000 논리 파티션이 만들어집니다.

항목의 논리적 파티션을 결정 하는 파티션 키 외에도 컨테이너의 각 항목에는 *항목 ID* (논리 파티션 내에서 고유)가 있습니다. 파티션 키와 *항목 ID* 를 결합 하면 항목을 고유 하 게 식별 하는 항목의 *인덱스가* 생성 됩니다. [파티션 키를 선택](#choose-partitionkey) 하는 것은 응용 프로그램의 성능에 영향을 주는 중요 한 결정입니다.

이 문서에서는 논리적 파티션 및 물리적 파티션 간의 관계를 설명 합니다. 또한 분할에 대 한 모범 사례에 대해 설명 하 고 Azure Cosmos DB에서 수평 확장이 작동 하는 방식에 대 한 자세한 보기를 제공 합니다. 파티션 키를 선택 하는 이러한 내부 세부 정보를 이해 하지 않아도 되지만 Azure Cosmos DB 작동 방식을 명확 하 게 파악할 수 있습니다.

## <a name="logical-partitions"></a>논리 파티션

논리적 파티션은 동일한 파티션 키를 가진 항목 집합으로 구성 됩니다. 예를 들어 음식 영양 대 한 데이터가 포함 된 컨테이너에서 모든 항목에는 `foodGroup` 속성이 포함 됩니다. 를 `foodGroup` 컨테이너에 대 한 파티션 키로 사용할 수 있습니다. ,, 등의 특정 값이 있는 항목 그룹은 `foodGroup` `Beef Products` `Baked Products` `Sausages and Luncheon Meats` 고유한 논리 파티션을 형성 합니다. 기본 데이터를 삭제할 때 논리적 파티션을 삭제 하는 것에 대해 걱정할 필요가 없습니다.

또한 논리적 파티션은 데이터베이스 트랜잭션의 범위를 정의 합니다. [스냅숏 격리로 트랜잭션을](database-transactions-optimistic-concurrency.md)사용 하 여 논리적 파티션 내에서 항목을 업데이트할 수 있습니다. 새 항목이 컨테이너에 추가 되 면 시스템에서 새 논리적 파티션을 투명 하 게 만듭니다.

컨테이너의 논리 파티션 수에는 제한이 없습니다. 각 논리 파티션은 최대 20GB의 데이터를 저장할 수 있습니다. 좋은 파티션 키 선택 항목에는 다양 한 값을 사용할 수 있습니다. 예를 들어 모든 항목에 속성이 포함 된 컨테이너에서 `foodGroup` 논리 파티션 내의 데이터는 `Beef Products` 최대 20gb까지 증가할 수 있습니다. 범위가 광범위 한 [파티션 키를 선택](#choose-partitionkey) 하면 컨테이너를 확장할 수 있습니다.

## <a name="physical-partitions"></a>실제 파티션

컨테이너는 데이터와 처리량을 실제 파티션에 분산 하 여 크기를 조정 합니다. 내부적으로 하나 이상의 논리 파티션은 단일 실제 파티션에 매핑됩니다. 일반적으로 작은 컨테이너에는 많은 논리적 파티션이 있지만 실제 파티션이 하나만 필요 합니다. 논리적 파티션과 달리 실제 파티션은 시스템의 내부 구현 이며 Azure Cosmos DB에 의해 완전히 관리 됩니다.

컨테이너의 실제 파티션 수는 다음 구성에 따라 달라 집니다.

* 프로 비전 된 처리량의 수입니다. 각 개별 실제 파티션은 초당 최대 1만 요청 단위의 처리량을 제공할 수 있습니다.
* 총 데이터 저장소 (각 개별 실제 파티션은 최대 50GB의 데이터를 저장할 수 있음).

컨테이너의 총 실제 파티션 수에는 제한이 없습니다. 프로 비전 된 처리량 또는 데이터 크기가 증가 함에 따라 Azure Cosmos DB는 기존 파티션을 분할 하 여 새 실제 파티션을 자동으로 만듭니다. 물리적 파티션 분할은 응용 프로그램의 가용성에 영향을 주지 않습니다. 실제 파티션이 분할 된 후 단일 논리적 파티션 내의 모든 데이터는 여전히 동일한 실제 파티션에 저장 됩니다. 물리적 파티션 분할은 단순히 실제 파티션에 논리적 파티션의 새 매핑을 만듭니다.

컨테이너에 대해 프로 비전 된 처리량은 실제 파티션 간에 균등 하 게 분할 됩니다. 요청을 균등 하 게 배포 하지 않는 파티션 키 디자인은 "핫"이 될 수 있는 작은 파티션 하위 집합으로 전달 되는 요청이 너무 많습니다. 핫 파티션은 프로 비전 된 처리량을 비효율적으로 사용 하 여 속도를 제한 하 고 더 높은 비용을 발생 시킬 수 있습니다.

Azure Portal **메트릭 블레이드의** **저장소** 섹션에서 컨테이너의 실제 파티션을 볼 수 있습니다.

:::image type="content" source="./media/partitioning-overview/view-partitions-zoomed-out.png" alt-text="실제 파티션 수 보기" lightbox="./media/partitioning-overview/view-partitions-zoomed-in.png" ::: 

위의 스크린 샷에서 컨테이너에는 `/foodGroup` 파티션 키가 있습니다. 그래프의 각 세 막대는 실제 파티션을 나타냅니다. 이미지에서 **파티션 키 범위** 는 실제 파티션과 같습니다. 선택한 실제 파티션에는 세 개의 논리 파티션, 및가 포함 되어 있습니다 `Beef Products` `Vegetable and Vegetable Products` `Soups, Sauces, and Gravies` .

초당 18000 요청 단위의 처리량을 프로 비전 하는 경우 세 개의 실제 파티션이 프로 비전 된 총 처리량의 1/3을 활용할 수 있습니다. 선택한 실제 파티션 내에서 논리적 파티션 키, `Beef Products` 및는 `Vegetable and Vegetable Products` 집합적으로 `Soups, Sauces, and Gravies` 물리적 파티션의 6000 프로 비전 된 r u/s를 활용할 수 있습니다. 프로 비전 된 처리량은 컨테이너의 실제 파티션에 균등 하 게 분할 되므로 [올바른 논리적 파티션 키를 선택](#choose-partitionkey)하 여 처리량 소비를 균등 하 게 분산 하는 파티션 키를 선택 하는 것이 중요 합니다. 

> [!NOTE]
> 논리적 파티션 간에 처리량 소비를 균등 하 게 분산 하는 파티션 키를 선택 하는 경우 실제 파티션의 처리량 사용량이 균형을 유지 하 게 됩니다.

## <a name="managing-logical-partitions"></a>논리 파티션 관리

Azure Cosmos DB는 컨테이너의 확장성 및 성능 요구를 효율적으로 충족 하기 위해 물리적 파티션에서 논리적 파티션 배치를 투명 하 고 자동으로 관리 합니다. 응용 프로그램의 처리량 및 저장소 요구 사항이 증가 하면, Azure Cosmos DB 논리적 파티션을 이동 하 여 더 많은 수의 실제 파티션에 부하를 자동으로 분산 합니다. [실제 파티션에](partitioning-overview.md#physical-partitions)대해 자세히 알아볼 수 있습니다.

Azure Cosmos DB 해시 기반 분할을 사용 하 여 실제 파티션에 논리적 파티션을 분산 합니다. Azure Cosmos DB는 항목의 파티션 키 값을 해시 합니다. 해시 된 결과는 실제 파티션을 결정 합니다. 그런 다음 Azure Cosmos DB는 실제 파티션에서 파티션 키 해시의 키 공간을 균등 하 게 할당 합니다.

트랜잭션 (저장 프로시저 또는 트리거)은 단일 논리적 파티션의 항목에 대해서만 허용 됩니다.

[Azure Cosmos DB 파티션을 관리 하는 방법](partitioning-overview.md)에 대해 자세히 알아볼 수 있습니다. 응용 프로그램을 빌드하거나 실행 하기 위한 내부 세부 정보를 이해 하는 데 필요 하지는 않지만 여기에서 자세한 정보를 확인할 수 있습니다.

## <a name="replica-sets"></a>복제본 세트

각 실제 파티션은 [*복제본*](global-dist-under-the-hood.md)집합으로도 불리는 복제본 집합으로 구성 됩니다. 각 복제본 집합은 데이터베이스 엔진의 인스턴스를 호스팅합니다. 복제본 세트를 사용 하면 실제 파티션 내에 저장 된 데이터를 지 속성, 고가용성 및 일관성을 유지할 수 있습니다. 실제 파티션을 구성 하는 각 복제본은 파티션의 저장소 할당량을 상속 합니다. 실제 파티션의 모든 복제본은 실제 파티션에 할당 된 처리량을 전체적으로 지원 합니다. Azure Cosmos DB은 복제본 세트를 자동으로 관리 합니다.

일반적으로 작은 컨테이너는 단일 실제 파티션만 필요 하지만 적어도 4 개의 복제본이 있습니다.

다음 이미지에서는 논리 파티션이 전역적으로 배포된 실제 파티션에 매핑되는 방법을 보여 줍니다.

:::image type="content" source="./media/partitioning-overview/logical-partitions.png" alt-text="실제 파티션 수 보기" border="false":::

## <a name="choosing-a-partition-key"></a><a id="choose-partitionkey"></a>파티션 키 선택

파티션 키에는 **파티션 키 경로** 와 **파티션 키 값** 의 두 가지 구성 요소가 있습니다. 예를 들어 항목 {"userId": "Andrew", "worksFor": "Microsoft"} 파티션 키로 "userId"를 선택 하는 경우 다음 두 가지 파티션 키 구성 요소가 있습니다.

* 파티션 키 경로 (예: "/userId")입니다. 파티션 키 경로는 영숫자 및 밑줄 (_) 문자를 허용 합니다. 표준 경로 표기법 (/)을 사용 하 여 중첩 된 개체를 사용할 수도 있습니다.

* 파티션 키 값 (예: "Andrew")입니다. 파티션 키 값은 문자열 또는 숫자 형식일 수 있습니다.

파티션 키의 처리량, 저장소 및 길이에 대 한 제한 사항에 대 한 자세한 내용은 [Azure Cosmos DB 서비스 할당량](concepts-limits.md) 문서를 참조 하세요.

파티션 키를 선택 하는 것은 Azure Cosmos DB에서 간단 하지만 중요 한 디자인 선택입니다. 파티션 키를 선택한 후에는 해당 키를 그대로 변경할 수 없습니다. 파티션 키를 변경 해야 하는 경우 새 파티션 키를 사용 하 여 새 컨테이너로 데이터를 이동 해야 합니다.

**모든** 컨테이너에 대해 파티션 키는 다음을 수행 해야 합니다.

* 값이 변경 되지 않는 속성 이어야 합니다. 속성이 파티션 키 인 경우 해당 속성의 값을 업데이트할 수 없습니다.

* 카디널리티가 높습니다. 즉, 속성에는 다양 한 값을 사용할 수 있어야 합니다.

* 모든 논리적 파티션에 균등 하 게 분산 요청 단위 () 사용량과 데이터 저장소를 균등 하 게 분산 합니다. 이렇게 하면 실제 파티션에 대해 과도 한 사용량과 저장소 배포가 가능 합니다.

Azure Cosmos DB에서 [다중 항목 ACID 트랜잭션이](database-transactions-optimistic-concurrency.md#multi-item-transactions) 필요한 경우에는 [저장 프로시저 또는 트리거](how-to-write-stored-procedures-triggers-udfs.md#stored-procedures)를 사용 해야 합니다. 모든 JavaScript 기반 저장 프로시저와 트리거는 단일 논리 파티션으로 범위가 한정 됩니다.

## <a name="partition-keys-for-read-heavy-containers"></a>읽기 작업이 많은 컨테이너의 파티션 키

대부분의 컨테이너에서 위의 기준은 파티션 키를 선택할 때 고려해 야 할 사항입니다. 그러나 읽기 작업이 많은 컨테이너의 경우 쿼리에 필터로 자주 나타나는 파티션 키를 선택 하는 것이 좋습니다. 필터 조건자에 파티션 키를 포함 하 여 쿼리 [를 관련 실제 파티션으로 효율적으로 라우팅할](how-to-query-container.md#in-partition-query) 수 있습니다.

대부분의 워크 로드 요청이 쿼리이 고 대부분의 쿼리에 동일한 속성에 대 한 같음 필터가 있는 경우이 속성은 좋은 파티션 키를 선택할 수 있습니다. 예를 들어를 필터링 하는 쿼리를 자주 실행 하는 경우 `UserID` `UserID` 파티션 키로를 선택 하면 [파티션 간 쿼리](how-to-query-container.md#avoiding-cross-partition-queries)수가 줄어듭니다.

그러나 컨테이너가 작은 경우 파티션 간 쿼리의 성능 영향에 대해 걱정 하지 않아도 되는 물리적 파티션이 충분 하지 않을 수 있습니다. Azure Cosmos DB에서 대부분의 작은 컨테이너는 하나 또는 두 개의 실제 파티션만 필요 합니다.

컨테이너가 몇 개의 실제 파티션으로 확장 될 수 있는 경우 파티션 간 쿼리를 최소화 하는 파티션 키를 선택 해야 합니다. 다음 중 하나에 해당 하는 경우 컨테이너에 몇 개의 실제 파티션이 필요 합니다.

* 사용자의 컨테이너가 프로 비전 된 3만 이상의 기능을 제공 합니다.

* 컨테이너가 100 GB 이상의 데이터를 저장 합니다.

## <a name="using-item-id-as-the-partition-key"></a>항목 ID를 파티션 키로 사용

컨테이너에 다양 한 범위의 값이 포함 된 속성이 있는 경우 좋은 파티션 키를 선택할 수 있습니다. 이러한 속성의 가능한 한 가지 예는 *항목 ID* 입니다. 모든 크기의 작은 읽기-대량 컨테이너 또는 쓰기 작업량이 많은 컨테이너의 경우, *항목 ID* 는 기본적으로 파티션 키에 적합 합니다.

컨테이너의 모든 항목에 시스템 속성 *항목 ID* 가 있습니다. 항목의 논리적 ID를 나타내는 다른 속성이 있을 수 있습니다. 대부분의 경우에는 *항목 ID* 와 동일한 이유로 적합 한 파티션 키를 선택 해야 합니다.

*항목 ID* 는 다음과 같은 이유로 적합 한 파티션 키입니다.

* 가능한 값의 범위는 다양 합니다 (항목당 하나의 고유 *항목 ID* ).
* 항목별 고유 *항목 id* 가 있기 때문에 *항목 id* 를 사용 하 여 매우 많은 작업을 수행 하 고 데이터 저장소를 균등 하 게 분산 합니다.
* *항목 ID* 를 알고 있는 경우 항상 항목의 파티션 키를 알 수 있으므로 효율적인 시점 읽기를 쉽게 수행할 수 있습니다.

*항목 ID* 를 파티션 키로 선택 하는 경우 고려해 야 할 몇 가지 사항은 다음과 같습니다.

* *항목 ID* 가 파티션 키 인 경우 전체 컨테이너 전체에서 고유 식별자가 됩니다. 항목 *ID* 가 중복 된 항목을 포함할 수 없습니다.
* [실제 파티션이](partitioning-overview.md#physical-partitions)많은 읽기 전용 컨테이너를 사용 하는 경우 쿼리는 *항목 ID* 를 사용 하는 같음 필터가 있는 경우 더 효율적입니다.
* 여러 논리 파티션에서 저장 프로시저나 트리거를 실행할 수 없습니다.

## <a name="next-steps"></a>다음 단계

* [Azure Cosmos DB에서 프로 비전 된 처리량](request-units.md)에 대해 알아봅니다.
* [Azure Cosmos DB의 글로벌 배포](distribute-data-globally.md)에 대해 알아봅니다.
* [Azure Cosmos 컨테이너의 처리량을 프로비전](how-to-provision-container-throughput.md)하는 방법을 알아봅니다.
* [Azure Cosmos 데이터베이스의 처리량을 프로비전](how-to-provision-database-throughput.md)하는 방법을 알아봅니다.
