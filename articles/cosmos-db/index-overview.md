---
title: Azure Cosmos DB의 인덱싱
description: Azure Cosmos DB에서 인덱싱의 작동 방식을 파악하고
author: markjbrown
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 11/10/2018
ms.author: mjbrown
ms.openlocfilehash: c0525cfba16fb61f8388ae4d6a693be3bb71674c
ms.sourcegitcommit: 1f9e1c563245f2a6dcc40ff398d20510dd88fd92
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/14/2018
ms.locfileid: "51628532"
---
# <a name="indexing-in-azure-cosmos-db"></a>Azure Cosmos DB의 인덱싱

Azure Cosmos DB는 스키마에 구애받지 않는 데이터베이스이며 스키마나 인덱스 관리를 처리할 필요 없이 애플리케이션을 빠르게 반복할 수 있습니다. 기본적으로 Azure Cosmos DB는 개발자에게 스키마 또는 보조 인덱스를 요청하지 않고 컨테이너의 모든 항목을 자동으로 인덱싱합니다.

## <a name="items-as-trees"></a>트리로서의 항목

Azure Cosmos DB는 컨테이너에 있는 항목을 JSON 문서로 프로젝션하고 트리로 표시함으로써 여러 항목에 걸친 구조 및 인스턴스 값을 모두  **동적으로 인코딩된 구조**의 통합 개념으로 정규화합니다. 이 표현에서 속성 이름 및 해당 값 모두를 포함하는 JSON 문서의 각 레이블은 트리의 노드가 됩니다. 트리의 리프는 실제 값을 포함하고 중간 노드는 스키마 정보를 포함합니다. 다음 이미지는 컨테이너의 두 항목(1 및 2)에 대해 만든 트리를 나타냅니다.

![Azure Cosmos 컨테이너의 서로 다른 두 개의 항목을 표현하는 트리](./media/index-overview/indexing-as-tree.png)

의사 루트 노드는 아래 문서의 레이블에 해당하는 실제 노드의 부모로 작성됩니다. 중첩된 데이터 구조는 트리의 계층 구조를 만듭니다. 숫자 값(예: 0, 1, ...)을 사용하여 레이블이 지정된 인위적인 중간 노드는 열거형 및 배열 인덱스를 나타내는 데 사용됩니다.

## <a name="index-paths"></a>인덱스 경로

Azure Cosmos DB는 항목을 JSON 문서로, 인덱스를 트리로 프로젝션합니다. 그런 다음, 트리 내 경로에 대한 정책으로 조정할 수 있습니다. 인덱싱에서 경로를 포함하거나 제외하도록 선택할 수도 있습니다. 따라서 쿼리 패턴을 사전에 알고 있는 시나리오에서 쓰기 성능이 향상되고 인덱스 스토리지를 줄일 수 있습니다. 자세히 알아보려면 [인덱스 경로](index-paths.md)를 참조하세요.

## <a name="indexing-under-the-hood"></a>인덱싱: 내부 살펴보기

Azure Cosmos 데이터베이스는 자동 인덱싱을 데이터에 적용합니다. 여기서 특정 경로를 제외하도록 구성하지 않는 한 트리의 모든 경로가 인덱스됩니다.

Azure Cosmos 데이터베이스는 각 항목의 정보를 저장하고 쿼리 시 효율적인 표현을 활용하기 위해 반전된 인덱스 데이터 구조를 사용합니다. 인덱스 트리는 컨테이너의 개별 항목을 나타내는 트리의 모든 합집합을 사용하여 생성된 문서입니다. 인덱스 트리는 새 항목이 추가되거나 기존 항목이 컨테이너에서 업데이트되면 시간이 지남에 따라 증가합니다. 관계형 데이터베이스 인덱싱과는 달리, Azure Cosmos DB는 새로운 필드가 도입되면 인덱스를 처음부터 다시 시작하지 않으며 새로운 항목은 기존 구조에 추가됩니다. 

인덱스 트리의 각 노드는 용어라고 하는 레이블 및 위치 값, 게시물이라고 하는 항목의 ID를 포함하는 인덱스 항목입니다. 반전된 인덱스 그림의 중괄호에 있는 게시물(예: {1,2})은 지정된 레이블 값을 포함하는 문서1 및 문서2와 같은 항목에 해당합니다. 스키마 레이블 및 인스턴스 값 모두를 균일하게 처리하는 것은 모두 큰 인덱스 내에 있다는 점에서 중요한 의미가 있습니다. 여전히 리프에 있는 인스턴스 값은 반복되지 않으며, 스키마 레이블이 서로 다른 항목 간에서 서로 다른 역할에 있을 수 있지만 동일한 값입니다. 다음 이미지는 다른 항목에 대한 반전된 인덱스를 보여줍니다.

![인덱스 내부, 반전된 인덱싱](./media/index-overview/inverted-index.png)

> [!NOTE]
> 반전된 인덱스는 정보 검색 도메인의 검색 엔진에 사용되는 인덱싱 구조와 유사하게 나타날 수 있습니다. Azure Cosmos DB는 이 방법을 사용하여 사용자가 해당 스키마 구조에 관계 없이 모든 항목에 대한 데이터베이스를 검색할 수 있도록 합니다.

정규화된 경로의 경우 인덱스는 값의 형식 정보와 함께 루트에서 값까지의 모든 전달 경로를 인코딩합니다. 경로 및 값은 범위, 공간 종류와 같은 인덱싱의 다양한 형식을 제공하도록 인코딩됩니다. 값 인코딩은 경로 세트의 조합 또는 고유한 값을 제공하기 위해 설계되었습니다.

## <a name="querying-with-indexes"></a>인덱스를 사용한 쿼리

반전된 인덱스를 사용하면 쿼리에서 쿼리 조건자를 일치하는 문서를 신속하게 식별할 수 있습니다. 경로의 관점에서 스키마 및 인스턴스 값을 균일하게 다루면 반전된 인덱스도 트리입니다. 따라서 인덱스 및 결과는 유효한 JSON 문서로 직렬화할 수 있으며, 트리 표현으로 반환될 때 문서 자체로 반환될 수 있습니다. 이 방법을 사용하면 추가 쿼리 시 결과를 재귀적으로 사용할 수 있습니다. 다음 이미지는 지점 쿼리에서의 인덱싱 예제를 보여줍니다.  

![지점 쿼리 예제](./media/index-overview/index-point-query.png)

범위 쿼리의 경우 GermanTax는 쿼리 처리의 일부로 실행되는 사용자 정의 함수입니다. 사용자 정의 함수는 쿼리로 통합되는 다양한 프로그래밍 논리를 제공할 수 있는 등록된 Javascript 함수입니다. 다음 이미지는 범위 쿼리에서의 인덱싱 예제를 보여줍니다.

![범위 쿼리 예제](./media/index-overview/index-range-query.png)

## <a name="next-steps"></a>다음 단계

다음 문서에서 인덱싱에 대해 자세히 알아보세요.

- [인덱싱 정책](index-policy.md)
- [인덱싱 형식](index-types.md)
- [인덱스 경로](index-paths.md)
- [인덱싱 정책을 관리하는 방법](how-to-manage-indexing-policy.md)