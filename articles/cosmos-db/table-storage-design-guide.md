---
title: 확장 및 성능을 위한 Azure Cosmos DB 테이블 디자인
description: 'Azure 테이블 저장소 디자인 가이드: Azure Cosmos DB 및 Azure 테이블 저장소의 확장 가능 하고 성능이 뛰어난 테이블'
ms.service: cosmos-db
ms.subservice: cosmosdb-table
ms.topic: conceptual
ms.date: 05/21/2019
author: sakash279
ms.author: akshanka
ms.custom: seodec18
ms.openlocfilehash: 166076d366cbbf7bef24648772beaba9b3a88253
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/28/2020
ms.locfileid: "79246475"
---
# <a name="azure-table-storage-table-design-guide-scalable-and-performant-tables"></a>Azure 테이블 저장소 테이블 디자인 가이드: 확장 가능 하고 수행 가능한 테이블

[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

확장 가능하고 성능이 뛰어난 테이블을 디자인하려면 비용을 비롯한 다양한 요인을 고려해야 합니다. 이전에 관계형 데이터베이스에 대한 스키마를 디자인한 적이 있다면 이러한 고려 사항이 익숙할 것입니다. 그러나 Azure Table Storage와 관계형 모델 간에는 몇 가지 유사점이 있지만 중요한 차이점도 많이 있습니다. 이러한 차이점으로 인해 일반적으로 관계형 데이터베이스에 익숙한 사용자에게는 직관에 반하거나 잘못된 것으로 보일 수 있지만 Table Storage와 같은 NoSQL 키/값 저장소를 디자인하는 경우에는 매우 적절한 다른 디자인이 도출됩니다.

테이블 저장소는 수십억 개의 엔터티(관계형 데이터베이스 용어의 "행")를 포함하거나 대량 트랜잭션 볼륨을 지원해야 하는 데이터 집합을 포함하는 클라우드 규모의 응용 프로그램을 지원하도록 설계되었습니다. 따라서 데이터를 저장하는 방법에 대해 다르게 생각하고 Table 저장소의 작동 방식을 이해해야 합니다. 잘 설계된 NoSQL 데이터 저장소를 사용하면 관계형 데이터베이스를 사용하는 솔루션보다 훨씬 더 저렴한 비용으로 솔루션을 확장할 수 있습니다. 이 가이드에서는 이러한 항목에 대해 설명합니다.  

## <a name="about-azure-table-storage"></a>Azure 테이블 저장소 정보
이 섹션에서는 성능 및 확장성을 위한 설계와 특히 관련된 Table 저장소의 몇 가지 주요 기능을 중추적으로 다합니다. Azure 저장소 및 테이블 저장소를 처음 사용하는 경우 이 문서의 나머지 부분을 읽기 전에 [.NET을 사용하여](table-storage-how-to-use-dotnet.md) Azure Azure 저장소 [소개](../storage/common/storage-introduction.md) 및 Azure 테이블 저장소 를 시작하십시오. 이 가이드의 초점은 테이블 저장소에 있지만 Azure Queue 저장소 및 Azure Blob 저장소에 대한 몇 가지 설명과 솔루션의 테이블 저장소와 함께 사용할 수 있는 방법에 대한 설명이 포함되어 있습니다.  

테이블 저장소는 테이블 형식형식을 사용하여 데이터를 저장합니다. 표준 용어로, 테이블의 각 행은 엔터티를 나타내고 행은 해당 엔터티의 여러 속성을 저장합니다. 모든 엔터티에는 고유하게 식별하는 키 쌍과 Table Storage가 엔터티가 마지막으로 업데이트된 시기를 추적하는 데 사용하는 타임스탬프 열이 있습니다. 타임스탬프 필드는 자동으로 추가되며 임의의 값으로 타임스탬프를 수동으로 덮어쓸 수 없습니다. 테이블 저장소는 이 마지막 수정된 LMT(타임스탬프)를 사용하여 낙관적 동시성을 관리합니다.  

> [!NOTE]
> 테이블 저장소 REST API `ETag` 작업은 LMT에서 파생된 값도 반환합니다. 이 문서에서ETag 및 LMT는 동일한 기본 데이터를 참조하기 때문에 상호 교환적으로 사용됩니다.  
> 
> 

다음 예제에서는 직원 및 부서 엔터티를 저장하는 간단한 테이블 디자인을 보여 줍니다. 이 가이드의 뒷부분에 나오는 예제는 대부분 이 간단한 디자인을 기반으로 합니다.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>타임스탬프</th>
<th></th>
</tr>
<tr>
<td>Marketing</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>6월</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>department</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Marketing</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>Sales</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


지금까지 이 디자인은 관계형 데이터베이스의 테이블과 유사합니다. 주요 차이점은 필수 열과 동일한 테이블에 여러 엔터티 형식을 저장하는 기능입니다. 또한 **FirstName** 또는 **Age와**같은 각 사용자 정의 속성에는 관계형 데이터베이스의 열과 마찬가지로 정수 또는 문자열과 같은 데이터 형식이 있습니다. 그러나 관계형 데이터베이스와 달리 테이블 저장소의 스키마가 없는 특성은 속성에 각 엔터티에 동일한 데이터 형식이 필요하지 않음을 의미합니다. 복잡한 데이터 형식을 단일 속성에 저장하려면 JSON 또는 XML과 같은 직렬화된 형식을 사용해야 합니다. 자세한 내용은 [테이블 저장소 데이터 모델 이해를](https://msdn.microsoft.com/library/azure/dd179338.aspx)참조하십시오.

당신의 선택은 `PartitionKey` `RowKey` 좋은 테이블 디자인의 기본입니다. 테이블에 저장된 모든 엔터티에는 및 `PartitionKey` `RowKey`의 고유한 조합이 있어야 합니다. 관계형 데이터베이스 테이블의 키와 `PartitionKey` 마찬가지로 `RowKey` 및 값은 인덱싱되어 빠른 조회를 가능하게 하는 클러스터된 인덱스를 만듭니다. 그러나 테이블 저장소는 보조 인덱스를 만들지 않으므로 인덱싱된 두 개의 속성만 이 속성입니다(나중에 설명된 패턴 중 일부는 이 명백한 제한을 해결할 수 있는 방법을 보여 주어 도있습니다).  

테이블은 하나 이상의 파티션으로 구성되며, 대부분의 디자인 결정은 적합한 `PartitionKey` 파티션을 `RowKey` 선택하고 솔루션을 최적화하는 것입니다. 솔루션은 파티션으로 구성된 모든 엔터티를 포함하는 단일 테이블로 구성될 수 있지만 일반적으로 솔루션에는 여러 테이블이 있습니다. 표를 사용하면 엔터티를 논리적으로 구성하고 액세스 제어 목록을 사용하여 데이터에 대한 액세스를 관리할 수 있습니다. 단일 저장소 작업을 사용하여 전체 테이블을 삭제할 수 있습니다.  

### <a name="table-partitions"></a>테이블 파티션
계정 이름, 테이블 이름 `PartitionKey` 및 함께 테이블 저장소 엔터티를 저장 하는 저장소 서비스 내에서 파티션을 식별 합니다. 파티션은 엔터티에 대한 주소 지정 체계의 일부일 뿐만 아니라 트랜잭션 범위를 정의하고(이 문서의 후반부, [엔터티 그룹 트랜잭션](#entity-group-transactions)참조) 테이블 저장소 확장 방식의 기초를 형성합니다. 테이블 파티션에 대한 자세한 내용은 [테이블 저장소에 대한 성능 및 확장성 검사 목록을](../storage/tables/storage-performance-checklist.md)참조하십시오.  

테이블 저장소에서 개별 노드는 하나 이상의 완전한 파티션을 서비스하고 서비스는 노드 간에 파티션을 동적으로 로드밸런싱하여 확장합니다. 노드가 로드중인 경우 테이블 저장소는 해당 노드에서 서비스하는 파티션범위를 다른 노드로 분할할 수 있습니다. 트래픽이 가라앉으면 테이블 저장소는 조용한 노드에서 단일 노드로 파티션 범위를 병합할 수 있습니다.  

테이블 저장소의 내부 세부 정보 및 특히 파티션을 관리하는 방법에 대한 자세한 내용은 [Microsoft Azure Storage: 일관성이 높은 고가용성 클라우드 저장소 서비스를](https://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)참조하십시오.  

### <a name="entity-group-transactions"></a>엔터티 그룹 트랜잭션
테이블 저장소에서 엔터티 그룹 트랜잭션(EgT)은 여러 엔터티에서 원자성 업데이트를 수행하기 위한 유일한 기본 제공 메커니즘입니다. ET를 일괄 처리 *트랜잭션이라고도*합니다. ET는 동일한 파티션에 저장된 엔터티(특정 테이블에서 동일한 파티션 키 공유)에서만 작동할 수 있으므로 여러 엔터티에서 원자성 트랜잭션 동작이 필요할 때마다 해당 엔터티가 동일한 파티션에 있는지 확인합니다. 이는 여러 엔터티 형식을 동일한 테이블(및 파티션)에 유지하고 다른 엔터티 형식에 대해 여러 테이블을 사용하지 않는 이유입니다. 단일 EGT는 최대 100개의 엔터티에서 작동할 수 있습니다.  처리를 위해 여러 개의 동시 ET를 제출하는 경우 이러한 ET가 ET에서 공통적인 엔터티에서 작동하지 않도록 하는 것이 중요합니다. 그렇지 않으면 처리가 지연될 위험이 있습니다.

EGT는 디자인을 평가하기 위해 잠재적인 장단점에 대해서도 소개합니다. 파티션을 더 많이 사용하면 Azure에서 노드 간에 로드 밸런싱 요청을 더 많이 사용할 수 있으므로 응용 프로그램의 확장성이 향상됩니다. 그러나 이렇게 하면 응용 프로그램이 원자성 트랜잭션을 수행하고 데이터에 대한 강력한 일관성을 유지하는 기능이 제한될 수 있습니다. 또한 단일 노드에서 예상할 수 있는 트랜잭션 처리량을 제한할 수 있는 파티션 수준에서 특정 확장성 목표가 있습니다.

Azure 저장소 계정의 확장성 대상에 대한 자세한 내용은 [표준 저장소 계정에 대한 확장성 목표를](../storage/common/scalability-targets-standard-account.md)참조하세요. 테이블 저장소의 확장성 목표에 대한 자세한 내용은 [Table 저장소에 대한 확장성 및 성능 목표를](../storage/tables/scalability-targets.md)참조하십시오. 이 가이드의 뒷부분에 나오는 섹션에서는 이와 같은 장단점을 관리하는 데 도움이 되는 여러 가지 디자인 전략을 소개하고, 클라이언트 애플리케이션의 특정 요구 사항에 따라 파티션 키를 선택하는 최상의 방법을 설명합니다.  

### <a name="capacity-considerations"></a>용량 고려 사항
다음 표에는 Table 저장소 솔루션을 디자인할 때 알아야 할 몇 가지 주요 값이 포함되어 있습니다.  

| Azure Storage 계정의 총 용량 | 500TB |
| --- | --- |
| Azure Storage 계정에서 테이블의 수 |저장소 계정의 용량에 의해서만 제한됩니다. |
| 테이블에 있는 파티션 수 |저장소 계정의 용량에 의해서만 제한됩니다. |
| 파티션의 엔터티 수 |저장소 계정의 용량에 의해서만 제한됩니다. |
| 개별 엔터티의 크기 |최대 1MB이며 최대 255개의 속성(를 `PartitionKey` `RowKey`포함하여 `Timestamp`및). |
| 사이즈는`PartitionKey` |최대 1KB 크기의 문자열입니다. |
| 사이즈는`RowKey` |최대 1KB 크기의 문자열입니다. |
| 엔터티 그룹 트랜잭션의 크기 |트랜잭션에는 최소 100개의 엔터티가 포함될 수 있으며 페이로드의 크기는 4MB 미만이어야 합니다. EGT는 한 번에 하나의 엔터티만 업데이트할 수 있음 |

자세한 내용은 [테이블 서비스 데이터 모델 이해를](https://msdn.microsoft.com/library/azure/dd179338.aspx)참조하십시오.  

### <a name="cost-considerations"></a>비용 고려 사항
테이블 저장소는 비교적 저렴하지만 Table 저장소를 사용하는 솔루션에 대한 평가의 일부로 용량 사용량과 트랜잭션 수량에 대한 비용 예측을 포함해야 합니다. 그러나 대부분의 시나리오에서 솔루션의 성능이나 확장성을 향상시키기 위해 비정규화 또는 중복 데이터를 저장하는 것은 유효한 방법입니다. 가격 책정에 대한 자세한 내용은 [Azure Storage 가격](https://azure.microsoft.com/pricing/details/storage/)을 참조하세요.  

## <a name="guidelines-for-table-design"></a>테이블 디자인 지침
이러한 목록에는 테이블을 디자인할 때 염두에 두어야 할 몇 가지 주요 지침이 요약되어 있습니다. 이 가이드는 나중에 더 자세히 모두 해결합니다. 이러한 지침은 관계형 데이터베이스 디자인에 대해 일반적으로 따르는 지침과 다릅니다.  

*효율적으로 읽을* 수 있도록 테이블 스토리지 를 디자인:

* **읽기 작업이 많은 애플리케이션의 쿼리를 위해 디자인합니다.** 테이블을 디자인할 때 엔터티를 업데이트하는 방법을 고려하기 전에 실행할 쿼리(특히 대기 시간에 민감한 쿼리)에 대해 생각해 보십시오. 이는 일반적으로 솔루션의 효율성 및 성능에 영향을 줍니다.  
* **쿼리와 `PartitionKey` `RowKey` 쿼리를 모두 지정합니다.** 이와 같은 *포인트 쿼리는* 가장 효율적인 테이블 저장소 쿼리입니다.  
* **엔터티의 중복 복사본을 저장하는 것이 좋습니다.** 테이블 저장소는 저렴하므로 보다 효율적인 쿼리를 활성화하기 위해 동일한 엔터티를 여러 번 여러 번(다른 키)으로 저장하는 것이 좋습니다.  
* **데이터를 비정규화하는 것이 좋습니다.** 테이블 저장소는 저렴하므로 데이터를 비정규화하는 것이 좋습니다. 예를 들어 집계 데이터에 대한 쿼리에서 단일 엔터티에만 액세스하면 되도록 요약 엔터티를 저장합니다.  
* **복합 키 값을 사용하는 것이 좋습니다.** 당신이 가지고있는 유일한 `PartitionKey` 키는 `RowKey`및 . 예를 들어 복합 키 값을 사용하여 엔터티에 대한 대체 키 액세스 경로를 사용하도록 설정할 수 있습니다.  
* **쿼리 프로젝션을 사용합니다.** 필요한 필드만 선택하는 쿼리를 사용하여 네트워크를 통해 전송하는 데이터 양을 줄일 수 있습니다.  

*효율적으로 작성할* 수 있도록 테이블 저장소를 디자인합니다.  

* **핫 파티션을 만들지 마십시오.** 언제든 여러 파티션으로 요청을 분산할 수 있는 키를 선택합니다.  
* **트래픽 급증을 방지합니다.** 적절한 기간 동안 트래픽을 분산하고 트래픽 급증을 방지합니다.
* **각 엔터티 유형에 대해 별도의 테이블을 만들 필요는 없습니다.** 엔터티 유형 간에 원자성 트랜잭션이 필요한 경우 이러한 여러 엔터티 유형을 동일한 테이블의 동일한 파티션에 저장할 수 있습니다.
* **달성해야 하는 최대 처리량을 고려합니다.** Table 저장소의 확장성 목표를 알고 있어야 하며 설계로 인해 이를 초과하지 않도록 해야 합니다.  

이 가이드의 후반부에서는 이러한 모든 원칙을 실천하는 예제를 살펴보겠습니다.  

## <a name="design-for-querying"></a>쿼리를 위한 디자인
테이블 저장소는 읽기 집약적, 쓰기 집약적, 또는 둘의 혼합이 될 수 있습니다. 이 섹션에서는 읽기 작업을 효율적으로 지원하도록 설계하는 방법을 고려합니다. 일반적으로 읽기 작업을 효율적으로 지원하는 디자인은 쓰기 작업에도 효율적입니다. 그러나 쓰기 작업을 지원 하도록 디자인할 때 추가 고려 사항이 있습니다. 다음 섹션, [데이터 수정을 위한 디자인에](#design-for-data-modification)대해 설명합니다.

데이터를 효율적으로 읽을 수 있는 좋은 출발점은 "필요한 데이터를 검색하기 위해 응용 프로그램에서 실행해야 하는 쿼리는 무엇입니까?"  

> [!NOTE]
> 테이블 저장소를 사용하면 나중에 변경하기가 어렵고 비용이 많이 들기 때문에 디자인을 미리 수정하는 것이 중요합니다. 예를 들어 관계형 데이터베이스에서는 기존 데이터베이스에 인덱스를 추가하기만 하면 성능 문제를 해결할 수 있습니다. 테이블 저장소는 옵션이 아닙니다.  

### <a name="how-your-choice-of-partitionkey-and-rowkey-affects-query-performance"></a>선택한 방법 `PartitionKey` 및 `RowKey` 쿼리 성능에 미치는 영향
다음 예제에서는 Table storage가 직원 엔터티를 다음과 같은 구조로 저장한다고 `Timestamp` 가정합니다(대부분의 예제는 명확성을 위해 속성을 생략합니다).  

| 열 이름 | 데이터 형식 |
| --- | --- |
| `PartitionKey`(부서 이름) |String |
| `RowKey`(직원 ID) |String |
| `FirstName` |String |
| `LastName` |String |
| `Age` |정수 |
| `EmailAddress` |String |

다음은 테이블 저장소 쿼리를 디자인하기 위한 몇 가지 일반적인 지침입니다. 다음 예제에서 사용되는 필터 구문은 테이블 저장소 REST API에서 가져옵니다. 자세한 내용은 [엔터티 쿼리](https://msdn.microsoft.com/library/azure/dd179421.aspx)를 참조하십시오.  

* *포인트 쿼리는* 가장 효율적인 조회이며 대기 시간이 가장 적은 대용량 조회 또는 조회에 권장됩니다. 이러한 쿼리는 인덱스를 사용하여 `PartitionKey` 인덱스와 `RowKey` 값을 모두 지정하여 개별 엔터티를 효율적으로 찾을 수 있습니다. 예: `$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')`  
* 두 번째 는 *범위 쿼리입니다.* `PartitionKey`은 및 필터링 범위의 `RowKey` 값을 사용하여 두 개 이상의 엔터티를 반환합니다. 값은 `PartitionKey` 특정 파티션을 식별하고 `RowKey` 값은 해당 파티션의 엔터티 하위 집합을 식별합니다. 예: `$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'`  
* 세 번째 가장 좋은 *파티션 스캔입니다.* `PartitionKey`다른 비키 속성에 대해 에서 및 필터를 사용하고 두 개 이상의 엔터티를 반환할 수 있습니다. 값은 `PartitionKey` 특정 파티션을 식별하고 속성 값은 해당 파티션의 엔터티 하위 집합에 대해 선택합니다. 예: `$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'`  
* *테이블 검색에는* `PartitionKey`을 포함하지 않으며 일치하는 엔터티에 대해 테이블을 구성하는 모든 파티션을 검색하기 때문에 비효율적입니다. 필터에서 를 사용하는지 여부에 관계없이 테이블 스캔을 `RowKey`수행합니다. 예: `$filter=LastName eq 'Jones'`  
* 여러 엔터티를 반환하는 Azure Table `PartitionKey` 저장소 `RowKey` 쿼리는 해당 엔터티를 정렬하고 순서대로 정렬합니다. 클라이언트의 엔터티를 사용하지 않으려면 가장 `RowKey` 일반적인 정렬 순서를 정의하는 a를 선택합니다. Azure Cosmos DB의 Azure Table API에서 반환된 쿼리 결과는 파티션 키 또는 행 키로 정렬되지 않습니다. 자세한 기능 차이 목록에 대해서는 [Azure Cosmos DB 및 Azure Table Storage의 Table API 간 차이점](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)을 참조하세요.

값에**or**따라 `RowKey` 필터를 지정하기 위해 " 또는 "를 사용하면 파티션 검색이 생성되며 범위 쿼리로 처리되지 않습니다. 따라서 다음과 `$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')`같은 필터를 사용하는 쿼리는 사용하지 마십시오.  

저장소 클라이언트 라이브러리를 사용하여 효율적인 쿼리를 실행하는 클라이언트 쪽 코드의 예는 다음과 같은 경우를 참조하십시오.  

* [저장소 클라이언트 라이브러리를 사용하여 포인트 쿼리 실행](#run-a-point-query-by-using-the-storage-client-library)
* [LINQ를 사용하여 여러 엔터티 검색](#retrieve-multiple-entities-by-using-linq)
* [서버 쪽 프로젝션](#server-side-projection)  

동일한 테이블에 저장된 여러 엔터티 유형을 처리할 수 있는 클라이언트 쪽 코드의 예는 다음을 참조하세요.  

* [유형이 다른 엔터티 형식 사용](#work-with-heterogeneous-entity-types)  

### <a name="choose-an-appropriate-partitionkey"></a>적절한 선택`PartitionKey`
EGT(일관성 보장)를 여러 파티션에 배포해야 하는 요구 사항(확장 가능한 솔루션을 보장하기 위해)과 EGT 사용을 사용하도록 `PartitionKey` 설정해야 합니다.  

한 가지 극단적인 경우 모든 엔터티를 단일 파티션에 저장할 수 있습니다. 그러나 이렇게 하면 솔루션의 확장성이 제한될 수 있으며 Table 저장소에서 요청을 로드 밸류업할 수 없게 됩니다. 다른 극단적인 경우 파티션당 하나의 엔터티를 저장할 수 있습니다. 이는 확장성이 뛰어나고 Table 저장소에서 요청을 로드 밸류에이블화할 수 있지만 엔터티 그룹 트랜잭션을 사용하지 못하게 합니다.  

이상적인 `PartitionKey` 기능을 사용하면 효율적인 쿼리를 사용할 수 있으며 솔루션의 확장성을 보장하기에 충분한 파티션이 있습니다. 일반적으로 엔터티에 충분한 파티션에 엔터티를 배포하는 적절한 속성이 있음을 알 수 있습니다.

> [!NOTE]
> 예를 들어 사용자 또는 직원에 대한 정보를 `UserID` 저장하는 시스템에서는 `PartitionKey`좋은 수 있습니다. 특정 `UserID` 엔터티를 파티션 키로 사용하는 엔터티가 여러 개 있을 수 있습니다. 사용자에 대한 데이터를 저장하는 각 엔터티는 단일 파티션으로 그룹화됩니다. 이러한 엔터티는 ET를 통해 액세스할 수 있지만 확장성이 높습니다.
> 
> 

엔터티를 `PartitionKey` 삽입, 업데이트 및 삭제하는 방법과 관련된 추가 고려 사항이 있습니다. 자세한 내용은 이 문서의 다음 부분에서 [데이터 수정을 위한 설계를](#design-for-data-modification) 참조하십시오.  

### <a name="optimize-queries-for-table-storage"></a>테이블 스토리지를 위한 쿼리 최적화
테이블 저장소는 단일 클러스터된 `PartitionKey` 인덱스의 `RowKey` 및 값을 사용하여 엔터티를 자동으로 인덱싱합니다. 이것이 포인트 쿼리가 가장 효율적으로 사용하는 이유입니다. 그러나 및 `RowKey`에 클러스터된 인덱스에 있는 인덱스 이외의 `PartitionKey` 인덱스는 없습니다.

대부분의 디자인은 여러 조건을 기반으로 엔터티를 조회할 수 있어야 한다는 요구 사항을 준수해야 합니다. 예를 들어 전자 메일, 직원 ID 또는 성을 기반으로 직원 엔터티를 찾습니다. [테이블 디자인 패턴](#table-design-patterns) 섹션의 다음 패턴은 이러한 유형의 요구 사항을 해결합니다. 또한 이 패턴은 Table 저장소가 보조 인덱스를 제공하지 않는다는 사실을 해결하는 방법에 대해서도 설명합니다.  

* [파티션 내 보조 인덱스 패턴](#intra-partition-secondary-index-pattern): 동일한 파티션에 `RowKey` 서로 다른 값을 사용하여 각 엔터티의 여러 복사본을 저장합니다. 이를 통해 빠르고 효율적인 조회를 가능하게 하고 `RowKey` 다른 값을 사용하여 정렬 순서를 대체할 수 있습니다.  
* [파티션 간 보조 인덱스 패턴](#inter-partition-secondary-index-pattern): 별도의 파티션이나 별도의 테이블에 서로 다른 `RowKey` 값을 사용하여 각 엔터티의 여러 복사본을 저장합니다. 이를 통해 빠르고 효율적인 조회를 가능하게 하고 `RowKey` 다른 값을 사용하여 정렬 순서를 대체할 수 있습니다.  
* [인덱스 엔터티 패턴](#index-entities-pattern): 엔터티 목록을 반환하는 효율적인 검색을 사용하도록 인덱스 엔터티를 유지 관리합니다.  

### <a name="sort-data-in-table-storage"></a>테이블 저장소의 데이터 정렬

테이블 저장소는 에 따라 `PartitionKey` `RowKey`오름차순으로 정렬된 쿼리 결과를 반환합니다.

> [!NOTE]
> Azure Cosmos DB의 Azure Table API에서 반환된 쿼리 결과는 파티션 키 또는 행 키로 정렬되지 않습니다. 자세한 기능 차이 목록에 대해서는 [Azure Cosmos DB 및 Azure Table Storage의 Table API 간 차이점](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)을 참조하세요.

테이블 저장소의 키는 문자열 값입니다. 숫자 값이 올바르게 정렬되도록 하려면 고정 길이로 변환하고 0으로 고정해야 합니다. 예를 들어 정수 값으로 `RowKey` 사용하는 직원 ID 값이 경우 직원 ID **123을** **00000123으로**변환해야 합니다. 

많은 애플리케이션에서 서로 다른 순서로 정렬(예: 이름 또는 입사 날짜별로 직원 정렬)된 데이터를 사용할 수 있도록 요구하고 있습니다. [테이블 디자인](#table-design-patterns) 패턴 섹션의 다음 패턴은 엔터티에 대한 정렬 순서를 대체하는 방법을 설명합니다.  

* [파티션 내 보조 인덱스 패턴](#intra-partition-secondary-index-pattern): 동일한 파티션에 `RowKey` 서로 다른 값을 사용하여 각 엔터티의 여러 복사본을 저장합니다. 이를 통해 빠르고 효율적인 조회를 가능하게 하고 `RowKey` 다른 값을 사용하여 정렬 순서를 대체할 수 있습니다.  
* [파티션 간 보조 인덱스 패턴](#inter-partition-secondary-index-pattern): 별도의 테이블에 `RowKey` 별도의 파티션에 서로 다른 값을 사용하여 각 엔터티의 여러 복사본을 저장합니다. 이를 통해 빠르고 효율적인 조회를 가능하게 하고 `RowKey` 다른 값을 사용하여 정렬 순서를 대체할 수 있습니다.
* [꼬리 패턴 로그](#log-tail-pattern): 역날짜 및 시간 순서로 `RowKey` 정렬되는 값을 사용하여 파티션에 가장 최근에 추가된 *n* 엔터티를 검색합니다.  

## <a name="design-for-data-modification"></a>데이터 수정을 위한 디자인
이 섹션에서는 삽입, 업데이트 및 삭제를 최적화하기 위한 디자인 고려 사항을 중점적으로 알아봅니다. 경우에 따라 데이터 수정에 최적화된 디자인에 대해 쿼리에 최적화된 디자인 간의 장단점을 평가해야 합니다. 이 평가는 관계형 데이터베이스에 대한 디자인에서 수행하는 것과 유사합니다(디자인 장단점을 관리하는 기술은 관계형 데이터베이스에서 다르지만). 테이블 [디자인 패턴](#table-design-patterns) 섹션에서는 테이블 저장소에 대한 몇 가지 세부 디자인 패턴을 설명하고 이러한 장단점 중 일부를 강조합니다. 실제로 엔터티 쿼리에 최적화된 많은 디자인도 엔터티 수정에도 적합합니다.  

### <a name="optimize-the-performance-of-insert-update-and-delete-operations"></a>삽입, 업데이트 및 삭제 작업 성능 최적화
엔터티를 업데이트하거나 삭제하려면 `PartitionKey` 및 `RowKey` 값을 사용하여 엔터티를 식별할 수 있어야 합니다. 이와 관련하여 엔터티 `PartitionKey` 를 `RowKey` 선택하고 수정하는 경우 포인트 쿼리를 지원하기 위해 선택한 것과 유사한 기준을 따라야 합니다. 엔터티를 가능한 한 효율적으로 식별하려고 합니다. 비효율적인 파티션 이나 테이블 검색을 사용 하 여 엔터티를 검색 하 `PartitionKey` `RowKey` 고 업데이트 하거나 삭제 하는 데 필요한 값을 검색 하지 않으려는 경우.  

섹션 표 디자인 [패턴의](#table-design-patterns) 다음 패턴은 삽입, 업데이트 및 삭제 작업의 성능을 최적화합니다.  

* [대용량 삭제 패턴](#high-volume-delete-pattern): 모든 엔터티를 저장하여 대용량 엔터티를 삭제하여 자체 별도의 테이블에 동시에 삭제할 수 있습니다. 테이블을 삭제하여 엔터티를 삭제합니다.  
* [데이터 계열 패턴](#data-series-pattern): 전체 데이터 계열을 단일 엔터티에 저장하여 요청 횟수를 최소화합니다.  
* [와이드 엔터티 패턴](#wide-entities-pattern): 여러 물리적 엔터티를 사용하여 252개 이상의 속성을 가진 논리 엔터티를 저장합니다.  
* [큰 엔터티 패턴](#large-entities-pattern): Blob 저장소를 사용하여 큰 속성 값을 저장합니다.  

### <a name="ensure-consistency-in-your-stored-entities"></a>저장된 엔터티의 일관성 유지
데이터 수정을 최적화하기 위한 키 선택에 영향을 주는 다른 주요 요소는 원자성 트랜잭션을 사용하여 일관성을 유지하는 방법입니다. EGT는 동일한 파티션에 저장된 엔터티에서만 작동합니다.  

[테이블 디자인 패턴](#table-design-patterns) 섹션의 다음 패턴은 일관성 관리를 다룹니다.  

* [파티션 내 보조 인덱스 패턴](#intra-partition-secondary-index-pattern): 동일한 파티션에 `RowKey` 서로 다른 값을 사용하여 각 엔터티의 여러 복사본을 저장합니다. 이를 통해 빠르고 효율적인 조회를 가능하게 하고 `RowKey` 다른 값을 사용하여 정렬 순서를 대체할 수 있습니다.  
* [파티션 간 보조 인덱스 패턴](#inter-partition-secondary-index-pattern): 별도의 파티션이나 별도의 테이블에 서로 다른 `RowKey` 값을 사용하여 각 엔터티의 여러 복사본을 저장합니다. 이를 통해 빠르고 효율적인 조회를 가능하게 하고 `RowKey` 다른 값을 사용하여 정렬 순서를 대체할 수 있습니다.  
* [결국 일관된 트랜잭션 패턴](#eventually-consistent-transactions-pattern): Azure 큐를 사용하여 파티션 경계 또는 저장소 시스템 경계에서 결국 일관된 동작을 활성화합니다.
* [인덱스 엔터티 패턴](#index-entities-pattern): 엔터티 목록을 반환하는 효율적인 검색을 사용하도록 인덱스 엔터티를 유지 관리합니다.  
* [비정규화 패턴](#denormalization-pattern): 단일 포인트 쿼리로 필요한 모든 데이터를 검색할 수 있도록 관련 데이터를 단일 엔터티에 함께 결합합니다.  
* [데이터 계열 패턴](#data-series-pattern): 전체 데이터 계열을 단일 엔터티에 저장하여 요청 횟수를 최소화합니다.  

자세한 내용은 이 문서의 [후반부에서 엔터티 그룹 트랜잭션을](#entity-group-transactions) 참조하세요.  

### <a name="ensure-your-design-for-efficient-modifications-facilitates-efficient-queries"></a>효율적인 수정을 위한 디자인이 효율적인 쿼리에도 유용
대부분의 경우 효율적인 쿼리를 위한 디자인은 효율적인 수정으로 이어지지만 항상 특정 시나리오에 이 사항이 적용되는지 평가해야 합니다. [테이블 디자인](#table-design-patterns) 섹션의 일부 패턴은 엔터티 쿼리와 수정 간의 장단점을 명시적으로 평가하며 항상 각 작업 유형의 수를 고려해야 합니다.  

[테이블 디자인](#table-design-patterns) 패턴 섹션의 다음 패턴은 효율적인 쿼리를 위한 설계와 효율적인 데이터 수정을 위한 설계 간의 장단점을 해결합니다.  

* [복합 키 패턴](#compound-key-pattern) `RowKey` : 복합 값을 사용하여 클라이언트가 단일 포인트 쿼리로 관련 데이터를 조회할 수 있도록 합니다.  
* [꼬리 패턴 로그](#log-tail-pattern): 역날짜 및 시간 순서로 `RowKey` 정렬되는 값을 사용하여 파티션에 가장 최근에 추가된 *n* 엔터티를 검색합니다.  

## <a name="encrypt-table-data"></a>테이블 데이터 암호화
.NET Azure Storage 클라이언트 라이브러리는 삽입 및 바꾸기 작업에 대한 문자열 엔터티 속성의 암호화를 지원합니다. 암호화된 문자열은 서비스에 이진 속성으로 저장되며 암호 해독 후 문자열로 다시 변환됩니다.    

테이블의 경우, 암호화 정책 외에도 사용자가 암호화할 속성을 지정해야 합니다. `EncryptProperty` 특성(파생POCO `TableEntity`엔터티)을 지정하거나 요청 옵션에서 암호화 확인자를 지정합니다. 암호화 확인자는 파티션 키, 행 키 및 속성 이름을 가져와 해당 속성을 암호화할지 여부를 나타내는 부울을 반환하는 대리자입니다. 암호화 하는 동안 클라이언트 라이브러리는 이 정보를 사용 하 여 와이어에 쓰는 동안 속성을 암호화 해야 하는지 여부를 결정 합니다. 대리자 속성은 암호화 하는 방법 논리의 가능성도 제공 합니다. 예를 들어 X인 경우 속성 A를 암호화하고 속성 A와 B를 암호화합니다. 엔터티를 읽거나 쿼리하는 동안 이 정보를 제공할 필요는 없습니다.

병합은 현재 지원되지 않습니다. 다른 키를 사용하여 이전에 속성의 하위 집합이 암호화되었을 수 있으므로 새 속성을 병합하고 메타데이터를 업데이트하기만 하면 데이터가 손실됩니다. 병합하려면 서비스에서 기존 엔터티를 읽기 위해 추가 서비스 호출을 하거나 속성당 새 키를 사용해야합니다. 둘 다 성능상의 이유로 적합하지 않습니다.     

테이블 데이터 암호화에 대한 자세한 내용은 [Microsoft Azure 저장소에 대한 클라이언트 측 암호화 및 Azure 키 자격 증명 모음을](../storage/common/storage-client-side-encryption.md)참조하십시오.  

## <a name="model-relationships"></a>관계 모델
도메인 모델 빌드는 복잡한 시스템의 디자인에서 중요한 단계입니다. 일반적으로 모델링 프로세스를 사용하여 비즈니스 도메인을 이해하고 시스템 디자인을 알리는 방법으로 엔터티와 엔터티 간의 관계를 식별합니다. 이 섹션에서는 도메인 모델에 있는 일부 공통 관계 유형을 Table 저장소용 디자인으로 변환하는 방법에 대해 중점합니다. 논리적 데이터 모델에서 실제 NoSQL 기반 데이터 모델로 매핑하는 프로세스는 관계형 데이터베이스를 디자인할 때 사용되는 프로세스와 다릅니다. 관계형 데이터베이스 디자인은 일반적으로 중복성을 최소화하는 데 최적화된 데이터 정규화 프로세스를 가정합니다. 또한 이러한 디자인은 데이터베이스 작동 방식의 구현을 추상화하는 선언적 쿼리 기능을 가정합니다.  

### <a name="one-to-many-relationships"></a>일대다 관계
비즈니스 도메인 개체 간의 일대다 관계는 빈번하게 발생합니다. 예를 들어 하나의 부서에 여러 직원이 있는 경우가 여기에 해당합니다. Table 저장소에서 일대다 관계를 구현하는 방법에는 여러 가지가 있으며 각 경우 특정 시나리오와 관련이 있을 수 있는 장단점이 있습니다.  

수만 개의 부서와 직원 엔터티가 있는 대규모 다국적 기업의 예를 생각해 보십시오. 모든 부서에는 많은 직원이 있으며 각 직원은 하나의 특정 부서와 연결됩니다. 한 가지 방법은 다음과 같이 별도의 부서 및 직원 엔터티를 저장하는 것입니다.  

![부서 엔터티 및 직원 엔터티를 보여 주면 그래픽][1]

이 예제에서는 값을 기반으로 형식 간의 암시적 일대다 관계를 보여 주습니다. `PartitionKey` 각 부서에는 여러 직원이 있을 수 있습니다.  

또한 이 예에서는 부서 엔터티와 해당 관련 직원 엔터티가 동일한 파티션에 있습니다. 다른 엔터티 유형에 대해 다른 파티션, 테이블 또는 저장소 계정을 사용하도록 선택할 수 있습니다.  

다른 방법은 다음 예제와 같이 데이터를 비정규화하고 정규화되지 않은 부서 데이터가 있는 직원 엔터티만 저장하는 것입니다. 이 특정 시나리오에서는 부서 관리자의 세부 정보를 변경할 수 있어야 하는 요구 사항이 있는 경우 이 비정규화 된 접근 방식이 최선이 아닐 수 있습니다. 이렇게 하려면 부서의 모든 직원을 업데이트해야 합니다.  

![직원 엔터티 그래픽][2]

자세한 내용은 이 가이드의 뒷부분에 있는 [비정규화 패턴](#denormalization-pattern) 을 참조하세요.  

다음 표에는 일대다 관계가 있는 직원 및 부서 엔터티를 저장하기 위한 각 접근 방식의 장단점을 요약한 것입니다. 또한 다양한 작업을 수행할 것으로 예상되는 빈도도 고려해야 합니다. 해당 작업이 자주 발생하지 않는 경우에만 비용이 많이 드는 작업을 포함하는 디자인을 사용할 수 있습니다.  

<table>
<tr>
<th>접근 방식</th>
<th>장점</th>
<th>단점</th>
</tr>
<tr>
<td>별도의 엔터티 유형, 동일한 파티션, 동일한 테이블</td>
<td>
<ul>
<li>단일 작업으로 부서 엔터티를 업데이트할 수 있습니다.</li>
<li>직원 엔터티를 업데이트/삽입/삭제할 때마다 부서 엔터티를 수정해야 하는 경우 EGT를 사용하여 일관성을 유지할 수 있습니다. 예를 들어 각 부서의 직원 수를 유지 관리하는 경우가 여기에 해당됩니다.</li>
</ul>
</td>
<td>
<ul>
<li>일부 클라이언트 활동에 대해 직원과 부서 엔터티를 모두 검색해야 할 수 있습니다.</li>
<li>스토리지 작업이 동일한 파티션에서 발생합니다. 트랜잭션 량이 많으면 핫스팟이 발생할 수 있습니다.</li>
<li>EGT를 사용하여 직원을 새 부서로 이동할 수 없습니다.</li>
</ul>
</td>
</tr>
<tr>
<td>별도의 엔터티 형식, 서로 다른 파티션, 테이블 또는 스토리지 계정</td>
<td>
<ul>
<li>단일 작업으로 부서 엔터티 또는 직원 엔터티를 업데이트할 수 있습니다.</li>
<li>트랜잭션 볼륨이 많을수록 더 많은 파티션에 부하를 분산시킬 수 있습니다.</li>
</ul>
</td>
<td>
<ul>
<li>일부 클라이언트 활동에 대해 직원과 부서 엔터티를 모두 검색해야 할 수 있습니다.</li>
<li>직원을 업데이트/삽입/삭제하고 부서를 업데이트할 때 ET를 사용하여 일관성을 유지할 수 없습니다. 예를 들어 부서 엔터티의 직원 수를 업데이트하는 경우가 여기에 해당합니다.</li>
<li>EGT를 사용하여 직원을 새 부서로 이동할 수 없습니다.</li>
</ul>
</td>
</tr>
<tr>
<td>단일 엔터티 유형으로 비정규화</td>
<td>
<ul>
<li>단일 요청으로 필요한 모든 정보를 검색할 수 있습니다.</li>
</ul>
</td>
<td>
<ul>
<li>부서 정보를 업데이트해야 하는 경우 일관성을 유지하는 데 많은 비용이 들 수 있습니다(부서의 모든 직원을 업데이트해야 합니다).</li>
</ul>
</td>
</tr>
</table>

이러한 옵션 중에서 선택하는 방법과 가장 중요한 장단점 중 어느 것이 가장 중요한지 는 특정 응용 프로그램 시나리오에 따라 다릅니다. 예를 들어 부서 엔터티를 얼마나 자주 수정합니까? 모든 직원 쿼리에 추가 부서 정보가 필요합니까? 파티션 또는 저장소 계정의 확장성 제한에 얼마나 근접합니까?  

### <a name="one-to-one-relationships"></a>일대일 관계
도메인 모델에는 엔터티 간의 일대일 관계가 포함될 수 있습니다. Table 저장소에서 일대일 관계를 구현해야 하는 경우 두 엔터티를 모두 검색해야 할 때 두 관련 엔터티를 연결하는 방법도 선택해야 합니다. 이 링크는 키 값의 규칙을 기반으로 암시적이거나 각 엔터티의 `PartitionKey` 형식및 `RowKey` 값에 대한 링크를 해당 엔터티에 저장하여 명시적일 수 있습니다. 관련 엔터티를 동일한 파티션에 저장해야 하는지 여부에 대한 자세한 내용은 [일대다 관계](#one-to-many-relationships)섹션을 참조하세요.  

테이블 저장소에서 일대일 관계를 구현할 수 있는 구현 고려 사항도 있습니다.  

* 큰 엔터티 처리(자세한 내용은 [큰 엔터티 패턴](#large-entities-pattern)참조).  
* 액세스 컨트롤 구현(자세한 내용은 [공유 액세스 시그니처를 사용할](#control-access-with-shared-access-signatures)수 있는 액세스 제어 참조).  

### <a name="join-in-the-client"></a>클라이언트에 조인
Table 저장소에서 관계를 모델링하는 방법이 있지만 Table 저장소를 사용하는 두 가지 주요 이유는 확장성과 성능이라는 점을 잊지 마십시오. 솔루션의 성능과 확장성을 손상시키는 많은 관계를 모델링하는 경우 테이블 디자인에 모든 데이터 관계를 빌드해야 하는지 자문해 보아야 합니다. 클라이언트 응용 프로그램에서 필요한 조인을 수행하도록 허용하면 설계를 단순화하고 솔루션의 확장성과 성능을 향상시킬 수 있습니다.  

예를 들어 자주 변경되지 않는 데이터가 포함된 작은 테이블이 있는 경우 이 데이터를 한 번 검색하여 클라이언트에 캐시할 수 있습니다. 그러면 동일한 데이터를 검색하기 위한 반복 작업을 방지할 수 있습니다. 이 가이드에서 살펴본 예제에서는 소규모 조직의 부서 집합이 작고 자주 변경되지 않을 수 있습니다. 따라서 클라이언트 응용 프로그램이 한 번 다운로드하고 조회 데이터로 캐시할 수 있는 데이터에 적합합니다.  

### <a name="inheritance-relationships"></a>상속 관계
클라이언트 응용 프로그램이 비즈니스 엔터티를 나타내기 위해 상속 관계의 일부를 구성하는 클래스 집합을 사용하는 경우 Table 저장소에 해당 엔터티를 쉽게 유지할 수 있습니다. 예를 들어 클라이언트 응용 프로그램에 정의된 다음과 같은 클래스 `Person` 집합이 있는 경우 추상 클래스가 있을 수 있습니다.

![상속 관계 다이어그램][3]

단일 `Person` 테이블을 사용하여 테이블 저장소에서 두 개의 구체적인 클래스의 인스턴스를 지속할 수 있습니다. 다음과 같은 엔터티를 사용합니다.  

![고객 엔터티 및 직원 엔터티를 표시하는 그래픽][4]

클라이언트 코드의 동일한 테이블에서 여러 엔터티 형식으로 작업하는 것에 대한 자세한 내용은 이 가이드의 후반부에서 [이기종 엔터티 형식으로 작업하는 경우를](#work-with-heterogeneous-entity-types) 참조하십시오. 이 섹션에서는 클라이언트 코드에서 엔터티 유형을 인식하는 방법에 대한 예제를 제공합니다.  

## <a name="table-design-patterns"></a>테이블 디자인 패턴
이전 섹션에서는 쿼리를 사용하여 엔터티 데이터를 검색하고 엔터티 데이터를 삽입, 업데이트 및 삭제하는 방법에 대해 배웠습니다. 이 섹션에서는 테이블 저장소에 사용하기에 적합한 몇 가지 패턴에 대해 설명합니다. 또한 이 가이드에서 이전에 제기된 몇 가지 문제와 장단점을 실질적으로 해결할 수 있는 방법을 살펴보겠습니다. 다음 다이어그램은 서로 다른 패턴 간의 관계를 요약합니다.  

![테이블 디자인 패턴 다이어그램][5]

패턴 맵은 이 가이드에 설명되어 있는 패턴(파란색)과 패턴 반대(주황색) 간의 일부 관계를 강조 표시됩니다. 물론 고려할 만한 다른 많은 패턴도 있습니다. 예를 들어 테이블 저장소의 주요 시나리오 중 하나는 명령 쿼리 [책임 분리](https://msdn.microsoft.com/library/azure/jj554200.aspx) 패턴에서 [구체화된 뷰](https://msdn.microsoft.com/library/azure/dn589782.aspx) 패턴을 사용하는 것입니다.  

### <a name="intra-partition-secondary-index-pattern"></a>파티션 간 보조 인덱스 패턴
동일한 파티션에 서로 다른 `RowKey` 값을 사용하여 각 엔터티의 여러 복사본을 저장합니다. 이를 통해 빠르고 효율적인 조회를 가능하게 하고 `RowKey` 다른 값을 사용하여 정렬 순서를 대체할 수 있습니다. ET를 사용하여 복사본 간의 업데이트를 일관되게 유지할 수 있습니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
테이블 저장소는 및 `PartitionKey` `RowKey` 값을 사용하여 엔터티를 자동으로 인덱싱합니다. 이렇게 하면 클라이언트 응용 프로그램이 이러한 값을 사용하여 엔터티를 효율적으로 검색할 수 있습니다. 예를 들어 다음 테이블 구조를 사용하여 클라이언트 응용 프로그램은 지점 쿼리를 사용하여 부서 이름과 직원 `PartitionKey` ID(및 `RowKey` 값)를 사용하여 개별 직원 엔터티를 검색할 수 있습니다. 또한 클라이언트는 각 부서 내에서 직원 ID별로 정렬된 엔터티를 검색할 수 있습니다.

![직원 엔터티 그래픽][6]

전자 메일 주소와 같은 다른 속성의 값을 기반으로 직원 엔터티를 찾으려면 보다 효율적인 파티션 검사를 사용하여 일치하는 개체를 찾아야 합니다. 이는 테이블 저장소가 보조 인덱스를 제공하지 않기 때문입니다. 또한 주문과 다른 `RowKey` 순서로 정렬된 직원 목록을 요청할 수 있는 옵션은 없습니다.  

#### <a name="solution"></a>해결 방법
보조 인덱스가 부족한 경우 각 엔터티의 여러 복사본을 저장하고 각 복사본은 `RowKey` 다른 값을 사용하여 저장할 수 있습니다. 다음 구조의 엔터티를 저장하는 경우 전자 메일 주소 또는 직원 ID를 기반으로 직원 엔터티를 효율적으로 검색할 수 있습니다. 에 `RowKey` `empid_`대한 접두사 `email_` 값을 통해 다양한 전자 메일 주소 또는 직원 아이디를 사용하여 단일 직원 또는 직원 범위에 대해 쿼리할 수 있습니다.  

![RowKey 값이 다양한 직원 엔터티를 보여주는 그래픽][7]

다음 두 필터 기준(직원 ID로 조회한 필터 기준과 전자 메일 주소로 조회하는 필터 기준)은 모두 포인트 쿼리를 지정합니다.  

* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')  
* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')  

직원 엔터티 의 범위를 쿼리하는 경우 직원 ID 순서로 정렬된 범위 또는 전자 메일 주소 순서로 정렬된 범위를 지정할 수 있습니다. 에서 적절한 접두사가 있는 `RowKey`엔터티를 쿼리합니다.  

* 000100에서 000199 범위의 직원 ID가 있는 영업 부서의 모든 직원을 찾으려면 $filter=(PartitionKey eq 'sales') 및 (RowKey ge 'empid_000100') 및 (RowKey le 'empid_000199')  
* "a"로 시작하는 전자 메일 주소가 있는 영업 부서의 모든 직원을 찾으려면 $filter=(PartitionKey eq 'sales') 및 (RowKey ge 'email_a') 및 (RowKey lt 'email_b')  
  
앞의 예제에서 사용되는 필터 구문은 테이블 저장소 REST API에서 가져옵니다. 자세한 내용은 [엔터티 쿼리](https://msdn.microsoft.com/library/azure/dd179421.aspx)를 참조하십시오.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 테이블 저장소는 사용하기가 상대적으로 저렴하므로 중복 데이터를 저장하는 데 드는 비용 오버헤드가 큰 문제가 되지 않습니다. 그러나 항상 예상되는 저장소 요구 사항에 따라 디자인 비용을 평가하고 클라이언트 응용 프로그램이 실행할 쿼리를 지원하기 위해 중복 엔터티만 추가해야 합니다.  
* 보조 인덱스 엔터티는 원래 엔터티와 동일한 파티션에 저장되므로 개별 파티션의 확장성 목표를 초과하지 않도록 해야 합니다.  
* EGT를 사용하여 엔터티의 두 복사본을 원자성으로 업데이트하는 방식으로 중복 엔터티를 서로 일관성 있게 유지할 수 있습니다. 이는 엔터티의 모든 복사본을 동일한 파티션에 저장해야 함을 의미합니다. 자세한 내용은 [엔터티 그룹 트랜잭션 사용을](#entity-group-transactions)참조하십시오.  
* 에 사용되는 값은 각 엔터티에 대해 `RowKey` 고유해야 합니다. 복합 키 값을 사용하는 것이 좋습니다.  
* (예: employee ID `RowKey` 000223)의 패딩 숫자 값은 상한및 하한을 기반으로 올바른 정렬 및 필터링을 가능하게 합니다.  
* 엔터티의 모든 속성을 복제할 필요는 없습니다. 예를 들어 직원의 사용 연령에 전자 메일 주소를 `RowKey` 사용하여 엔터티를 조회하는 쿼리에 다음 구조가 있을 수 있습니다.

  ![직원 엔터티 그래픽][8]

* 일반적으로 중복 데이터를 저장하고 하나의 쿼리를 사용하여 엔터티를 찾고 다른 쿼리를 사용하여 필요한 데이터를 조회하는 것보다 단일 쿼리로 필요한 모든 데이터를 검색할 수 있는지 확인하는 것이 좋습니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
다음 경우에 이 패턴을 사용합니다.

- 클라이언트 응용 프로그램은 다양한 키를 사용하여 엔터티를 검색해야 합니다.
- 클라이언트는 다른 정렬 순서로 엔터티를 검색해야 합니다.
- 다양한 고유 값을 사용하여 각 엔터티를 식별할 수 있습니다.

그러나 다른 `RowKey` 값을 사용하여 엔터티 조회를 수행할 때 파티션 확장성 제한을 초과하지 않도록 해야 합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [파티션 간 보조 인덱스 패턴](#inter-partition-secondary-index-pattern)
* [복합 키 패턴](#compound-key-pattern)
* [엔터티 그룹 트랜잭션](#entity-group-transactions)
* [유형이 다른 엔터티 형식 사용](#work-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a>파티션 간 보조 인덱스 패턴
별도의 파티션이나 별도의 테이블에 `RowKey` 서로 다른 값을 사용하여 각 엔터티의 여러 복사본을 저장합니다. 이를 통해 빠르고 효율적인 조회를 가능하게 하고 `RowKey` 다른 값을 사용하여 정렬 순서를 대체할 수 있습니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
테이블 저장소는 및 `PartitionKey` `RowKey` 값을 사용하여 엔터티를 자동으로 인덱싱합니다. 이렇게 하면 클라이언트 응용 프로그램이 이러한 값을 사용하여 엔터티를 효율적으로 검색할 수 있습니다. 예를 들어 다음 테이블 구조를 사용하여 클라이언트 응용 프로그램은 지점 쿼리를 사용하여 부서 이름과 직원 `PartitionKey` ID(및 `RowKey` 값)를 사용하여 개별 직원 엔터티를 검색할 수 있습니다. 또한 클라이언트는 각 부서 내에서 직원 ID별로 정렬된 엔터티를 검색할 수 있습니다.  

![직원 엔터티 그래픽][9]

전자 메일 주소와 같은 다른 속성 값으로 기반으로 직원 엔터티를 찾을 수 있도록 하려면 비효율적인 파티션 검색을 사용하여 일치하는 항목을 찾아야 합니다. 이는 테이블 저장소가 보조 인덱스를 제공하지 않기 때문입니다. 또한 주문과 다른 `RowKey` 순서로 정렬된 직원 목록을 요청할 수 있는 옵션은 없습니다.  

이러한 엔터티에 대해 많은 양의 트랜잭션을 예상하고 있으며 클라이언트를 제한하는 Table 저장소 속도의 위험을 최소화하려고 합니다.  

#### <a name="solution"></a>해결 방법
보조 인덱스가 부족한 경우 각 엔터티의 여러 복사본을 저장할 수 있으며 `PartitionKey` 각 `RowKey` 복사본은 서로 다른 값과 값을 사용하여 저장할 수 있습니다. 다음 구조의 엔터티를 저장하는 경우 전자 메일 주소 또는 직원 ID를 기반으로 직원 엔터티를 효율적으로 검색할 수 있습니다. 에 대한 접두사 `email_` 값을 사용하여 쿼리에 `PartitionKey` `empid_`사용할 인덱스를 식별할 수 있습니다.  

![보조 인덱스가 있는 기본 인덱스 및 직원 엔터티를 가진 직원 엔터티를 보여주는 그래픽][10]

다음 두 필터 기준(직원 ID로 조회한 필터 기준과 전자 메일 주소로 조회하는 필터 기준)은 모두 포인트 쿼리를 지정합니다.  

* $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
* $filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  

직원 엔터티 의 범위를 쿼리하는 경우 직원 ID 순서로 정렬된 범위 또는 전자 메일 주소 순서로 정렬된 범위를 지정할 수 있습니다. 에서 적절한 접두사가 있는 `RowKey`엔터티를 쿼리합니다.  

* **000100에서** **000199**범위의 직원 ID를 가진 영업 부서의 모든 직원을 찾으려면 직원 ID 순서로 정렬하여 $filter=(PartitionKey eq 'empid_Sales') 및 (RowKey ge '000100') 및 (RowKey le '000199')  
* 이메일 주소 순서로 정렬된 "a"로 시작하는 전자 메일 주소가 있는 영업 부서의 모든 직원을 찾으려면 $filter=(PartitionKey eq 'email_Sales') 및 (RowKey ge 'a') 및 (RowKey lt 'b')를 사용합니다.  

앞의 예제에서 사용된 필터 구문은 Table 저장소 REST API에서 가져옵니다. 자세한 내용은 [엔터티 쿼리](https://msdn.microsoft.com/library/azure/dd179421.aspx)를 참조하십시오.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern) 을 사용하여 주 인덱스 엔터티 및 보조 인덱스 엔터티를 유지 관리함으로써 중복 엔터티를 서로 일관성 있게 유지할 수 있습니다.  
* 테이블 저장소는 사용하기가 상대적으로 저렴하므로 중복 데이터를 저장하는 데 드는 비용 오버헤드가 큰 문제가 되지 않아야 합니다. 그러나 항상 예상되는 저장소 요구 사항에 따라 설계 비용을 평가하고 클라이언트 응용 프로그램이 실행할 쿼리를 지원하기 위해 중복 엔터티만 추가합니다.  
* 에 사용되는 값은 각 엔터티에 대해 `RowKey` 고유해야 합니다. 복합 키 값을 사용하는 것이 좋습니다.  
* (예: employee ID `RowKey` 000223)의 패딩 숫자 값은 상한및 하한을 기반으로 올바른 정렬 및 필터링을 가능하게 합니다.  
* 엔터티의 모든 속성을 복제할 필요는 없습니다. 예를 들어 직원의 사용 연령에 전자 메일 주소를 `RowKey` 사용하여 엔터티를 조회하는 쿼리에 다음 구조가 있을 수 있습니다.
  
  ![보조 인덱스가 있는 직원 엔터티를 보여주는 그래픽][11]
* 일반적으로 중복 데이터를 저장하고 한 쿼리를 사용하여 보조 인덱스와 다른 쿼리를 사용하여 기본 인덱스에서 필요한 데이터를 조회하는 것보다 단일 쿼리로 필요한 모든 데이터를 검색할 수 있는지 확인하는 것이 좋습니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
다음 경우에 이 패턴을 사용합니다.

- 클라이언트 응용 프로그램은 다양한 키를 사용하여 엔터티를 검색해야 합니다.
- 클라이언트는 다른 정렬 순서로 엔터티를 검색해야 합니다.
- 다양한 고유 값을 사용하여 각 엔터티를 식별할 수 있습니다.

다른 `RowKey` 값을 사용하여 엔터티 조회를 수행할 때 파티션 확장성 제한을 초과하지 않으려는 경우 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)  
* [파티션 간 보조 인덱스 패턴](#intra-partition-secondary-index-pattern)  
* [복합 키 패턴](#compound-key-pattern)  
* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [유형이 다른 엔터티 형식 사용](#work-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a>결과적으로 일관성 있는 트랜잭션 패턴
Azure 큐를 사용하여 파티션 경계 또는 스토리지 시스템 경계 간에 결과적으로 일관성 있는 동작을 지원합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
EGT는 동일한 파티션 키를 공유하는 여러 엔터티 간의 원자성 트랜잭션을 지원합니다. 성능 및 확장성을 위해 일관성 요구 사항이 있는 엔터티를 별도의 파티션이나 별도의 저장소 시스템에 저장하도록 결정할 수 있습니다. 이러한 시나리오에서는 일관성을 유지하기 위해 ET를 사용할 수 없습니다. 예를 들어 다음 엔터티 간에 결과적 일관성을 유지해야 하는 요구 사항이 있을 수 있습니다.  

* 동일한 테이블, 서로 다른 테이블 또는 서로 다른 스토리지 계정의 두 파티션에 저장된 엔터티  
* 테이블 저장소에 저장된 엔터티와 Blob 저장소에 저장된 Blob입니다.  
* 테이블 저장소에 저장된 엔터티와 파일 시스템의 파일입니다.  
* 테이블 저장소에 저장된 엔터티이지만 Azure 인지 검색을 사용하여 인덱싱됩니다.  

#### <a name="solution"></a>해결 방법
Azure 큐를 사용하면 둘 이상의 파티션 또는 스토리지 시스템 간에 결과적 일관성을 유지하는 솔루션을 구현할 수 있습니다.

이 방법을 설명하기 위해 이전 직원 엔터티를 보관할 수 있어야 한다고 가정합니다. 이전 직원 엔터티는 거의 쿼리되지 않으며 현재 직원을 다루는 모든 활동에서 제외되어야 합니다. 이 요구 사항을 구현하려면 **현재** 테이블에 활성 직원과 이전 직원을 **보관 테이블에** 저장합니다. 직원을 보관하려면 **현재** 테이블에서 엔터티를 삭제하고 **엔터티를 보관** 테이블에 추가해야 합니다.

그러나 EGT를 사용하여 이러한 두 작업을 수행할 수는 없습니다. 오류로 인해 하나의 엔터티가 두 테이블 모두에 표시되거나 아무 테이블에도 표시되지 않는 위험을 방지하려면 보관 작업이 결과적으로 일관성이 있어야 합니다. 다음 시퀀스 다이어그램에 이 작업의 단계가 요약되어 있습니다.  

![결과적 일관성을 위한 솔루션 다이어그램][12]

클라이언트는 Azure 큐에 메시지를 배치하여 아카이브 작업을 시작합니다(이 예에서는 직원 #456 보관하기 위해). 작업자 역할이 새 메시지에 대해 큐를 폴링합니다. 새 메시지를 찾은 경우 메시지를 읽고 숨겨진 복사본을 큐에 남겨 둡니다. 작업자 역할이 **현재** 테이블에서 엔터티의 복사본을 가져와 **보관** 테이블에 삽입한 다음 **현재** 테이블에서 원래 엔터티를 삭제합니다. 마지막으로 이전 단계에서 오류가 발생하지 않은 경우 작업자 역할이 큐에서 숨겨진 메시지를 삭제합니다.  

이 예제에서는 다이어그램의 4단계에서 직원을 **보관** 테이블에 삽입합니다. Blob 저장소의 Blob 또는 파일 시스템의 파일에 직원을 추가할 수 있습니다.  

#### <a name="recover-from-failures"></a>오류복구
다이어그램의 4-5단계의 작업은 작업자 역할이 아카이브 작업을 다시 시작해야 하는 경우에 대비하여 *idempotent여야* 합니다. 테이블 저장소를 사용하는 경우 4단계의 경우 "삽입 또는 바꾸기" 작업을 사용해야 합니다. 5단계의 경우 사용 중인 클라이언트 라이브러리에서 "있는 경우 삭제" 작업을 사용해야 합니다. 다른 저장소 시스템을 사용하는 경우 적절한 idempotent 작업을 사용해야 합니다.  

작업자 역할이 다이어그램에서 6단계를 완료하지 않으면 시간 지정 후 작업자 역할이 다시 처리하려고 할 준비가 된 큐에 메시지가 다시 나타납니다. 작업자 역할은 큐의 메시지를 읽은 횟수를 확인하고 필요한 경우 별도의 큐로 보내 조사를 위해 "독" 메시지로 플래그를 지정할 수 있습니다. 큐 메시지를 읽고 큐 에서 수를 확인하는 자세한 내용은 [메시지 받기를](https://msdn.microsoft.com/library/azure/dd179474.aspx)참조하십시오.  

테이블 저장소 및 Queue 저장소의 일부 오류는 일시적인 오류이며 클라이언트 응용 프로그램에이를 처리하기에 적합한 재시도 논리가 포함되어야 합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 이 솔루션은 트랜잭션 격리를 제공하지 않습니다. 예를 들어 클라이언트는 작업자 역할이 다이어그램의 4-5단계 사이에 있을 때 **현재** 및 **보관** 테이블을 읽고 데이터의 일관되지 않은 보기를 볼 수 있습니다. 결국 데이터는 일관성 있게 유지됩니다.  
* 최종 일관성을 보장하기 위해 4-5단계는 idempotent인지 확인해야 합니다.  
* 여러 큐 및 작업자 역할 인스턴스를 사용하여 솔루션을 확장할 수 있습니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
서로 다른 파티션 또는 테이블에 있는 엔터티 간의 결과적 일관성을 보장하려는 경우에 이 패턴을 사용합니다. 이 패턴을 확장하여 Table 저장소 및 Blob 저장소 및 데이터베이스 또는 파일 시스템과 같은 기타 Azure Storage 데이터 원본에서 작업의 최종 일관성을 보장할 수 있습니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [병합 또는 바꾸기](#merge-or-replace)  

> [!NOTE]
> 트랜잭션 격리가 솔루션에 중요한 경우 ET를 사용할 수 있도록 테이블을 다시 디자인하는 것이 좋습니다.  
> 
> 

### <a name="index-entities-pattern"></a>인덱스 엔터티 패턴
인덱스 엔터티를 유지 관리하여 엔터티 목록을 반환하는 효율적인 검색을 지원합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
테이블 저장소는 및 `PartitionKey` `RowKey` 값을 사용하여 엔터티를 자동으로 인덱싱합니다. 이렇게 하면 클라이언트 응용 프로그램이 포인트 쿼리를 사용하여 엔터티를 효율적으로 검색할 수 있습니다. 예를 들어 다음 테이블 구조를 사용하여 클라이언트 응용 프로그램은 부서 이름과 직원 `PartitionKey` ID(및)를 `RowKey`사용하여 개별 직원 엔터티를 효율적으로 검색할 수 있습니다.  

![직원 엔터티 그래픽][13]

또한 성처럼 고유하지 않은 다른 속성의 값을 기반으로 직원 엔터티 목록을 검색하려면 효율성이 떨어지는 파티션 검사를 사용해야 합니다. 이 검색은 인덱스를 사용하여 직접 조회하는 대신 일치하는 항목을 찾습니다. 이는 테이블 저장소가 보조 인덱스를 제공하지 않기 때문입니다.  

#### <a name="solution"></a>해결 방법
앞의 엔터티 구조에서 성으로 조회를 사용하려면 직원 아이디 목록을 유지 관리해야 합니다. Jones와 같은 특정 성을 가진 직원 엔터티를 검색하려면 먼저 Jones를 성으로 가진 직원의 직원 아이디 목록을 찾은 다음 해당 직원 엔터티를 검색해야 합니다. 직원 아이디 목록을 저장하는 세 가지 주요 옵션이 있습니다.  

* Blob 저장소를 사용합니다.  
* 직원 엔터티와 동일한 파티션에 인덱스 엔터티 만들기  
* 별도의 파티션 또는 테이블에 인덱스 엔터티 만들기  

옵션 1: Blob 저장소 사용  

모든 고유한 성에 대해 Blob을 만들고 각 Blob 저장소에 해당 성을 가진 직원에 대한 `PartitionKey` (부서) 및 `RowKey` (직원 ID) 값의 목록을 만듭니다. 직원을 추가하거나 삭제할 때 관련 Blob의 콘텐츠가 결국 직원 엔터티와 일치하는지 확인합니다.  

옵션 2: 동일한 파티션에서 인덱스 엔터티 만들기  

다음 데이터를 저장하는 인덱스 엔터티를 사용합니다.  

![동일한 성을 가진 직원 아이디 목록이 포함된 문자열이 있는 직원 엔터티를 표시하는 그래픽][14]

속성에는 `EmployeeIDs` `RowKey`에 저장된 성이 있는 직원의 직원 등록부 목록이 포함되어 있습니다.  

다음 단계에서는 새 직원을 추가할 때 따라야 하는 프로세스에 대해 간략하게 설명합니다. 이 예제에서는 영업 부서에 ID 000152와 성 존스가 있는 직원을 추가합니다.  

1. 값 "Sales"와 `PartitionKey` 값 "Jones"를 `RowKey` 가진 인덱스 엔터티를 검색합니다. 이 엔터티의 ETag를 2단계에서 사용하기 위해 저장합니다.  
2. 새 직원`PartitionKey` 엔터티(값 "Sales" 및 값 "000152")를 `RowKey` 삽입하고 인덱스 엔터티(값`PartitionKey` "Sales" 및 `RowKey` 값 "Jones")를 업데이트하는 엔터티 그룹 트랜잭션(즉, 일괄 처리 작업)을 만듭니다. EGT는 EmployeeID 필드의 목록에 새 직원 ID를 추가하여 이 작업을 수행합니다. ET에 대한 자세한 내용은 [엔터티 그룹 트랜잭션을](#entity-group-transactions)참조하십시오.  
3. 낙관적 동시성 오류(즉, 다른 사람이 인덱스 엔터티를 수정했기 때문에 EGT가 실패하면 1단계에서 다시 시작해야 합니다).  

두 번째 옵션을 사용하는 경우 유사한 방법을 사용하여 직원을 삭제할 수 있습니다. 직원 엔터티, 이전 성에 대한 인덱스 엔터티 및 새 성에 대한 인덱스 엔터티의 세 엔터티를 업데이트하는 EGT를 실행해야 하기 때문에 직원의 성을 변경하는 것이 약간 더 복잡합니다. 낙관적 동시성을 사용하여 업데이트를 수행하는 데 사용할 수 있는 ETag 값을 검색하려면 변경하기 전에 각 엔터티를 검색해야 합니다.  

다음 단계에서는 부서의 특정 성을 가진 모든 직원을 찾아야 할 때 따라야 하는 프로세스를 간략하게 설명합니다. 이 예제에서는 영업 부서에서 성 존스를 가진 모든 직원을 찾고 있습니다.  

1. 값 "Sales"와 `PartitionKey` 값 "Jones"를 `RowKey` 가진 인덱스 엔터티를 검색합니다.  
2. 현장의 직원 아이디 목록을 구문 `EmployeeIDs` 분석합니다.  
3. 이러한 각 직원(예: 전자 메일 주소)에 대한 추가 정보가 필요한 경우 `PartitionKey` 값 "Sales"를 사용하여 각 직원 엔터티를 검색하고 `RowKey` 2단계에서 얻은 직원 목록에서 값을 검색합니다.  

옵션 3: 별도의 파티션 또는 테이블에서 인덱스 엔터티 만들기  

이 옵션의 경우 다음 데이터를 저장하는 인덱스 엔터티를 사용합니다.  

![동일한 성을 가진 직원 아이디 목록이 포함된 문자열이 있는 직원 엔터티를 표시하는 그래픽][15]

속성에는 `EmployeeIDs` `RowKey`에 저장된 성이 있는 직원의 직원 등록부 목록이 포함되어 있습니다.  

인덱스 엔터티가 직원 엔터티와 별도의 파티션에 있으므로 ET를 사용하여 일관성을 유지할 수 없습니다. 인덱스 엔터티가 결국 직원 엔터티와 일치하는지 확인합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 이 솔루션에는 일치하는 엔터티를 검색하는 쿼리가 두 개 이상 필요합니다. `RowKey`  
* 개별 엔터티의 최대 크기가 1MB이기 때문에 솔루션의 옵션 2 및 옵션 3은 특정 성에 대한 직원 식별 목록이 1MB를 초과하지 않는 것으로 가정합니다. 직원 아이디 목록이 1MB 를 초과할 가능성이 있는 경우 옵션 1을 사용하고 인덱스 데이터를 Blob 저장소에 저장합니다.  
* 옵션 2(ET를 사용하여 직원 추가 및 삭제 및 직원의 성 변경)를 사용하는 경우 트랜잭션 볼륨이 특정 파티션의 확장성 제한에 근접할지 여부를 평가해야 합니다. 이 경우 결국 일관된 솔루션(옵션 1 또는 옵션 3)을 고려해야 합니다. 이러한 큐를 사용하여 업데이트 요청을 처리하고 인덱스 엔터티를 직원 엔터티와 별도의 파티션에 저장할 수 있습니다.  
* 이 솔루션의 옵션 2는 부서 내에서 성으로 조회하려는 것으로 가정합니다. 예를 들어 영업 부서에서 성 존스가 있는 직원 목록을 검색하려고 합니다. 조직 전체에서 성 존스로 모든 직원을 조회하려면 옵션 1 또는 옵션 3중 하나를 사용합니다.
* 최종 일관성을 제공하는 큐 기반 솔루션을 구현할 수 있습니다. 자세한 내용은 결국 [일관된 트랜잭션 패턴을](#eventually-consistent-transactions-pattern)참조하십시오.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
성이 존스(Jones)라는 이름의 모든 직원과 같이 공통 속성 값을 모두 공유하는 엔터티 집합을 조회하려는 경우 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [복합 키 패턴](#compound-key-pattern)  
* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)  
* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [유형이 다른 엔터티 형식 사용](#work-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a>비정규화 패턴
관련 데이터를 단일 엔터티에 함께 통합하여 단일 지점 쿼리로 필요한 모든 데이터를 검색할 수 있습니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
관계형 데이터베이스에서는 일반적으로 데이터를 정규화하여 쿼리가 여러 테이블에서 데이터를 검색할 때 발생하는 중복을 제거합니다. Azure 테이블의 데이터를 정규화한 경우 클라이언트와 버 간에 여러 번 왕복하여 관련 데이터를 검색해야 합니다. 예를 들어 다음 테이블 구조를 사용하면 부서의 세부 정보를 검색하려면 두 번의 왕복이 필요합니다. 한 여행은 관리자의 ID를 포함하는 부서 엔터티를 가져오고 두 번째 여행은 직원 엔터티에서 관리자의 세부 정보를 가져옵니다.  

![부서 엔터티 및 직원 엔터티 그래픽][16]

#### <a name="solution"></a>해결 방법
두 개의 별도 엔터티에 데이터를 저장하는 대신 데이터를 비정규화하여 부서 엔터티에 관리자 세부 정보의 복사본을 유지합니다. 예를 들어:  

![비정규화 및 결합된 부서 엔터티 그래픽][17]

이러한 속성과 함께 저장된 부서 엔터티를 사용하면 이제 점 쿼리를 사용하여 부서에 필요한 모든 세부 정보를 검색할 수 있습니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 일부 데이터를 두 번 저장하는 것과 관련된 약간의 비용 오버헤드가 있습니다. Table 저장소에 대한 요청 수가 적어 성능이 향상되는 것은 일반적으로 스토리지 비용의 한계 증가보다 큽니다. 또한 이 비용은 부서의 세부 정보를 가져오는 데 필요한 트랜잭션 수를 줄임으로써 부분적으로 상쇄됩니다.  
* 관리자에 대한 정보를 저장하는 두 엔터티의 일관성을 유지해야 합니다. ET를 사용하여 단일 원자성 트랜잭션에서 여러 엔터티를 업데이트하여 일관성 문제를 처리할 수 있습니다. 이 경우 부서 관리자의 부서 엔터티와 직원 엔터티가 동일한 파티션에 저장됩니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
관련 정보를 자주 조회해야 하는 경우에 이 패턴을 사용합니다. 이 패턴은 클라이언트에서 필요한 데이터를 검색하기 위해 실행해야 하는 쿼리 수를 줄여 줍니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [복합 키 패턴](#compound-key-pattern)  
* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [유형이 다른 엔터티 형식 사용](#work-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a>복합 키 패턴
복합 `RowKey` 값을 사용하여 클라이언트가 단일 포인트 쿼리로 관련 데이터를 조회할 수 있습니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
관계형 데이터베이스에서는 쿼리에서 조인을 사용하여 관련 데이터를 단일 쿼리에서 클라이언트에 반환하는 것이 당연합니다. 예를 들어 직원 ID를 사용하여 해당 직원에 대한 성과 및 검토 데이터가 포함된 관련 엔터티 목록을 조회할 수 있습니다.  

다음 구조를 사용하여 직원 엔터티를 테이블 저장소에 저장한다고 가정합니다.  

![직원 엔터티 그래픽][18]

또한 직원이 조직에서 근무한 해마다 검토 및 성과와 관련된 기록 데이터를 저장해야 하며 연도별로 이 정보에 액세스할 수 있어야 합니다. 한 가지 옵션은 다음 구조로 엔터티를 저장하는 다른 테이블을 만드는 것입니다.  

![직원 검토 엔터티 그래픽][19]

이 방법을 사용하면 새 엔터티에서 일부 정보(예: 이름 및 성)를 복제하여 단일 요청으로 데이터를 검색할 수 있도록 할 수 있습니다. 그러나 EGT를 사용하여 두 엔터티를 원자적으로 업데이트할 수 없으므로 강력한 일관성을 유지할 수 없습니다.  

#### <a name="solution"></a>해결 방법
다음 구조의 엔터티를 사용하여 원래 테이블에 새 엔터티 형식을 저장합니다.  

![복합 키가 있는 직원 엔터티 그래픽][20]

직원 ID와 검토 데이터의 연도로 구성된 복합 키가 어떻게 `RowKey` 구성되는지 확인합니다. 이렇게 하면 단일 엔터티에 대한 단일 요청으로 직원의 성과를 검색하고 데이터를 검토할 수 있습니다.  

다음 예제에서는 특정 직원(예: Sales 부서의 직원 000123)에 대한 모든 검토 데이터를 검색할 수 있는 방법을 간략하게 설명합니다.  

$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* `RowKey` **000123_2012와**같은 값을 쉽게 구문 분석할 수 있는 적절한 구분 기호 문자를 사용해야 합니다.  
* 또한 이 엔터티를 동일한 직원에 대한 관련 데이터를 포함하는 다른 엔터티와 동일한 파티션에 저장합니다. 즉, ET를 사용하여 강력한 일관성을 유지할 수 있습니다.
* 이 패턴이 적절한지 여부를 결정하기 위해 데이터를 쿼리하는 빈도를 고려해야 합니다. 예를 들어 검토 데이터에 자주 액세스하지 못하고 주 직원 데이터에 자주 액세스하는 경우 해당 데이터를 별도의 엔터티로 유지해야 합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
자주 쿼리하는 하나 이상의 관련 엔터티를 저장해야 하는 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [엔터티 그룹 트랜잭션](#entity-group-transactions)  
* [유형이 다른 엔터티 형식 사용](#work-with-heterogeneous-entity-types)  
* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a>로그 테일 패턴
역날짜 *n* 및 시간 순서로 `RowKey` 정렬되는 값을 사용하여 파티션에 가장 최근에 추가된 n 엔터티를 검색합니다.  

> [!NOTE]
> Azure Cosmos DB의 Azure Table API에서 반환된 쿼리 결과는 파티션 키 또는 행 키로 정렬되지 않습니다. 따라서 이 패턴은 테이블 저장소에 적합하지만 Azure Cosmos DB에는 적합하지 않습니다. 기능 차이에 대한 자세한 목록은 [Azure Cosmos DB의 테이블 API와 Azure 테이블 저장소 간의 차이점을](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)참조하십시오.

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
일반적인 요구 사항은 가장 최근에 생성된 엔터티(예: 직원이 제출한 가장 최근 비용 청구 10개)를 검색할 수 있는 것입니다. 테이블 쿼리는 `$top` 집합에서 첫 번째 *n* 엔터티를 반환 하는 쿼리 작업을 지원 합니다. 집합의 마지막 *n* 엔터티를 반환하는 동등한 쿼리 작업은 없습니다.  

#### <a name="solution"></a>해결 방법
역날짜/시간 순서로 자연스럽게 `RowKey` 정렬되는 엔터티를 사용하여 엔터티를 저장하므로 가장 최근 항목은 항상 테이블의 첫 번째 항목입니다.  

예를 들어 직원이 제출한 가장 최근 비용 청구 10개를 검색하려면 현재 날짜/시간에서 파생된 역방향 틱 값을 사용하면 됩니다. 다음 C# 코드 샘플에서는 가장 최근에서 가장 오래된 것까지 정렬되는 에 `RowKey` 대해 적합한 "반전된 틱" 값을 만드는 한 가지 방법을 보여 주었습니다.  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

다음 코드를 사용하여 날짜/시간 값으로 돌아갈 수 있습니다.  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

테이블 쿼리는 다음과 같습니다.  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 문자열 값이 예상대로 정렬되도록 하려면 역방향 틱 값을 선행 영점으로 채점해야 합니다.  
* 파티션 수준의 확장성 목표를 알아야 합니다. 핫 스팟 파티션을 만들지 않도록 주의하십시오.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
역날짜/시간 순서로 엔터티에 액세스해야 하거나 가장 최근에 추가된 엔터티에 액세스해야 하는 경우 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [앞/뒤에 추가된 안티패턴](#prepend-append-anti-pattern)  
* [엔터티 검색](#retrieve-entities)  

### <a name="high-volume-delete-pattern"></a>대용량 삭제 패턴
자체 별도 테이블에 동시 삭제를 위해 모든 엔터티를 저장하여 대량의 엔터티를 삭제할 수 있습니다. 테이블을 삭제하여 엔터티를 삭제합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
대부분의 애플리케이션은 클라이언트 애플리케이션에서 더 이상 사용할 필요가 없거나 애플리케이션이 다른 스토리지 매체에 보관한 경우 이전 데이터를 삭제합니다. 일반적으로 날짜별로 이러한 데이터를 식별합니다. 예를 들어 60일이 지난 모든 로그인 요청의 레코드를 삭제해야 합니다.  

한 가지 가능한 디자인은 `RowKey`다음에서 로그인 요청의 날짜와 시간을 사용하는 것입니다.  

![로그인 시도 엔터티그래픽][21]

이 방법은 응용 프로그램이 별도의 파티션에서 각 사용자에 대한 로그인 엔터티를 삽입하고 삭제할 수 있으므로 파티션 핫스팟을 방지합니다. 그러나 이 방법은 엔터티수가 많은 경우 비용이 많이 들고 시간이 오래 걸릴 수 있습니다. 먼저 삭제할 모든 엔터티를 식별하려면 테이블 검사를 수행한 다음 각 이전 엔터티를 삭제해야 합니다. 여러 삭제 요청을 EGT로 일괄 처리하면 이전 엔터티를 삭제하는 데 필요한 서버 왕복 횟수를 줄일 수 있습니다.  

#### <a name="solution"></a>해결 방법
각 로그인 시도 날짜에 별도의 테이블을 사용합니다. 이전 엔터티 디자인을 사용하여 엔터티를 삽입할 때 핫스팟을 방지할 수 있습니다. 이제 이전 엔터티를 삭제하는 것은 매일 수백, 수천 개의 개별 로그인 엔터티를 찾아 삭제하는 대신 매일 하나의 테이블(단일 저장소 작업)을 삭제하는 문제일 뿐입니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 디자인이 특정 엔터티 를 찾거나 다른 데이터와 연결하거나 집계 정보를 생성하는 등 응용 프로그램에서 데이터를 사용하는 다른 방법을 지원합니까?  
* 디자인이 새 엔터티를 삽입할 때 핫스폿을 방지하나요?  
* 테이블을 삭제한 후 동일한 테이블 이름을 다시 사용하려는 경우 지연이 발생할 수 있습니다. 항상 고유한 테이블 이름을 사용하는 것이 좋습니다.  
* 테이블 저장소는 액세스 패턴을 학습하고 노드 간에 파티션을 배포하는 동안 새 테이블을 처음 사용할 때 일부 속도 제한을 예상합니다. 새 테이블을 만들어야 하는 빈도를 고려해야 합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
동시에 삭제해야 하는 엔터티가 많은 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [엔터티 그룹 트랜잭션](#entity-group-transactions)
* [엔터티 수정](#modify-entities)  

### <a name="data-series-pattern"></a>데이터 계열 패턴
전체 데이터 계열을 단일 엔터티에 저장하여 요청 수를 최소화합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
일반적인 시나리오에서 애플리케이션은 보통 모든 엔터티를 동시에 검색하는 데 필요한 데이터 계열을 저장합니다. 예를 들어 애플리케이션은 각 직원이 매시간 보내는 IM 메시지 수를 기록한 다음, 이 정보를 사용하여 각 사용자가 이전 24시간 동안 보낸 메시지 수를 표시할 수 있습니다. 한 가지 디자인은 각 직원에 대한 24개의 엔터티를 저장하는 것입니다.  

![메시지 통계 엔터티의 그래픽][22]

이 디자인을 사용하면 애플리케이션이 메시지 수 값을 업데이트해야 할 때마다 각 직원에 대한 엔터티를 쉽게 찾아서 업데이트할 수 있습니다. 그러나 이전 24시간 동안의 활동에 대한 차트를 그리기 위해 정보를 검색하려면 24개의 엔터티를 검색해야 합니다.  

#### <a name="solution"></a>해결 방법
다음 디자인을 사용하여 별도의 속성과 함께 시간마다 메시지 수를 저장합니다.  

![분리된 속성이 있는 메시지 통계 엔터티표시 그래픽][23]

이 디자인을 사용하면 병합 작업을 통해 특정 시간 동안 각 직원의 메시지 수를 업데이트할 수 있습니다. 이제 단일 엔터티에 대한 요청을 사용하여 차트를 플롯하는 데 필요한 모든 정보를 검색할 수 있습니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 전체 데이터 계열이 단일 엔터티에 맞지 않는 경우(엔터티에 최대 252개의 속성을 가질 수 있음) Blob과 같은 대체 데이터 저장소를 사용합니다.  
* 엔터티를 동시에 업데이트하는 클라이언트가 여러 개인 경우 **ETag를** 사용하여 낙관적 동시성을 구현합니다. 클라이언트가 많은 경우 높은 경합이 발생할 수 있습니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
개별 엔터티와 연관된 데이터 계열을 업데이트하고 검색해야 하는 경우에 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [큰 엔터티 패턴](#large-entities-pattern)  
* [병합 또는 바꾸기](#merge-or-replace)  
* [결국 일관된 트랜잭션 패턴(데이터](#eventually-consistent-transactions-pattern) 계열을 Blob에 저장하는 경우)  

### <a name="wide-entities-pattern"></a>넓은 엔터티 패턴
여러 실제 엔터티를 사용하여 속성이 252개가 넘는 논리적 엔터티를 저장합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
개별 엔터티에는 252개 이하의 속성(필수 시스템 속성 제외)이 있을 수 있으며 총 1MB 이상의 데이터를 저장할 수 없습니다. 관계형 데이터베이스에서는 일반적으로 새 테이블을 추가하고 행 간의 일대일 관계를 적용하여 행 크기에 대한 제한을 해결합니다.  

#### <a name="solution"></a>해결 방법
Table 저장소를 사용하면 여러 엔터티를 저장하여 252개 이상의 속성이 있는 단일 대규모 비즈니스 개체를 나타낼 수 있습니다. 예를 들어 지난 365일 동안 각 직원이 보낸 IM 메시지 수를 저장하려는 경우 스키마가 다른 두 엔터티를 사용하는 다음 디자인을 사용할 수 있습니다.  

![Rowkey 01을 가진 메시지 통계 엔터티 및 Rowkey 02를 가진 메시지 통계 엔터티를 보여주는 그래픽][24]

서로 동기화된 상태로 유지하기 위해 두 엔터티를 모두 업데이트해야 하는 변경 내용을 적용하려는 경우 EGT를 사용할 수 있습니다. 그렇지 않으면 단일 병합 작업을 사용하여 특정 날짜의 메시지 수를 업데이트할 수 있습니다. 개별 직원에 대한 모든 데이터를 검색하려면 두 엔터티를 모두 검색해야 합니다. a와 `PartitionKey` 값을 모두 사용하는 두 개의 효율적인 `RowKey` 요청으로 이 작업을 수행할 수 있습니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현하는 방법을 결정할 때 다음 사항을 고려하십시오.  

* 전체 논리적 엔터티를 검색하는 데에는 적어도 두 개의 스토리지 트랜잭션이 필요합니다. 그 중 하나는 각 실제 엔터티를 검색합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
속성의 크기 또는 수가 Table 저장소의 개별 엔터티에 대한 제한을 초과하는 엔터티를 저장해야 하는 경우 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [엔터티 그룹 트랜잭션](#entity-group-transactions)
* [병합 또는 바꾸기](#merge-or-replace)

### <a name="large-entities-pattern"></a>큰 엔터티 패턴
Blob 저장소를 사용하여 큰 속성 값을 저장합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
개별 엔터티는 총 1MB 이상의 데이터를 저장할 수 없습니다. 엔터티의 총 크기가 이 값을 초과하도록 하는 속성 중 하나 또는 여러 개의 속성을 저장하는 경우 전체 엔터티를 테이블 저장소에 저장할 수 없습니다.  

#### <a name="solution"></a>해결 방법
하나 이상의 속성에 많은 양의 데이터가 포함되어 있기 때문에 엔터티 크기가 1MB를 초과하는 경우 Blob 저장소에 데이터를 저장한 다음 엔터티의 속성에 Blob의 주소를 저장할 수 있습니다. 예를 들어 직원의 사진을 Blob 저장소에 저장하고 직원 엔터티의 `Photo` 속성에 사진에 대한 링크를 저장할 수 있습니다.  

![Blob 저장소를 가리키는 사진용 문자열이 있는 직원 엔터티를 표시하는 그래픽][25]

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 테이블 저장소의 엔터티와 Blob 저장소의 데이터 간의 최종 일관성을 유지하려면 [결국 일관된 트랜잭션 패턴을](#eventually-consistent-transactions-pattern) 사용하여 엔터티를 유지 관리합니다.
* 전체 엔터티를 검색하는 데에는 적어도 두 개의 스토리지 트랜잭션이 필요합니다. 그 중 하나는 엔터티를 검색하고, 또 하나는 Blob 데이터를 검색합니다.  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
크기가 Table 저장소의 개별 엔터티 에 대한 제한을 초과하는 엔터티를 저장해야 하는 경우 이 패턴을 사용합니다.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [결과적으로 일관성 있는 트랜잭션 패턴](#eventually-consistent-transactions-pattern)  
* [넓은 엔터티 패턴](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a>앞에 추가/뒤에 추가 안티패턴
인서트가 많은 경우 여러 파티션에 인서트를 분산하여 확장성을 높입니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
저장된 엔터티 앞 또는 뒤에 엔터티를 추가하면 일반적으로 애플리케이션에서 파티션 시퀀스의 첫 번째 또는 마지막 파티션에 새 엔터티를 추가합니다. 이 경우 특정 시간에 모든 삽입이 동일한 파티션에서 발생하여 핫스팟을 만듭니다. 이렇게 하면 Table 저장소가 여러 노드에서 부하 분산 인서트를 사용할 수 없으며 응용 프로그램이 파티션의 확장성 목표에 도달할 수 있습니다. 예를 들어 직원의 네트워크 및 리소스 액세스를 기록하는 응용 프로그램의 경우를 고려합니다. 트랜잭션 볼륨이 개별 파티션의 확장성 목표에 도달하면 다음과 같은 엔터티 구조로 인해 현재 시간의 파티션이 핫스팟이 될 수 있습니다.  

![직원 엔터티 그래픽][26]

#### <a name="solution"></a>해결 방법
다음 대체 엔터티 구조는 응용 프로그램이 이벤트를 기록하므로 특정 파티션의 핫스팟을 방지합니다.  

![연도, 월, 일, 시간 및 이벤트 ID를 복합하는 RowKey를 가진 직원 엔터티를 보여주는 그래픽][27]

이 예제에서 복합 `PartitionKey` 키와 `RowKey` 복합 키가 모두 어떻게 되는지 확인합니다. 부서와 `PartitionKey` 직원 ID를 모두 사용하여 여러 파티션에 로깅을 배포합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려하세요.  

* 삽입 시 핫 파티션 생성을 효율적으로 방지하는 대체 키 구조가 클라이언트 애플리케이션의 쿼리를 지원하나요?  
* 예상 되는 트랜잭션 볼륨은 개별 파티션의 확장성 목표에 도달하고 테이블 저장소에 의해 제한될 가능성이 있음을 의미합니까?  

#### <a name="when-to-use-this-pattern"></a>이 패턴을 사용해야 하는 경우
핫 파티션에 액세스할 때 트랜잭션 볼륨이 테이블 저장소에 의해 속도 제한이 발생할 가능성이 있는 경우 미리 준비/패턴 방지를 사용하지 마십시오.  

#### <a name="related-patterns-and-guidance"></a>관련 패턴 및 지침
이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.  

* [복합 키 패턴](#compound-key-pattern)  
* [로그 테일 패턴](#log-tail-pattern)  
* [엔터티 수정](#modify-entities)  

### <a name="log-data-anti-pattern"></a>로그 데이터 안티패턴
일반적으로 테이블 저장소 대신 Blob 저장소를 사용하여 로그 데이터를 저장해야 합니다.  

#### <a name="context-and-problem"></a>컨텍스트 및 문제점
로그 데이터의 일반적인 사용 사례는 특정 날짜/시간 범위에 대한 로그 항목 선택을 검색하는 것입니다. 예를 들어 응용 프로그램이 특정 날짜에 15:04에서 15:06 사이에 기록한 모든 오류 및 중요한 메시지를 찾으려고 합니다. 로그 메시지의 날짜와 시간을 사용하여 로그 엔터티를 저장하는 파티션을 결정하려는 것은 아닙니다. 따라서 특정 시간에 모든 로그 엔터티가 동일한 `PartitionKey` 값을 공유하기 때문에 핫 파티션이 발생합니다(Prepend/추가 안티 [패턴](#prepend-append-anti-pattern)참조). 예를 들어 로그 메시지에 대한 다음 엔터티 스키마는 응용 프로그램이 현재 날짜 및 시간에 대한 모든 로그 메시지를 파티션에 기록하기 때문에 핫 파티션을 생성합니다.  

![로그 메시지 엔터티의 그래픽][28]

이 예제에서는 `RowKey` 로그 메시지가 날짜/시간 순서로 정렬되도록 로그 메시지의 날짜와 시간을 포함합니다. `RowKey` 또한 여러 로그 메시지가 동일한 날짜와 시간을 공유하는 경우 메시지 ID도 포함됩니다.  

또 다른 방법은 `PartitionKey` 응용 프로그램이 다양한 파티션에서 메시지를 작성하는 것을 보장하는 a를 사용하는 것입니다. 예를 들어 로그 메시지의 소스가 여러 파티션에 메시지를 배포하는 방법을 제공하는 경우 다음 엔터티 스키마를 사용할 수 있습니다.  

![로그 메시지 엔터티의 그래픽][29]

그러나 이 스키마의 문제는 특정 시간 범위에 대한 모든 로그 메시지를 검색하려면 테이블의 모든 파티션을 검색해야 한다는 것입니다.

#### <a name="solution"></a>해결 방법
이전 섹션에서는 Table 저장소를 사용하여 로그 항목을 저장하는 문제를 강조표시하고 두 가지 불만족스러운 디자인을 제안했습니다. 한 가지 해결책은 로그 메시지를 작성하는 성능이 저하될 위험이 있는 핫 파티션으로 이어졌습니다. 다른 솔루션은 테이블의 모든 파티션을 검색하여 특정 시간 범위에 대한 로그 메시지를 검색해야 하기 때문에 쿼리 성능이 저하되었습니다. Blob 저장소는 이러한 유형의 시나리오에 더 나은 솔루션을 제공하며 Azure Storage 분석에서 수집한 로그 데이터를 저장하는 방법입니다.  

이 섹션에서는 일반적으로 범위별로 쿼리하는 데이터를 저장하는 이 방법의 예시로 Storage 분석에서 로그 데이터를 Blob 저장소에 저장하는 방법을 설명합니다.  

저장소 분석은 여러 Blob에서 제한된 형식으로 로그 메시지를 저장합니다. 구분 기호로 분리된 형식을 사용하면 클라이언트 애플리케이션에서 로그 메시지의 데이터를 쉽게 구문 분석할 수 있습니다.  

저장소 분석은 검색중인 로그 메시지가 포함된 Blob(또는 Blob)을 찾을 수 있는 Blob에 대한 명명 규칙을 사용합니다. 예를 들어 "queue/2014/07/31/1800/000001.log"라는 이름의 Blob에는 2014년 7월 31일 18:00부터 시작되는 시간 동안의 큐 서비스와 관련된 로그 메시지가 포함되어 있습니다. "000001"은 이것이 이 기간 동안의 첫 번째 로그 파일임을 나타냅니다. 또한 저장소 분석은 Blob 메타데이터의 일부로 파일에 저장된 첫 번째 및 마지막 로그 메시지의 타임스탬프를 기록합니다. Blob 저장소용 API를 사용하면 이름 접두사를 기반으로 컨테이너에서 Blob을 찾을 수 있습니다. 18:00부터 18:00부터 시작되는 시간의 큐 로그 데이터가 포함된 모든 Blob을 찾으려면 접두사 "queue/2014/07/31/1800"을 사용할 수 있습니다.  

저장소 분석 버퍼는 내부적으로 메시지를 로그한 다음 정기적으로 적절한 Blob을 업데이트하거나 최신 로그 항목 배치로 새 Blob을 만듭니다. 이렇게 하면 Blob 저장소에 수행해야 하는 쓰기 수가 줄어듭니다.  

자체 응용 프로그램에서 유사한 솔루션을 구현하는 경우 안정성과 비용 및 확장성 간의 장단점을 관리하는 방법을 고려하십시오. 즉, 응용 프로그램의 업데이트를 버퍼링하고 일괄 처리로 Blob 저장소에 쓰는 것과 비교하여 Blob 저장소에 모든 로그 항목을 작성하는 효과를 평가합니다.  

#### <a name="issues-and-considerations"></a>문제 및 고려 사항
로그 데이터를 저장할 방법을 결정할 때 다음 사항을 고려하세요.  

* 잠재적인 핫 파티션을 방지하는 테이블 디자인을 만드는 경우 로그 데이터에 효율적으로 액세스할 수 없습니다.  
* 로그 데이터를 처리하기 위해 클라이언트에서 많은 레코드를 로드해야 하는 경우가 종종 있습니다.  
* 로그 데이터는 종종 구조화되어 있지만 Blob 저장소가 더 나은 솔루션일 수 있습니다.  

### <a name="implementation-considerations"></a>구현 고려 사항
이 섹션에서는 이전 섹션에 설명된 패턴을 구현할 때 염두에 두어야 하는 몇 가지 고려 사항을 알아봅니다. 이 섹션에서는 대부분 Storage 클라이언트 라이브러리(이 문서 작성 당시 버전 4.3.0)를 사용하는 C#으로 작성된 예제를 사용합니다.  

### <a name="retrieve-entities"></a>엔터티 검색
[쿼리를 위한 디자인](#design-for-querying)섹션에 설명된 대로 가장 효율적인 쿼리는 지점 쿼리입니다. 그러나 일부 시나리오에서는 여러 엔터티를 검색해야 할 수 있습니다. 이 섹션에서는 저장소 클라이언트 라이브러리를 사용하여 엔터티를 검색하는 몇 가지 일반적인 방법을 설명합니다.  

#### <a name="run-a-point-query-by-using-the-storage-client-library"></a>저장소 클라이언트 라이브러리를 사용하여 포인트 쿼리 실행
포인트 쿼리를 실행하는 가장 쉬운 방법은 **테이블 검색** 작업을 사용하는 것입니다. 다음 C# 코드 스니펫에 표시된 것처럼 이 작업은 `PartitionKey` 값 "Sales"와 값 `RowKey` "212"를 가진 엔터티를 검색합니다.  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

이 예제에서 검색하는 엔터티가 형식이 `EmployeeEntity`될 것으로 예상하는 방법을 확인합니다.  

#### <a name="retrieve-multiple-entities-by-using-linq"></a>LINQ를 사용하여 여러 엔터티 검색
저장소 클라이언트 라이브러리와 LINQ를 사용 하 여 여러 엔터티를 검색할 수 있습니다 및 **where** 절을 사용 하 여 쿼리를 지정 합니다. 테이블 검색을 방지하려면 항상 where 절에 `PartitionKey` 값을 포함해야 하며 가능하면 테이블 및 파티션 검사를 피하기 위한 `RowKey` 값을 포함해야 합니다. 테이블 저장소는 where 절에서 사용할 수 있는 제한된 비교 연산자 집합(보다 크거나 크거나 같거나, 보다 크거나 같거나, 보다 적거나, 같거나, 같거나, 같거나 같지 않음)을 지원합니다. 다음 C# 코드 스니펫은 영업 부서에서 성이름이 "B"(성을 `RowKey` 저장한다고 가정)로 시작하는 모든 `PartitionKey` 직원을 찾습니다(백화점이 백화점 이름을 가정).  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

더 나은 성능을 보장하기 위해 `RowKey` 쿼리가 a와 a를 `PartitionKey` 모두 지정하는 방법을 확인합니다.  

다음 코드 샘플에서는 Fluent API를 사용하여 동등한 기능을 보여 주며(일반적으로 Fluent API에 대한 자세한 내용은 [유창한 API를 디자인하는 모범 사례를](https://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)참조).  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> 샘플은 세 `CombineFilters` 가지 필터 조건을 포함하도록 여러 메서드를 중첩합니다.  
> 
> 

#### <a name="retrieve-large-numbers-of-entities-from-a-query"></a>쿼리에서 많은 수의 엔터티 검색
최적 쿼리는 값과 값을 `PartitionKey` 기반으로 `RowKey` 개별 엔터티를 반환합니다. 그러나 일부 시나리오에서는 동일한 파티션또는 여러 파티션에서 많은 엔터티를 반환해야 할 수도 있습니다. 이러한 시나리오에서는 항상 애플리케이션의 성능을 철저히 테스트해야 합니다.  

Table 저장소에 대한 쿼리는 한 번에 최대 1,000개의 엔터티를 반환하고 최대 5초 동안 실행할 수 있습니다. 테이블 저장소는 연속 토큰을 반환하여 클라이언트 응용 프로그램이 다음 엔터티 집합을 요청할 수 있도록 합니다(다음 중 첫 번째 엔터티)가 true인 경우.

- 결과 집합에는 1,000개 이상의 엔터티가 포함되어 있습니다.
- 5초 이내에 쿼리가 완료되지 않았습니다.
- 쿼리는 파티션 경계를 교차합니다. 

연속 토큰의 작동 방식에 대한 자세한 내용은 [쿼리 시간 시간 및 페이지 표시를](https://msdn.microsoft.com/library/azure/dd135718.aspx)참조하십시오.  

저장소 클라이언트 라이브러리를 사용하는 경우 Table 저장소에서 엔터티를 반환할 때 연속 토큰을 자동으로 처리할 수 있습니다. 예를 들어 다음 C# 코드 샘플은 Table 저장소가 응답으로 반환하는 경우 연속 토큰을 자동으로 처리합니다.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

다음 C# 코드는 연속 토큰을 명시적으로 처리합니다.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

연속 토큰을 명시적으로 사용하면 애플리케이션이 데이터의 다음 세그먼트를 검색하는 시점을 제어할 수 있습니다. 예를 들어 클라이언트 응용 프로그램에서 사용자가 테이블에 저장된 엔터티를 통해 페이징할 수 있도록 하는 경우 사용자는 쿼리에서 검색한 모든 엔터티를 페이징하지 않기로 결정할 수 있습니다. 응용 프로그램은 사용자가 현재 세그먼트의 모든 엔터티를 페이징을 완료했을 때만 연속 토큰을 사용하여 다음 세그먼트를 검색합니다. 이 접근 방식에는 몇 가지 이점이 있습니다.  

* Table 저장소에서 검색할 데이터와 네트워크를 통해 이동하는 데이터의 양을 제한할 수 있습니다.  
* .NET에서 비동기 I/O를 수행할 수 있습니다.  
* 연속 토큰을 영구 저장소로 직렬화할 수 있으므로 응용 프로그램 충돌이 발생할 경우 계속할 수 있습니다.  

> [!NOTE]
> 연속 토큰은 일반적으로 1,000개의 엔터티를 포함하는 세그먼트를 반환하지만 더 적은 수의 엔터티를 포함할 수 있습니다. 검색 조건과 일치하는 첫 번째 n 엔터티를 반환하기 위해 **Take를** 사용하여 쿼리가 반환하는 항목 수를 제한하는 경우에도 마찬가지입니다. 테이블 저장소는 나머지 엔터티를 검색할 수 있도록 연속 토큰과 함께 n개 미만의 엔터티를 포함하는 세그먼트를 반환할 수 있습니다.  
> 
> 

다음 C# 코드에서는 세그먼트 내에서 반환되는 엔터티 수를 수정하는 방법을 보여 줍니다.  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a>서버 쪽 프로젝션
단일 엔터티는 최대 255개의 속성을 가질 수 있으며, 크기가 최대 1MB일 수 있습니다. 테이블을 쿼리하고 엔터티를 검색할 때 모든 속성이 필요하지 않을 수 있으며 지연 시간과 비용을 줄이기 위해 데이터를 불필요하게 전송하지 않을 수 있습니다. 서버 쪽 프로젝션을 사용하여 필요한 속성만 전송할 수 있습니다. 다음 예제에서는 쿼리에서 `Email` 선택한 엔터티에서 `RowKey` `Timestamp`속성(와 함께 `ETag` `PartitionKey`및)만 검색합니다.  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

검색할 `RowKey` 속성 목록에 포함되지 않은 경우에도 값을 사용할 수 있는 방법을 확인합니다.  

### <a name="modify-entities"></a>엔터티 수정
저장소 클라이언트 라이브러리를 사용하면 엔터티를 삽입, 삭제 및 업데이트하여 테이블 저장소에 저장된 엔터티를 수정할 수 있습니다. ET를 사용하여 여러 인서트를 일괄 처리하고, 작업을 업데이트하고, 삭제하여 필요한 왕복 횟수를 줄이고 솔루션의 성능을 향상시킬 수 있습니다.  

저장소 클라이언트 라이브러리가 EGT를 실행할 때 발생하는 예외에는 일반적으로 일괄 처리가 실패하게 한 엔터티의 인덱스가 포함됩니다. 이는 EGT를 사용하는 코드를 디버그할 때 유용합니다.  

디자인이 클라이언트 애플리케이션에서 동시성 및 업데이트 작업을 처리하는 방법에 어떤 영향을 미치는지도 고려해야 합니다.  

#### <a name="managing-concurrency"></a>동시성 관리
기본적으로 Table 저장소는 클라이언트가 Table 저장소에서 이러한 검사를 우회하도록 강제할 수 있지만 삽입, 병합 및 삭제 작업에 대한 개별 엔터티 수준에서 낙관적 동시성 검사를 구현합니다. 자세한 내용은 [Microsoft Azure 저장소의 동시성 관리를](../storage/common/storage-concurrency.md)참조하십시오.  

#### <a name="merge-or-replace"></a>병합 또는 바꾸기
`TableOperation` 클래스의 메서드는 `Replace` 항상 테이블 저장소의 전체 엔터티를 대체합니다. 해당 속성이 저장된 엔터티에 있을 때 요청에 속성을 포함하지 않으면 요청은 저장된 엔터티에서 해당 속성을 제거합니다. 저장된 엔터티에서 속성을 명시적으로 제거하지 않은 한 모든 속성을 요청에 포함해야 합니다.  

클래스의 메서드를 `Merge` `TableOperation` 사용하여 엔터티를 업데이트할 때 Table 저장소에 보내는 데이터의 양을 줄일 수 있습니다. 메서드는 `Merge` 저장된 엔터티의 모든 속성을 요청에 포함된 엔터티의 속성 값으로 바꿉습니다. 이 메서드는 요청에 포함되지 않은 저장된 엔터티의 모든 속성을 그대로 둡니다. 이 기능은 엔터티가 크고 요청에서 소수의 속성만 업데이트하면 되는 경우에 유용합니다.  

> [!NOTE]
> `*Replace` 엔터티가 `Merge` 없으면 및 메서드가 실패합니다. 또는 존재하지 않는 경우 `InsertOrReplace` 새 `InsertOrMerge` 엔터티를 만드는 메서드 및 메서드를 사용할 수 있습니다.  
> 
> 

### <a name="work-with-heterogeneous-entity-types"></a>유형이 다른 엔터티 형식 사용
테이블 저장소는 *스키마가 없는 테이블 저장소입니다.* 즉, 단일 테이블은 여러 형식의 엔터티를 저장할 수 있으므로 디자인에 큰 유연성을 제공합니다. 다음 예제에서는 직원 및 부서 엔터티를 모두 저장하는 테이블을 보여 줍니다.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>타임스탬프</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

각 엔터티에는 `PartitionKey`여전히 `RowKey`? `Timestamp` 및 값이 있어야 하지만 모든 속성 집합을 가질 수 있습니다. 또한 해당 정보를 어딘가에 저장하지 않는 한 엔터티 유형을 나타낼 수 있는 것은 없습니다. 엔터티 유형을 식별하는 두 가지 옵션이 있습니다.  

* 엔터티 형식을 `RowKey` (또는 아마도)에 `PartitionKey`미리 준비합니다. 예를 `EMPLOYEE_000123` 들어, `DEPARTMENT_SALES` `RowKey` 또는 값으로.  
* 다음 표와 같이 별도의 속성을 사용하여 엔터티 형식을 기록합니다.  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>타임스탬프</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>department</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>Email</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

엔터티 형식을 `RowKey`에 미리 보류하는 첫 번째 옵션은 서로 다른 형식의 두 엔터티에 동일한 키 값이 있을 가능성이 있는 경우에 유용합니다. 또한 이 옵션은 동일한 유형의 엔터티를 파티션에서 그룹화합니다.  

이 섹션에서 설명하는 기술은 상속 관계에 대한 설명과 특히 관련이[있습니다.](#inheritance-relationships)  

> [!NOTE]
> 클라이언트 응용 프로그램이 POCO 개체를 발전시키고 다른 버전으로 작업할 수 있도록 엔터티 형식 값에 버전 번호를 포함하는 것이 좋습니다.  
> 
> 

이 섹션의 나머지 부분에서는 동일한 테이블의 여러 엔터티 유형으로 작업하는 데 용이한 Storage 클라이언트 라이브러리의 몇 가지 기능에 대해 설명합니다.  

#### <a name="retrieve-heterogeneous-entity-types"></a>이기종 엔터티 형식 검색
저장소 클라이언트 라이브러리를 사용하는 경우 여러 엔터티 유형으로 작업할 수 있는 세 가지 옵션이 있습니다.  

특정 `RowKey` 및 `PartitionKey` 값으로 저장된 엔터티의 유형을 알고 있는 경우 엔터티를 검색할 때 엔터티 형식을 지정할 수 있습니다. 형식의 `EmployeeEntity`엔터티를 검색하는 이전 두 예제에서 이를 보았습니다: [저장소 클라이언트 라이브러리를 사용하여 포인트 쿼리를 실행하고](#run-a-point-query-by-using-the-storage-client-library) [LINQ를 사용하여 여러 엔터티를 검색합니다.](#retrieve-multiple-entities-by-using-linq)  

두 번째 옵션은 구체적인 `DynamicTableEntity` POCO 엔터티 유형 대신 형식(속성 가방)을 사용하는 것입니다. 이 옵션은 엔터티를 .NET 형식에 직렬화하고 역직렬화할 필요가 없으므로 성능이 향상될 수도 있습니다. 다음 C# 코드는 테이블에서 서로 다른 형식의 여러 엔터티를 검색할 수 있지만 모든 엔터티를 인스턴스로 `DynamicTableEntity` 반환합니다. 그런 다음 `EntityType` 속성을 사용하여 각 엔터티의 유형을 결정합니다.  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

다른 속성을 검색하려면 클래스의 `TryGetValue` 속성에서 `Properties` 메서드를 `DynamicTableEntity` 사용해야 합니다.  

세 번째 옵션은 형식과 `DynamicTableEntity` 인스턴스를 `EntityResolver` 사용하여 결합하는 것입니다. 이 옵션을 사용하면 동일한 쿼리에서 여러 POCO 유형을 확인할 수 있습니다. 이 예제에서 `EntityResolver` 대리자는 `EntityType` 속성을 사용하여 쿼리가 반환하는 두 가지 유형의 엔터티를 구분합니다. 메서드는 `Resolve` `resolver` 대리자를 사용하여 `DynamicTableEntity` 인스턴스를 인스턴스로 확인합니다. `TableEntity`  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modify-heterogeneous-entity-types"></a>이기종 엔터티 형식 수정
삭제할 엔터티의 유형을 알 필요가 없으며 엔터티를 삽입할 때 엔터티의 형식을 항상 알 수 있습니다. 그러나 `DynamicTableEntity` 형식을 사용하여 형식을 모르고 POCO 엔터티 클래스를 사용하지 않고 엔터티를 업데이트할 수 있습니다. 다음 코드 샘플은 단일 엔터티를 검색하고 `EmployeeCount` 업데이트하기 전에 속성이 있는지 확인합니다.  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="control-access-with-shared-access-signatures"></a>공유 액세스 서명으로 액세스 제어
SAS(공유 액세스 시그니처) 토큰을 사용하여 Table storage를 사용하여 직접 인증할 필요 없이 클라이언트 응용 프로그램이 테이블 엔터티를 직접 수정(및 쿼리)할 수 있습니다. 일반적으로 애플리케이션응에서 SAS를 사용할 경우 세 가지 주요 이점이 있습니다.  

* 해당 장치가 테이블 저장소의 엔터티에 액세스하고 수정할 수 있도록 하기 위해 저장소 계정 키를 안전하지 않은 플랫폼(예: 모바일 장치)에 배포할 필요가 없습니다.  
* 엔터티 를 관리하는 데 웹 및 작업자 역할이 수행하는 작업 중 일부를 오프로드할 수 있습니다. 최종 사용자 컴퓨터 및 모바일 장치와 같은 클라이언트 장치에 오프로드할 수 있습니다.  
* 클라이언트에 제한적이고 시간 제한적인 사용 권한 집합을 할당할 수 있습니다(예: 특정 리소스에 대한 읽기 전용 액세스 허용).  

테이블 저장소에서 SAS 토큰을 사용하는 자세한 내용은 [SAS(공유 액세스 서명 사용)를](../storage/common/storage-dotnet-shared-access-signature-part-1.md)참조하십시오.  

그러나 Table 저장소의 엔터티에 클라이언트 응용 프로그램을 부여하는 SAS 토큰을 생성해야 합니다. 저장소 계정 키에 대한 보안 액세스 권한이 있는 환경에서 이 작업을 수행합니다. 일반적으로 웹 또는 작업자 역할을 사용하여 SAS 토큰을 생성하고 엔터티에 액세스해야 하는 클라이언트 애플리케이션에 이를 제공합니다. SAS 토큰을 생성하여 클라이언트에 제공하는 작업과 관련된 오버헤드가 여전히 있으므로 특히 대용량 시나리오에서 이 오버헤드를 줄일 수 있는 최상의 방법을 고려해야 합니다.  

테이블의 엔터티 하위 집합에 대한 액세스 권한을 부여하는 SAS 토큰을 생성할 수 있습니다. 기본적으로 전체 테이블에 대한 SAS 토큰을 만듭니다. 그러나 SAS 토큰이 값 범위 `PartitionKey` 또는 범위 `PartitionKey` 및 `RowKey` 값에 대한 액세스 권한을 부여하도록 지정할 수도 있습니다. 각 사용자의 SAS 토큰이 테이블 저장소의 자신의 엔터티에만 액세스할 수 있도록 시스템의 개별 사용자에 대해 SAS 토큰을 생성하도록 선택할 수 있습니다.  

### <a name="asynchronous-and-parallel-operations"></a>비동기 및 병렬 작업
여러 파티션에 요청을 분산하는 경우 비동기 또는 병렬 쿼리를 사용하여 처리량 및 클라이언트 응답성을 향상시킬 수 있습니다.
예를 들어 둘 이상의 작업자 역할 인스턴스에서 테이블에 병렬로 액세스하는 경우가 있을 수 있습니다. 특정 파티션 집합을 담당하는 개별 작업자 역할을 갖거나 테이블의 모든 파티션에 액세스할 수 있는 여러 작업자 역할 인스턴스를 가질 수 있습니다.  

클라이언트 인스턴스 내에서 저장소 작업을 비동기적으로 실행하여 처리량을 향상시킬 수 있습니다. Storage 클라이언트 라이브러리를 사용하면 비동기 쿼리 및 수정 사항을 쉽게 작성할 수 있습니다. 예를 들어 다음 C# 코드와 같이 파티션의 모든 엔터티를 검색하는 동기 메서드로 시작할 수 있습니다.  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

다음과 같이 쿼리가 비동기적으로 실행되도록 이 코드를 쉽게 수정할 수 있습니다.  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

이 비동기 예제에서는 동기 버전에서 다음 사항이 변경된 것을 확인할 수 있습니다.  

* 이제 메서드 시그니처에 `async` 수정자를 포함하고 인스턴스를 반환합니다. `Task`  
* 결과를 검색하기 `ExecuteSegmented` 위해 메서드를 호출하는 대신 `ExecuteSegmentedAsync` 메서드가 메서드를 호출합니다. 메서드는 `await` 수정자를 사용하여 결과를 비동기적으로 검색합니다.  

클라이언트 응용 프로그램은 매개 변수에 대해 서로 `department` 다른 값으로 이 메서드를 여러 번 호출할 수 있습니다. 각 쿼리는 별도의 스레드에서 실행됩니다.  

인터페이스가 비동기 열거를 `Execute` 지원하지 않기 `TableQuery` 때문에 클래스에 메서드의 비동기 버전이 없습니다. `IEnumerable`  

엔터티를 비동기식으로 삽입, 업데이트 및 삭제할 수도 있습니다. 다음 C# 예제에서는 직원 엔터티를 삽입하거나 바꾸는 간단한 동기 메서드를 보여 줍니다.  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

다음과 같이 업데이트가 비동기적으로 실행되도록 이 코드를 쉽게 수정할 수 있습니다.  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

이 비동기 예제에서는 동기 버전에서 다음 사항이 변경된 것을 확인할 수 있습니다.  

* 이제 메서드 시그니처에 `async` 수정자를 포함하고 인스턴스를 반환합니다. `Task`  
* 엔터티를 업데이트하는 메서드를 `Execute` 호출하는 대신 메서드가 메서드를 `ExecuteAsync` 호출합니다. 메서드는 `await` 수정자를 사용하여 결과를 비동기적으로 검색합니다.  

클라이언트 응용 프로그램은 이와 같은 여러 비동기 메서드를 호출할 수 있으며 각 메서드 호출은 별도의 스레드에서 실행됩니다.  


[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

