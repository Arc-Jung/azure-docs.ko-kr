---
title: 장애 조치(failover) 및 패치 - Azure Cache for Redis
description: 장애 조치, 패치 및 Redis용 Azure 캐시에 대한 업데이트 프로세스에 대해 알아봅니다.
author: asasine
ms.service: cache
ms.topic: conceptual
ms.date: 10/18/2019
ms.author: adsasine
ms.openlocfilehash: 6ff33bd594181aabc4fd7d55ce33f780a0d06086
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/27/2020
ms.locfileid: "74122196"
---
# <a name="failover-and-patching-for-azure-cache-for-redis"></a>Redis에 대 한 Azure 캐시에 대 한 장애 조치 및 패치

복원력이 뛰어나고 성공적인 클라이언트 응용 프로그램을 빌드하려면 Redis 서비스에 대한 Azure Cache의 컨텍스트에서 장애 조치(failover)를 이해하는 것이 중요합니다. 장애 조치(failover)는 계획된 관리 작업의 일부이거나 계획되지 않은 하드웨어 또는 네트워크 오류로 인해 발생할 수 있습니다. 캐시 장애 조치의 일반적인 사용은 관리 서비스가 Redis 바이너리에 대한 Azure 캐시를 패치할 때 발생합니다. 이 문서에서는 장애 조치(failover)가 무엇인지, 패치 하는 동안 장애 발생 방법 및 복원력 있는 클라이언트 응용 프로그램을 빌드하는 방법에 대해 설명합니다.

## <a name="what-is-a-failover"></a>장애 조치(failover)란 무엇입니까?

Redis에 대한 Azure 캐시에 대한 장애 조치(failover)에 대한 개요부터 시작해 보겠습니다.

### <a name="a-quick-summary-of-cache-architecture"></a>캐시 아키텍처에 대한 간략한 요약

캐시는 별도의 개인 IP 주소가 있는 여러 가상 컴퓨터로 구성됩니다. 노드라고도 하는 각 가상 시스템은 단일 가상 IP 주소가 있는 공유 로드 밸런서에 연결됩니다. 각 노드는 Redis 서버 프로세스를 실행하며 호스트 이름과 Redis 포트를 통해 액세스할 수 있습니다. 각 노드는 마스터 또는 복제본 노드로 간주됩니다. 클라이언트 응용 프로그램이 캐시에 연결하면 트래픽이 이 로드 밸러버를 통과하고 마스터 노드로 자동으로 라우팅됩니다.

기본 캐시에서 단일 노드는 항상 마스터입니다. 표준 또는 프리미엄 캐시에는 두 개의 노드가 있습니다. 표준 및 프리미엄 캐시에는 여러 노드가 있기 때문에 한 노드를 사용할 수 없는 반면 다른 노드는 요청을 계속 처리하지 못할 수 있습니다. 클러스터된 캐시는 각각 고유한 마스터 및 복제본 노드가 있는 많은 샤드로 구성됩니다. 한 샤드를 사용할 수 있는 동안 에는 한 샤드가 다운될 수 있습니다.

> [!NOTE]
> 기본 캐시에는 여러 노드가 없으며 가용성에 대한 서비스 수준 계약(SLA)을 제공하지 않습니다. 기본 캐시는 개발 및 테스트 목적으로만 권장됩니다. 다중 노드 배포에 표준 또는 프리미엄 캐시를 사용하여 가용성을 높입니다.

### <a name="explanation-of-a-failover"></a>장애 조치(failover)에 대한 설명

장애 조치(failover)는 복제본 노드가 마스터 노드로 승격되고 이전 마스터 노드가 기존 연결을 닫을 때 발생합니다. 마스터 노드가 다시 나타나면 역할의 변화를 알아차리고 자체적으로 복제본으로 강등됩니다. 그런 다음 새 마스터에 연결하고 데이터를 동기화합니다. 장애 조치(failover)가 계획되거나 계획되지 않은 것일 수 있습니다.

*계획된 장애 조치(Failover)는* Redis 패치 또는 OS 업그레이드와 같은 시스템 업데이트 및 크기 조정 및 재부팅과 같은 관리 작업 중에 수행됩니다. 노드는 업데이트에 대한 사전 알림을 받기 때문에 역할을 협조적으로 교환하고 변경의 로드 밸러버를 신속하게 업데이트할 수 있습니다. 계획된 장애 조치(failover)는 일반적으로 1초 이내에 완료됩니다.

하드웨어 오류, 네트워크 오류 또는 마스터 노드에 대한 예기치 않은 중단으로 인해 *계획되지 않은 장애 발생이* 발생할 수 있습니다. 복제본 노드는 마스터로 승격되지만 프로세스는 더 오래 걸립니다. 복제본 노드는 먼저 장애 조치 프로세스를 시작하기 전에 마스터 노드를 사용할 수 없음을 감지해야 합니다. 또한 복제본 노드는 불필요한 장애 조치(failover)를 피하기 위해 계획되지 않은 이 오류가 일시적이거나 로컬이 아닌지 확인해야 합니다. 이러한 검색 지연은 계획되지 않은 장애 조치(failover)가 일반적으로 10~15초 내에 완료된다는 것을 의미합니다.

## <a name="how-does-patching-occur"></a>패치는 어떻게 발생합니까?

Redis 서비스에 대한 Azure 캐시는 정기적으로 최신 플랫폼 기능 및 수정 사항으로 캐시를 업데이트합니다. 캐시를 패치하기 위해 서비스는 다음 단계를 따릅니다.

1. 관리 서비스는 패치할 노드 하나를 선택합니다.
1. 선택한 노드가 마스터 노드인 경우 해당 복제본 노드가 협력적으로 승격됩니다. 이 프로모션은 계획된 장애 조치(failover)로 간주됩니다.
1. 선택한 노드가 다시 부팅되어 새 변경 내용을 가져와 복제본 노드로 다시 나타납니다.
1. 복제본 노드는 마스터 노드에 연결하고 데이터를 동기화합니다.
1. 데이터 동기화가 완료되면 나머지 노드에 대해 패치 프로세스가 반복됩니다.

패치는 계획된 장애 조치이므로 복제본 노드는 신속하게 마스터가 되도록 승격하고 요청 및 새 연결 서비스를 시작합니다. 기본 캐시에는 복제본 노드가 없으며 업데이트가 완료될 때까지 사용할 수 없습니다. 클러스터된 캐시의 각 샤드는 별도로 패치되며 다른 샤드에 대한 연결을 닫지 않습니다.

> [!IMPORTANT]
> 노드는 데이터 손실을 방지하기 위해 한 번에 하나씩 패치됩니다. 기본 캐시에는 데이터 손실이 있습니다. 클러스터된 캐시는 한 번에 하나의 샤드로 패치됩니다.

동일한 리소스 그룹 및 리전의 여러 캐시도 한 번에 하나씩 패치됩니다.  서로 다른 리소스 그룹 또는 다른 지역에 있는 캐시는 동시에 패치될 수 있습니다.

프로세스가 반복되기 전에 전체 데이터 동기화가 수행되므로 표준 또는 프리미엄 캐시를 사용할 때 데이터 손실이 발생할 가능성이 거의 없습니다. 데이터를 [내보내고](cache-how-to-import-export-data.md#export) [지속성을](cache-how-to-premium-persistence.md)사용하도록 설정하여 데이터 손실을 방지할 수 있습니다.

## <a name="additional-cache-load"></a>추가 캐시 로드

장애 조치(failover)가 발생할 때마다 표준 및 프리미엄 캐시는 한 노드에서 다른 노드로 데이터를 복제해야 합니다. 이 복제로 인해 서버 메모리와 CPU 모두에서 일부 부하가 증가합니다. 캐시 인스턴스가 이미 많이 로드된 경우 클라이언트 응용 프로그램은 대기 시간이 증가할 수 있습니다. 극단적인 경우 클라이언트 응용 프로그램은 시간 시간 예외를 받을 수 있습니다. 이 추가 로드의 영향을 완화하려면 캐시 설정을 `maxmemory-reserved` [구성합니다.](cache-configure.md#memory-policies)

## <a name="how-does-a-failover-affect-my-client-application"></a>장애 조치는 클라이언트 응용 프로그램에 어떤 영향을 미칩니까?

클라이언트 응용 프로그램에서 볼 수 있는 오류 수는 장애 조치(failover) 시점에 해당 연결에 보류 중인 작업 수에 따라 달라집니다. 연결을 닫은 노드를 통해 라우팅된 모든 연결에 오류가 표시됩니다. 많은 클라이언트 라이브러리는 시간 시간 예외, 연결 예외 또는 소켓 예외를 포함하여 연결이 끊어질 때 다양한 유형의 오류를 throw할 수 있습니다. 예외의 수와 유형은 캐시가 연결을 닫을 때 요청이 코드 경로의 위치에 따라 달라집니다. 예를 들어, 요청을 보내지만 장애 조치가 발생할 때 응답을 받지 못한 작업은 시간 초과 예외를 얻을 수 있습니다. 닫힌 연결 개체에 대한 새 요청은 다시 연결이 성공적으로 완료될 때까지 연결 예외를 받습니다.

대부분의 클라이언트 라이브러리는 캐시에 다시 연결하려고 합니다. 그러나 예기치 않은 버그로 라이브러리 개체를 복구할 수 없는 상태로 배치할 수 있습니다. 미리 구성된 시간보다 오랫동안 오류가 지속되면 연결 개체를 다시 만들어야 합니다. Microsoft.NET 및 기타 개체 지향 언어에서는 응용 프로그램을 다시 시작하지 않고 연결을 다시 만들 면 [지연\<T\> 패턴을](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#reconnecting-with-lazyt-pattern)사용하여 수행할 수 있습니다.

### <a name="how-do-i-make-my-application-resilient"></a>응용 프로그램을 복원력 있게 만들면 어떻게 해야 합니까?

장애 조치(failover)를 완전히 피할 수는 없으므로 연결 중단 및 실패한 요청에 대한 복원성을 위해 클라이언트 응용 프로그램을 작성합니다. 대부분의 클라이언트 라이브러리가 캐시 끝점에 자동으로 다시 연결되지만 실패한 요청을 다시 시도하려는 클라이언트 라이브러리는 거의 없습니다. 응용 프로그램 시나리오에 따라 백오프를 사용하여 다시 시도 논리를 사용하는 것이 합리적일 수 있습니다.

클라이언트 응용 프로그램의 복원력을 테스트하려면 연결 중단을 위한 수동 트리거로 [재부팅을](cache-administration.md#reboot) 사용합니다. 또한 캐시에서 [업데이트를 예약하는](cache-administration.md#schedule-updates) 것이 좋습니다. 지정된 주간 기간 동안 Redis 런타임 패치를 적용하도록 관리 서비스에 알부세요. 이러한 창은 일반적으로 잠재적인 인시던트를 피하기 위해 클라이언트 응용 프로그램 트래픽이 적은 기간입니다.

### <a name="client-network-configuration-changes"></a>클라이언트 네트워크 구성 변경 사항

특정 클라이언트 측 네트워크 구성 변경으로 인해 "연결 가능 없음" 오류가 발생할 수 있습니다. 이러한 변경 사항에는 다음이 포함될 수 있습니다.

- 스테이징 슬롯과 프로덕션 슬롯 간에 클라이언트 응용 프로그램의 가상 IP 주소를 교환합니다.
- 응용 프로그램의 인스턴스 크기 또는 수를 조정합니다.

이러한 변경으로 인해 1분 미만지속되는 연결 문제가 발생할 수 있습니다. 클라이언트 응용 프로그램은 Redis 서비스에 대한 Azure 캐시 외에 다른 외부 네트워크 리소스에 대한 연결이 손실될 수 있습니다.

## <a name="next-steps"></a>다음 단계

- 캐시에 대한 [업데이트를 예약합니다.](cache-administration.md#schedule-updates)
- [재부팅을](cache-administration.md#reboot)사용하여 응용 프로그램 복원력을 테스트합니다.
- 메모리 예약 및 정책을 [구성합니다.](cache-configure.md#memory-policies)
