---
title: Azure Functions C# 개발자 참조
description: 을 사용 하 여 C#Azure Functions를 개발 하는 방법을 이해 합니다.
ms.topic: reference
ms.date: 09/12/2018
ms.openlocfilehash: f412e5ea358fe7b97476802f432616c37b05dbd9
ms.sourcegitcommit: 5ab4f7a81d04a58f235071240718dfae3f1b370b
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/10/2019
ms.locfileid: "74975485"
---
# <a name="azure-functions-c-developer-reference"></a>Azure Functions C# 개발자 참조

<!-- When updating this article, make corresponding changes to any duplicate content in functions-reference-csharp.md -->

이 문서에서는 .NET 클래스 라이브러리에서를 사용 C# 하 여 Azure Functions를 개발 하는 방법을 소개 합니다.

Azure Functions는 C# 및 C# 스크립트 프로그래밍 언어를 지원 합니다. [Azure Portal에서를 사용 하는 C# 방법](functions-create-function-app-portal.md)에 대 한 지침은 [ C# 스크립트 (csx) 개발자 참조](functions-reference-csharp.md)를 참조 하세요.

이 문서에서는 다음 문서를 이미 알고 있다고 가정 합니다.

* [Azure Functions 개발자 가이드](functions-reference.md)
* [Azure Functions Visual Studio 2019 도구](functions-develop-vs.md)

## <a name="supported-versions"></a>Támogatott verziók

함수 런타임의 버전은 특정 버전의 .NET에서 작동 합니다. 다음 표에서는 프로젝트에서 특정 버전의 함수에 사용할 수 있는 .NET Core 및 .NET Framework 및 .NET Core의 가장 높은 수준을 보여 줍니다. 

| 함수 런타임 버전 | 최대 .NET 버전 |
| ---- | ---- |
| 함수 3(sp3) | .NET Core 3.1 |
| Functions 2.x | .NET Core 2.2 |
| Functions 1.x | .NET-keretrendszer 4.6 |

자세히 알아보려면 [Azure Functions 런타임 버전 개요](functions-versions.md) 를 참조 하세요.

## <a name="functions-class-library-project"></a>함수 클래스 라이브러리 프로젝트

Visual Studio에서 **Azure Functions** 프로젝트 템플릿은 다음 파일을 포함 C# 하는 클래스 라이브러리 프로젝트를 만듭니다.

* [호스트 json](functions-host-json.md) -로컬로 또는 Azure에서 실행 하는 경우 프로젝트의 모든 함수에 영향을 주는 구성 설정을 저장 합니다.
* [local. settings](functions-run-local.md#local-settings-file) -로컬로 실행할 때 사용 되는 앱 설정 및 연결 문자열을 저장 합니다. 이 파일에는 암호가 포함 되어 있으며 Azure의 함수 앱에 게시 되지 않습니다. 대신, [함수 앱에 앱 설정을 추가](functions-develop-vs.md#function-app-settings)합니다.

프로젝트를 빌드하면 빌드 출력 디렉터리에 다음 예제와 같은 폴더 구조가 생성 됩니다.

```
<framework.version>
 | - bin
 | - MyFirstFunction
 | | - function.json
 | - MySecondFunction
 | | - function.json
 | - host.json
```

이 디렉터리는 Azure의 함수 앱에 배포 됩니다. 함수 런타임의 [버전](functions-versions.md) 2.x에 필요한 바인딩 확장은 [NuGet 패키지로 프로젝트에 추가](./functions-bindings-register.md#vs)됩니다.

> [!IMPORTANT]
> 빌드 프로세스에서는 각 함수에 대 한 *함수 json* 파일을 만듭니다. 이 *함수인 json* 파일은 직접 편집할 수 없습니다. 이 파일을 편집 하 여 바인딩 구성을 변경 하거나 함수를 사용 하지 않도록 설정할 수 없습니다. 함수를 사용 하지 않도록 설정 하는 방법을 알아보려면 [함수를 사용 하지 않도록 설정 하는 방법](disable-function.md)을 참조 하세요.


## <a name="methods-recognized-as-functions"></a>함수로 인식 되는 메서드

클래스 라이브러리에서 함수는 다음 예제와 같이 `FunctionName` 및 트리거 특성을 사용 하는 정적 메서드입니다.

```csharp
public static class SimpleExample
{
    [FunctionName("QueueTrigger")]
    public static void Run(
        [QueueTrigger("myqueue-items")] string myQueueItem, 
        ILogger log)
    {
        log.LogInformation($"C# function processed: {myQueueItem}");
    }
} 
```

`FunctionName` 특성은 메서드를 함수 진입점으로 표시 합니다. 이름은 프로젝트 내에서 고유 해야 하 고, 문자로 시작 하 고 문자, 숫자, `_`및 `-`만 포함 해야 합니다. 최대 길이는 127 자입니다. 프로젝트 템플릿에서는 `Run`라는 메서드를 만들지만 메서드 이름은 모든 유효한 C# 메서드 이름일 수 있습니다.

Trigger 특성은 트리거 유형을 지정 하 고 입력 데이터를 메서드 매개 변수에 바인딩합니다. 예제 함수는 큐 메시지에 의해 트리거되고 큐 메시지는 `myQueueItem` 매개 변수의 메서드에 전달 됩니다.

## <a name="method-signature-parameters"></a>메서드 서명 매개 변수

메서드 시그니처에는 트리거 특성과 함께 사용 되는 매개 변수 이외의 매개 변수가 포함 될 수 있습니다. 포함할 수 있는 몇 가지 추가 매개 변수는 다음과 같습니다.

* 특성을 사용 하 여 데코레이팅하는 것으로 표시 된 [입력 및 출력 바인딩입니다](functions-triggers-bindings.md) .  
* [로깅을](#logging)위한 `ILogger` 또는 `TraceWriter` ([버전 1.x 전용](functions-versions.md#creating-1x-apps)) 매개 변수입니다.
* [정상 종료](#cancellation-tokens)를 위한 `CancellationToken` 매개 변수입니다.
* 트리거 메타 데이터를 가져오기 위한 식 매개 변수 [바인딩](./functions-bindings-expressions-patterns.md)

함수 시그니처의 매개 변수 순서는 중요 하지 않습니다. 예를 들어 다른 바인딩 앞 이나 뒤에 트리거 매개 변수를 배치할 수 있으며, 또는 after 트리거 또는 바인딩 매개 변수 앞 이나 뒤에로 거 매개 변수를 추가할 수 있습니다.

### <a name="output-binding-example"></a>출력 바인딩 예

다음 예제에서는 출력 큐 바인딩을 추가 하 여 선행 항목을 수정 합니다. 함수는 함수를 다른 큐의 새 큐 메시지로 트리거하는 큐 메시지를 씁니다.

```csharp
public static class SimpleExampleWithOutput
{
    [FunctionName("CopyQueueMessage")]
    public static void Run(
        [QueueTrigger("myqueue-items-source")] string myQueueItem, 
        [Queue("myqueue-items-destination")] out string myQueueItemCopy,
        ILogger log)
    {
        log.LogInformation($"CopyQueueMessage function processed: {myQueueItem}");
        myQueueItemCopy = myQueueItem;
    }
}
```

바인딩 참조 문서 (예:[저장소 큐](functions-bindings-storage-queue.md))는 트리거, 입력 또는 출력 바인딩 특성에 사용할 수 있는 매개 변수 형식을 설명 합니다.

### <a name="binding-expressions-example"></a>바인딩 식 예

다음 코드는 앱 설정에서 모니터링할 큐의 이름을 가져오고 `insertionTime` 매개 변수에서 큐 메시지 생성 시간을 가져옵니다.

```csharp
public static class BindingExpressionsExample
{
    [FunctionName("LogQueueMessage")]
    public static void Run(
        [QueueTrigger("%queueappsetting%")] string myQueueItem,
        DateTimeOffset insertionTime,
        ILogger log)
    {
        log.LogInformation($"Message content: {myQueueItem}");
        log.LogInformation($"Created at: {insertionTime}");
    }
}
```

## <a name="autogenerated-functionjson"></a>자동 생성 함수. json

빌드 프로세스는 빌드 폴더의 함수 폴더에 *json* 파일을 만듭니다. 앞에서 설명한 것 처럼이 파일은 직접 편집할 수 없습니다. 이 파일을 편집 하 여 바인딩 구성을 변경 하거나 함수를 사용 하지 않도록 설정할 수 없습니다. 

이 파일의 목적은 [소비 계획에 대 한 크기 조정을 결정](functions-scale.md#how-the-consumption-and-premium-plans-work)하는 데 사용할 수 있도록 크기 조정 컨트롤러에 정보를 제공 하는 것입니다. 이러한 이유로 파일에는 입력 또는 출력 바인딩이 아닌 트리거 정보만 있습니다.

생성 된 *함수인 json* 파일에는 *함수 json* 구성 대신 바인딩에 .net 특성을 사용 하도록 런타임에 지시 하는 `configurationSource` 속성이 포함 되어 있습니다. Például:

```json
{
  "generatedBy": "Microsoft.NET.Sdk.Functions-1.0.0.0",
  "configurationSource": "attributes",
  "bindings": [
    {
      "type": "queueTrigger",
      "queueName": "%input-queue-name%",
      "name": "myQueueItem"
    }
  ],
  "disabled": false,
  "scriptFile": "..\\bin\\FunctionApp1.dll",
  "entryPoint": "FunctionApp1.QueueTrigger.Run"
}
```

## <a name="microsoftnetsdkfunctions"></a>Microsoft .NET Sdk 함수

*함수 json* 파일 생성은 NuGet 패키지 [Microsoft\.NET\.Sdk\.함수](https://www.nuget.org/packages/Microsoft.NET.Sdk.Functions)에 의해 수행 됩니다. 

동일한 패키지가 함수 런타임의 버전 1.x 및 2.x 모두에 사용 됩니다. 대상 프레임 워크는 2.x 프로젝트에서 1.x 프로젝트를 구별 하는 것입니다. 다음은 다른 대상 프레임 워크와 동일한 `Sdk` 패키지를 보여 주는 *.csproj* 파일의 관련 부분입니다.

**함수 1.x**

```xml
<PropertyGroup>
  <TargetFramework>net461</TargetFramework>
</PropertyGroup>
<ItemGroup>
  <PackageReference Include="Microsoft.NET.Sdk.Functions" Version="1.0.8" />
</ItemGroup>
```

**함수 2.x**

```xml
<PropertyGroup>
  <TargetFramework>netcoreapp2.1</TargetFramework>
  <AzureFunctionsVersion>v2</AzureFunctionsVersion>
</PropertyGroup>
<ItemGroup>
  <PackageReference Include="Microsoft.NET.Sdk.Functions" Version="1.0.8" />
</ItemGroup>
```

`Sdk` 패키지 종속성 중에는 트리거와 바인딩이 있습니다. 1\.x 프로젝트는 1.x 트리거와 바인딩이 .NET Framework 대상으로 하는 반면, 2.x 트리거와 바인딩은 .NET Core를 대상으로 하기 때문에 1. x 트리거 및 바인딩을 참조 합니다.

`Sdk` 패키지는 [newtonsoft.json](https://www.nuget.org/packages/Newtonsoft.Json)에 종속 되 고 [windowsazure.servicebus](https://www.nuget.org/packages/WindowsAzure.Storage)에 간접적으로 종속 됩니다. 이러한 종속성은 프로젝트에서 대상으로 하는 함수 런타임 버전에서 작동 하는 패키지 버전을 프로젝트에서 사용 하는지 확인 합니다. 예를 들어 `Newtonsoft.Json` .NET Framework 4.6.1에 대 한 버전 11이 있지만 .NET Framework를 대상으로 하는 함수 런타임은 `Newtonsoft.Json` 9.0.1와만 호환 됩니다. 따라서 해당 프로젝트의 함수 코드는 `Newtonsoft.Json` 9.0.1도 사용 해야 합니다.

`Microsoft.NET.Sdk.Functions`에 대 한 소스 코드는 GitHub 리포지토리 [azure\-함수\-vs\-빌드\-sdk](https://github.com/Azure/azure-functions-vs-build-sdk)에서 사용할 수 있습니다.

## <a name="runtime-version"></a>런타임 버전

Visual Studio는 [Azure Functions Core Tools](functions-run-local.md#install-the-azure-functions-core-tools) 을 사용 하 여 함수 프로젝트를 실행 합니다. 핵심 도구는 함수 런타임에 대 한 명령줄 인터페이스입니다.

Npm를 사용 하 여 핵심 도구를 설치 하는 경우 Visual Studio에서 사용 하는 핵심 도구 버전에 영향을 주지 않습니다. 함수 런타임 버전 1.x의 경우 Visual Studio는 *%USERPROFILE%\AppData\Local\Azure.Functions.Cli* 에 핵심 도구 버전을 저장 하 고 거기에 저장 된 최신 버전을 사용 합니다. 함수 2.x의 경우 핵심 도구는 **Azure Functions 및 웹 작업 도구** 확장에 포함 되어 있습니다. 1\.x와 2.x 모두에서 함수 프로젝트를 실행할 때 콘솔 출력에 사용 되는 버전을 확인할 수 있습니다.

```terminal
[3/1/2018 9:59:53 AM] Starting Host (HostId=contoso2-1518597420, Version=2.0.11353.0, ProcessId=22020, Debug=False, Attempt=0, FunctionsExtensionVersion=)
```

## <a name="supported-types-for-bindings"></a>바인딩에 대해 지원 되는 형식

각 바인딩에는 자체 지원 형식이 있습니다. 예를 들어 blob 트리거 특성은 문자열 매개 변수, POCO 매개 변수, `CloudBlockBlob` 매개 변수 또는 지원 되는 다른 여러 형식에 적용 될 수 있습니다. [Blob 바인딩에 대 한 바인딩 참조 문서](functions-bindings-storage-blob.md#trigger---usage) 에는 지원 되는 모든 매개 변수 형식이 나열 됩니다. 자세한 내용은 [트리거 및](functions-triggers-bindings.md) 바인딩 및 [각 바인딩 형식에 대 한 바인딩 참조 문서](functions-triggers-bindings.md#next-steps)를 참조 하세요.

[!INCLUDE [HTTP client best practices](../../includes/functions-http-client-best-practices.md)]

## <a name="binding-to-method-return-value"></a>메서드 반환 값에 바인딩

메서드 반환 값에 특성을 적용 하 여 출력 바인딩에 메서드 반환 값을 사용할 수 있습니다. 예제는 [트리거 및 바인딩](./functions-bindings-return-value.md)을 참조 하세요. 

성공적인 함수 실행으로 인해 항상 반환 값이 출력 바인딩에 전달 되는 경우에만 반환 값을 사용 합니다. 그렇지 않으면 다음 섹션에 나와 있는 것 처럼 `ICollector` 또는 `IAsyncCollector`를 사용 합니다.

## <a name="writing-multiple-output-values"></a>여러 출력 값 쓰기

출력 바인딩에 여러 값을 기록 하거나 함수를 성공적으로 호출 하는 경우 출력 바인딩에 전달할 항목이 없을 수 있는 경우 [`ICollector`](https://github.com/Azure/azure-webjobs-sdk/blob/master/src/Microsoft.Azure.WebJobs/ICollector.cs) 또는 [`IAsyncCollector`](https://github.com/Azure/azure-webjobs-sdk/blob/master/src/Microsoft.Azure.WebJobs/IAsyncCollector.cs) 형식을 사용 합니다. 이러한 형식은 메서드가 완료 될 때 출력 바인딩에 기록 되는 쓰기 전용 컬렉션입니다.

이 예제에서는 `ICollector`를 사용 하 여 여러 큐 메시지를 동일한 큐에 씁니다.

```csharp
public static class ICollectorExample
{
    [FunctionName("CopyQueueMessageICollector")]
    public static void Run(
        [QueueTrigger("myqueue-items-source-3")] string myQueueItem,
        [Queue("myqueue-items-destination")] ICollector<string> myDestinationQueue,
        ILogger log)
    {
        log.LogInformation($"C# function processed: {myQueueItem}");
        myDestinationQueue.Add($"Copy 1: {myQueueItem}");
        myDestinationQueue.Add($"Copy 2: {myQueueItem}");
    }
}
```

## <a name="logging"></a>Naplózás

에서 C#스트리밍 로그에 대 한 출력을 기록 하려면 [ILogger](https://docs.microsoft.com/dotnet/api/microsoft.extensions.logging.ilogger)형식의 인수를 포함 합니다. 다음 예제와 같이 `log`이름을로 표시 하는 것이 좋습니다.  

```csharp
public static class SimpleExample
{
    [FunctionName("QueueTrigger")]
    public static void Run(
        [QueueTrigger("myqueue-items")] string myQueueItem, 
        ILogger log)
    {
        log.LogInformation($"C# function processed: {myQueueItem}");
    }
} 
```

Azure Functions에서 `Console.Write` 사용 하지 마십시오. 자세한 내용은 **Monitor Azure Functions** 문서에서 [함수에서 C# 로그 쓰기](functions-monitoring.md#write-logs-in-c-functions) 를 참조 하세요.

## <a name="async"></a>Async

[비동기](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/async/)함수를 만들려면 `async` 키워드를 사용 하 고 `Task` 개체를 반환 합니다.

```csharp
public static class AsyncExample
{
    [FunctionName("BlobCopy")]
    public static async Task RunAsync(
        [BlobTrigger("sample-images/{blobName}")] Stream blobInput,
        [Blob("sample-images-copies/{blobName}", FileAccess.Write)] Stream blobOutput,
        CancellationToken token,
        ILogger log)
    {
        log.LogInformation($"BlobCopy function processed.");
        await blobInput.CopyToAsync(blobOutput, 4096, token);
    }
}
```

비동기 함수에는 `out` 매개 변수를 사용할 수 없습니다. 출력 바인딩의 경우 [함수 반환 값](#binding-to-method-return-value) 또는 [수집기 개체](#writing-multiple-output-values) 를 대신 사용 합니다.

## <a name="cancellation-tokens"></a>취소 토큰

함수는 함수가 종료 될 때 운영 체제에서 코드를 알릴 수 있도록 하는 [CancellationToken](/dotnet/api/system.threading.cancellationtoken) 매개 변수를 사용할 수 있습니다. 이 알림을 사용 하 여 데이터가 일관 되지 않은 상태로 유지 되는 방식으로 함수가 예기치 않게 종료 되지 않도록 할 수 있습니다.

다음 예제에서는 임박한 함수 종료를 확인 하는 방법을 보여 줍니다.

```csharp
public static class CancellationTokenExample
{
    public static void Run(
        [QueueTrigger("inputqueue")] string inputText,
        TextWriter logger,
        CancellationToken token)
    {
        for (int i = 0; i < 100; i++)
        {
            if (token.IsCancellationRequested)
            {
                logger.WriteLine("Function was cancelled at iteration {0}", i);
                break;
            }
            Thread.Sleep(5000);
            logger.WriteLine("Normal processing for queue message={0}", inputText);
        }
    }
}
```

## <a name="environment-variables"></a>Környezeti változók

환경 변수 또는 앱 설정 값을 가져오려면 다음 코드 예제와 같이 `System.Environment.GetEnvironmentVariable`를 사용 합니다.

```csharp
public static class EnvironmentVariablesExample
{
    [FunctionName("GetEnvironmentVariables")]
    public static void Run([TimerTrigger("0 */5 * * * *")]TimerInfo myTimer, ILogger log)
    {
        log.LogInformation($"C# Timer trigger function executed at: {DateTime.Now}");
        log.LogInformation(GetEnvironmentVariable("AzureWebJobsStorage"));
        log.LogInformation(GetEnvironmentVariable("WEBSITE_SITE_NAME"));
    }

    public static string GetEnvironmentVariable(string name)
    {
        return name + ": " +
            System.Environment.GetEnvironmentVariable(name, EnvironmentVariableTarget.Process);
    }
}
```

앱 설정은 로컬로 개발 하는 경우와 Azure에서 실행할 때 모두 환경 변수에서 읽을 수 있습니다. 로컬로 개발할 때 앱 설정은 *로컬 설정 json* 파일의 `Values` 컬렉션에서 제공 됩니다. 두 환경 모두 로컬 및 Azure `GetEnvironmentVariable("<app setting name>")` 명명 된 앱 설정 값을 검색 합니다. 예를 들어 *로컬* 에서 실행 하는 경우에는 "My Site Name"이 반환 됩니다 .이 파일에는 `{ "Values": { "WEBSITE_SITE_NAME": "My Site Name" } }`포함 되어 있습니다.

[ConfigurationManager](https://docs.microsoft.com/dotnet/api/system.configuration.configurationmanager.appsettings) 속성은 앱 설정 값을 가져오는 대체 API 이지만 여기에 나와 있는 것 처럼 `GetEnvironmentVariable`를 사용 하는 것이 좋습니다.

## <a name="binding-at-runtime"></a>런타임에 바인딩

및 기타 .NET 언어에서는 특성의 [*선언적*](https://en.wikipedia.org/wiki/Declarative_programming) 바인딩과는 반대로 명령적 바인딩 패턴을 사용할 수 [있습니다](https://en.wikipedia.org/wiki/Imperative_programming) C#.   명령적 바인딩은 디자인 타임이 아닌 런타임에 바인딩 매개 변수를 계산 해야 하는 경우에 유용 합니다. 이 패턴을 사용 하면 함수 코드에서 지원 되는 입력 및 출력 바인딩을 즉시 바인딩할 수 있습니다.

명령적 바인딩을 다음과 같이 정의 합니다.

- 원하는 명령적 바인딩에 대 한 함수 시그니처에 특성을 포함 **하지 마십시오** .
- 입력 매개 변수 [`Binder binder`](https://github.com/Azure/azure-webjobs-sdk/blob/master/src/Microsoft.Azure.WebJobs.Host/Bindings/Runtime/Binder.cs) 또는 [`IBinder binder`](https://github.com/Azure/azure-webjobs-sdk/blob/master/src/Microsoft.Azure.WebJobs/IBinder.cs)를 전달 합니다.
- 다음 C# 패턴을 사용 하 여 데이터 바인딩을 수행 합니다.

  ```cs
  using (var output = await binder.BindAsync<T>(new BindingTypeAttribute(...)))
  {
      ...
  }
  ```

  `BindingTypeAttribute`는 바인딩을 정의 하는 .NET 특성이 며 `T`는 해당 바인딩 형식에서 지원 되는 입력 또는 출력 형식입니다. `T`는 `out` 매개 변수 형식 (예: `out JObject`)이 될 수 없습니다. 예를 들어 Mobile Apps 테이블 출력 바인딩은 [6 가지 출력 형식](https://github.com/Azure/azure-webjobs-sdk-extensions/blob/master/src/WebJobs.Extensions.MobileApps/MobileTableAttribute.cs#L17-L22)을 지원 하지만 명령적 바인딩과 함께 [ICollector\<t >](https://github.com/Azure/azure-webjobs-sdk/blob/master/src/Microsoft.Azure.WebJobs/ICollector.cs) 또는 [iasynccollector\<t >](https://github.com/Azure/azure-webjobs-sdk/blob/master/src/Microsoft.Azure.WebJobs/IAsyncCollector.cs) 만 사용할 수 있습니다.

### <a name="single-attribute-example"></a>단일 특성 예제

다음 예제 코드는 런타임에 정의 된 blob 경로를 사용 하 여 [저장소 blob 출력 바인딩을](functions-bindings-storage-blob.md#output) 만든 다음 문자열을 blob에 씁니다.

```cs
public static class IBinderExample
{
    [FunctionName("CreateBlobUsingBinder")]
    public static void Run(
        [QueueTrigger("myqueue-items-source-4")] string myQueueItem,
        IBinder binder,
        ILogger log)
    {
        log.LogInformation($"CreateBlobUsingBinder function processed: {myQueueItem}");
        using (var writer = binder.Bind<TextWriter>(new BlobAttribute(
                    $"samples-output/{myQueueItem}", FileAccess.Write)))
        {
            writer.Write("Hello World!");
        };
    }
}
```

[Blobattribute](https://github.com/Azure/azure-webjobs-sdk/blob/master/src/Microsoft.Azure.WebJobs.Extensions.Storage/Blobs/BlobAttribute.cs) 는 [저장소 blob](functions-bindings-storage-blob.md) 입력 또는 출력 바인딩을 정의 하 고, [TextWriter](/dotnet/api/system.io.textwriter) 는 지원 되는 출력 바인딩 유형입니다.

### <a name="multiple-attribute-example"></a>여러 특성 예제

앞의 예제에서는 함수 앱의 기본 저장소 계정 연결 문자열 (`AzureWebJobsStorage`)에 대 한 앱 설정을 가져옵니다. [Storageaccountattribute](https://github.com/Azure/azure-webjobs-sdk/blob/master/src/Microsoft.Azure.WebJobs/StorageAccountAttribute.cs) 를 추가 하 고 특성 배열을 `BindAsync<T>()`에 전달 하 여 저장소 계정에 사용할 사용자 지정 앱 설정을 지정할 수 있습니다. `IBinder`아닌 `Binder` 매개 변수를 사용 합니다.  Példa:

```cs
public static class IBinderExampleMultipleAttributes
{
    [FunctionName("CreateBlobInDifferentStorageAccount")]
    public async static Task RunAsync(
            [QueueTrigger("myqueue-items-source-binder2")] string myQueueItem,
            Binder binder,
            ILogger log)
    {
        log.LogInformation($"CreateBlobInDifferentStorageAccount function processed: {myQueueItem}");
        var attributes = new Attribute[]
        {
        new BlobAttribute($"samples-output/{myQueueItem}", FileAccess.Write),
        new StorageAccountAttribute("MyStorageAccount")
        };
        using (var writer = await binder.BindAsync<TextWriter>(attributes))
        {
            await writer.WriteAsync("Hello World!!");
        }
    }
}
```

## <a name="triggers-and-bindings"></a>Eseményindítók és kötések 

[!INCLUDE [Supported triggers and bindings](../../includes/functions-bindings.md)]

## <a name="next-steps"></a>Következő lépések

> [!div class="nextstepaction"]
> [트리거 및 바인딩에 대 한 자세한 정보](functions-triggers-bindings.md)

> [!div class="nextstepaction"]
> [모범 사례에 대 한 자세한 정보 Azure Functions](functions-best-practices.md)
