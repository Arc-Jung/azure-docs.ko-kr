---
title: Azure SignalR Service를 위한 성능 가이드
description: Azure SignalR 서비스의 성능 및 벤치마크개요입니다. 용량을 계획할 때 고려해야 할 주요 메트릭입니다.
author: sffamily
ms.service: signalr
ms.topic: conceptual
ms.date: 11/13/2019
ms.author: zhshang
ms.openlocfilehash: 68cad32be177fa20794399157fca89e87c2f8f59
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/27/2020
ms.locfileid: "74157676"
---
# <a name="performance-guide-for-azure-signalr-service"></a>Azure SignalR Service를 위한 성능 가이드

Azure SignalR 서비스를 사용할 때의 주요 이점 중 하나는 SignalR 응용 프로그램의 확장이 용이하다는 것입니다. 대규모 시나리오에서는 성능이 중요한 요소입니다. 

이 가이드에서는 SignalR 응용 프로그램 성능에 영향을 주는 요소를 소개합니다. 다양한 사용 사례 시나리오에서 일반적인 성능을 설명합니다. 결국 성능 보고서를 생성하는 데 사용할 수 있는 환경과 도구를 소개합니다.

## <a name="term-definitions"></a>용어 정의

*인바운드*: Azure SignalR 서비스에 들어오는 메시지입니다.

*아웃바운드*: Azure SignalR 서비스의 나가는 메시지입니다.

*대역폭*: 1초 안에 모든 메시지의 총 크기입니다.

*기본 모드*: Azure SignalR 서비스 인스턴스가 생성될 때기본 작업 모드입니다. Azure SignalR 서비스는 앱 서버가 클라이언트 연결을 수락하기 전에 앱 서버와 연결을 설정하도록 예상합니다.

*서버리스 모드*: Azure SignalR 서비스가 클라이언트 연결만 허용하는 모드입니다. 서버 연결이 허용되지 않습니다.

## <a name="overview"></a>개요

Azure SignalR 서비스는 서로 다른 성능 용량에 대해 7개의 표준 계층을 정의합니다. 이 가이드는 다음 질문에 답합니다.

-   각 계층의 일반적인 Azure SignalR 서비스 성능은 무엇입니까?

-   Azure SignalR 서비스가 메시지 처리량에 대한 요구 사항(예: 초당 100,000개의 메시지 전송)을 충족합니까?

-   특정 시나리오의 경우 어떤 계층이 나에게 적합한가요? 또는 적절한 티어를 선택하면 어떻게 해야 하나요?

-   어떤 종류의 앱 서버(VM 크기)가 나에게 적합합니까? 얼마나 많은 배포를 해야 합니까?

이러한 질문에 대답하기 위해 이 가이드에서는 먼저 성능에 영향을 미치는 요인에 대한 높은 수준의 설명을 제공합니다. 그런 다음 **에코,** **브로드캐스트,** **그룹으로 보내기**및 **연결(피어** 투 피어 채팅)으로 보내는 일반적인 사용 사례에 대한 모든 계층의 최대 인바운드 및 아웃바운드 메시지를 보여 줍니다.

이 가이드에서는 모든 시나리오(및 다양한 사용 사례, 메시지 크기, 메시지 전송 패턴 등)를 다룰 수 없습니다. 그러나 다음과 같은 몇 가지 방법을 제공합니다.

- 인바운드 또는 아웃바운드 메시지에 대한 대략적인 요구 사항을 평가합니다.
- 성능 테이블을 확인하여 적절한 계층을 찾습니다.

## <a name="performance-insight"></a>성능 통찰력

이 섹션에서는 성능 평가 방법론에 대해 설명한 다음 성능에 영향을 주는 모든 요소를 나열합니다. 결국 성능 요구 사항을 평가하는 데 도움이 되는 메서드를 제공합니다.

### <a name="methodology"></a>방법

*처리량과* *대기 시간은* 성능 검사의 두 가지 일반적인 측면입니다. Azure SignalR 서비스의 경우 각 SKU 계층에는 자체 처리량 제한 정책이 있습니다. 이 정책은 메시지의 99%가 1초 미만의 대기 시간이 있을 때 *허용되는 최대 처리량(인바운드 및 아웃바운드 대역폭)을* 최대 달성 처리량으로 정의합니다.

대기 시간은 Azure SignalR 서비스에서 응답 메시지를 수신하는 연결에서 메시지를 보내는 시간 범위입니다. 예를 들어 **에코를** 살펴보겠습니다. 모든 클라이언트 연결은 메시지에 타임스탬프를 추가합니다. 앱 서버의 허브는 원래 메시지를 클라이언트로 다시 보냅니다. 따라서 전파 지연은 모든 클라이언트 연결에 의해 쉽게 계산됩니다. 타임스탬프는 **브로드캐스트의**모든 메시지에 대해 첨부되고, **그룹으로 보내고,** **연결로 보냅니다.**

수천 개의 동시 클라이언트 연결을 시뮬레이션하기 위해 Azure의 가상 사설망에서 여러 VM이 만들어집니다. 이러한 모든 VM은 동일한 Azure SignalR 서비스 인스턴스에 연결됩니다.

Azure SignalR 서비스의 기본 모드에서 앱 서버 VM은 클라이언트 VM과 동일한 가상 사설망에 배포됩니다. 모든 클라이언트 VM 및 앱 서버 VM은 지역 간 대기 시간을 피하기 위해 동일한 지역의 동일한 네트워크에 배포됩니다.

### <a name="performance-factors"></a>성능 요인

이론적으로 Azure SignalR 서비스 용량은 CPU, 메모리 및 네트워크와 같은 계산 리소스에 의해 제한됩니다. 예를 들어 Azure SignalR 서비스에 대한 연결이 많을수록 서비스가 더 많은 메모리를 사용합니다. 더 큰 메시지 트래픽(예: 모든 메시지가 2,048바이트보다 큰 경우)의 경우 Azure SignalR Service는 트래픽을 처리하기 위해 더 많은 CPU 주기를 소비해야 합니다. 한편 Azure 네트워크 대역폭은 최대 트래픽에 대한 제한도 적용합니다.

전송 유형은 성능에 영향을 주는 또 다른 요소입니다. 세 가지 유형은 [WebSocket,](https://en.wikipedia.org/wiki/WebSocket) [서버 전송 이벤트](https://en.wikipedia.org/wiki/Server-sent_events)및 긴 [폴링입니다.](https://en.wikipedia.org/wiki/Push_technology) 

WebSocket은 단일 TCP 연결을 통해 양방향 및 전이중 통신 프로토콜입니다. 서버 전송-이벤트는 서버에서 클라이언트로 메시지를 푸시하는 단방향 프로토콜입니다. 긴 폴링은 클라이언트가 HTTP 요청을 통해 서버의 정보를 주기적으로 폴링하도록 요구합니다. 동일한 조건에서 동일한 API의 경우 WebSocket의 성능이 가장 우수하고 서버 전송 이벤트가 느리며 긴 폴링이 가장 느립니다. Azure SignalR 서비스는 기본적으로 WebSocket을 권장합니다.

메시지 라우팅 비용도 성능이 제한됩니다. Azure SignalR 서비스는 클라이언트 또는 서버 집합에서 다른 클라이언트 또는 서버로 메시지를 라우팅하는 메시지 라우터 역할을 합니다. 다른 시나리오 또는 API에는 다른 라우팅 정책이 필요합니다. 

**에코의**경우 클라이언트는 메시지를 자체적으로 보내고 라우팅 대상도 그 자체입니다. 이 패턴은 라우팅 비용이 가장 낮습니다. 그러나 **브로드캐스트의**경우 **그룹으로 보내고** **연결로 보내려면**Azure SignalR Service는 내부 분산 데이터 구조를 통해 대상 연결을 조회해야 합니다. 이 추가 처리는 더 많은 CPU, 메모리 및 네트워크 대역폭을 사용합니다. 따라서 성능이 느려집니다.

기본 모드에서앱 서버는 특정 시나리오의 병목 현상이 될 수도 있습니다. Azure SignalR SDK는 허브를 호출해야 하며 하트비트 신호를 통해 모든 클라이언트와 실시간 연결을 유지합니다.

서버리스 모드에서 클라이언트는 WEBSocket만큼 효율적이지 않은 HTTP 게시물로 메시지를 보냅니다.

또 다른 요소는 프로토콜: JSON 및 [MessagePack](https://msgpack.org/index.html). 메시지 팩의 크기가 작으며 JSON보다 빠르게 전달됩니다. 하지만 MessagePack성능이 향상되지 않을 수 있습니다. Azure SignalR 서비스의 성능은 클라이언트에서 서버로 메시지를 전달하는 동안 메시지 페이로드를 디코딩하지 않거나 그 반대의 경우도 마찬가지이므로 프로토콜에 중요하지 않습니다.

요약하면, 다음 요소는 인바운드 및 아웃바운드 용량에 영향을 미칩니다.

-   SKU 계층(CPU/메모리)

-   연결 수

-   메시지 크기

-   메시지 전송 속도

-   전송 유형(웹소켓, 서버 전송 이벤트 또는 긴 폴링)

-   사용 사례 시나리오(라우팅 비용)

-   앱 서버 및 서비스 연결(서버 모드)


### <a name="finding-a-proper-sku"></a>적절한 SKU 찾기

인바운드/아웃바운드 용량을 평가하거나 특정 사용 사례에 적합한 계층을 찾으려면 어떻게 해야 합니까?

앱 서버가 충분히 강력하며 성능 병목 현상이 아니라고 가정합니다. 그런 다음 모든 계층의 최대 인바운드 및 아웃바운드 대역폭을 확인합니다.

#### <a name="quick-evaluation"></a>빠른 평가

먼저 몇 가지 기본 설정을 가정하여 평가를 단순화해 보겠습니다. 

- 전송 유형은 WebSocket입니다.
- 메시지 크기는 2,048바이트입니다.
- 메시지는 1초마다 전송됩니다.
- Azure SignalR 서비스가 기본 모드에 있습니다.

모든 계층에는 고유한 최대 인바운드 대역폭과 아웃바운드 대역폭이 있습니다. 인바운드 또는 아웃바운드 연결이 제한을 초과한 후에는 원활한 사용자 환경이 보장되지 않습니다.

**Echo는** 라우팅 비용이 가장 낮기 때문에 최대 인바운드 대역폭을 제공합니다. **브로드캐스트는** 최대 아웃바운드 메시지 대역폭을 정의합니다.

다음 두 테이블에서 강조 표시된 값을 *초과하지* 마십시오.

|       Echo                        | 단위 1 | 단위 2 | 유닛 5 | 단위 10 | 단위 20 | 단위 50 | 단위 100 |
|-----------------------------------|-------|-------|-------|--------|--------|--------|---------|
| Connections                       | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| **인바운드 대역폭** | **2MBps**    | **4MBps**    | **10MBps**   | **20MBps**    | **40MBps**    | **100mbps**   | **200MBps**    |
| 아웃바운드 대역폭 | 2MBps   | 4MBps   | 10MBps  | 20MBps   | 40MBps   | 100mbps  | 200MBps   |


|     Broadcast             | 단위 1 | 단위 2 | 유닛 5  | 단위 10 | 단위 20 | 단위 50  | 단위 100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| Connections               | 1,000 | 2,000 | 5,000  | 10000 | 20,000 | 50,000  | 100,000 |
| 인바운드 대역폭  | 4KBps   | 4KBps   | 4KBps    | 4KBps    | 4KBps    | 4KBps     | 4KBps    |
| **아웃바운드 대역폭** | **4MBps**    | **8MBps**    | **20MBps**    | **40MBps**    | **80MBps**    | **200MBps**    | **400MBps**   |

*인바운드 대역폭과* *아웃바운드 대역폭은* 초당 총 메시지 크기입니다.  여기에 그들에 대한 수식은 다음과 같습니다
```
  inboundBandwidth = inboundConnections * messageSize / sendInterval
  outboundBandwidth = outboundConnections * messageSize / sendInterval
```

- *인바운드연결*: 메시지를 보내는 연결 수입니다.

- *아웃바운드연결*: 메시지를 수신하는 연결 수입니다.

- *messageSize*: 단일 메시지의 크기(평균 값)입니다. 1,024바이트 미만의 작은 메시지는 1,024바이트 메시지와 유사한 성능 에 영향을 미칩니다.

- *sendInterval*: 하나의 메시지를 보내는 시간입니다. 일반적으로 메시지당 1초이며, 이는 매초마다 하나의 메시지를 보내는 것을 의미합니다. 간격이 작을수록 기간 동안 더 많은 메시지를 보내는 것을 의미합니다. 예를 들어 메시지당 0.5초는 매초 두 개의 메시지를 보내는 것을 의미합니다.

- *연결*: 모든 계층에 대해 Azure SignalR 서비스에 대해 커밋된 최대 임계값입니다. 연결 번호가 더 늘어나면 연결 제한이 저하됩니다.

#### <a name="evaluation-for-complex-use-cases"></a>복잡한 사용 사례에 대한 평가

##### <a name="bigger-message-size-or-different-sending-rate"></a>더 큰 메시지 크기 또는 다른 전송 속도

실제 사용 사례는 더 복잡합니다. 2,048바이트보다 큰 메시지를 보내거나 송신 메시지 속도가 초당 하나의 메시지가 아닐 수 있습니다. Unit100의 브로드캐스트를 예로 들어 성능을 평가하는 방법을 살펴보겠습니다.

다음 표에서는 **브로드캐스트의**실제 사용 사례를 보여 주실 수 있습니다. 그러나 메시지 크기, 연결 수 및 메시지 전송 속도는 이전 섹션에서 가정한 것과 다릅니다. 문제는 우리가 그 중 두 가지를 알고있는 경우 이러한 항목 (메시지 크기, 연결 수 또는 메시지 전송 속도)를 추론 할 수있는 방법입니다.

| Broadcast  | 메시지 크기 | 초당 인바운드 메시지 | Connections | 간격 보내기 |
|---|---------------------|--------------------------|-------------|-------------------------|
| 1 | 20 KB                | 1                        | 100,000     | 5초                      |
| 2 | 256 KB               | 1                        | 8,000       | 5초                      |

다음 수식은 이전 수식을 기반으로 쉽게 추론할 수 있습니다.

```
outboundConnections = outboundBandwidth * sendInterval / messageSize
```

Unit100의 경우 최대 아웃바운드 대역폭은 이전 테이블의 400MB입니다. 20KB 메시지 크기의 경우 최대 아웃바운드 연결은 실제 \* 값과 일치하는 400MB 5/20KB = 100,000이어야 합니다.

##### <a name="mixed-use-cases"></a>혼합 사용 사례

실제 사용 사례는 일반적으로 **에코,** **브로드캐스트,** 그룹 **보내기**및 **연결로 보내는**네 가지 기본 사용 사례를 함께 혼합합니다. 용량을 평가하는 데 사용하는 방법은 다음과 같은 것입니다.

1. 혼합 사용 사례를 네 가지 기본 사용 사례로 나눕니다.
1. 앞의 수식을 별도로 사용하여 최대 인바운드 및 아웃바운드 메시지 대역폭을 계산합니다.
1. 대역폭 계산을 합산하여 총 최대 인바운드/아웃바운드 대역폭을 가져옵니다. 

그런 다음 최대 인바운드/아웃바운드 대역폭 테이블에서 적절한 계층을 선택합니다.

> [!NOTE]
> 수백 또는 수천 개의 소규모 그룹에 메시지를 보내거나 수천 명의 클라이언트가 서로 메시지를 보내는 경우 라우팅 비용이 지배적입니다. 이러한 영향을 고려하십시오.

클라이언트에 메시지를 보내는 경우 앱 서버가 병목 현상이 *아닌지* 확인합니다. 다음 "사례 연구" 섹션에서는 필요한 앱 서버 수와 구성해야 하는 서버 연결 수에 대한 지침을 제공합니다.

## <a name="case-study"></a>사례 연구

다음 섹션에서는 WebSocket 전송에 대한 네 가지 일반적인 사용 사례인 **에코,** **브로드캐스트,** **그룹으로 보내기**및 **연결로 전송합니다.** 각 시나리오에 대해 섹션에는 Azure SignalR 서비스의 현재 인바운드 및 아웃바운드 용량이 나열됩니다. 또한 성능에 영향을 미치는 주요 요소에 대해서도 설명합니다.

기본 모드에서 앱 서버는 Azure SignalR 서비스를 통해 5개의 서버 연결을 만듭니다. 앱 서버는 기본적으로 Azure SignalR 서비스 SDK를 사용합니다. 다음 성능 테스트 결과에서는 서버 연결이 15로 증가합니다(큰 그룹에 메시지를 브로드캐스트하고 보내는 경우).

사용 사례마다 앱 서버에 대한 요구 사항이 다릅니다. **브로드캐스트에는** 적은 수의 앱 서버가 필요합니다. **에코** 또는 **연결에 전송많은** 응용 프로그램 서버가 필요합니다.

모든 사용 사례에서 기본 메시지 크기는 2,048바이트이고 메시지 전송 간격은 1초입니다.

### <a name="default-mode"></a>기본 모드

클라이언트, 웹 앱 서버 및 Azure SignalR 서비스가 기본 모드에 포함됩니다. 모든 클라이언트는 단일 연결을 의미합니다.

#### <a name="echo"></a>Echo

먼저 웹 앱이 Azure SignalR 서비스에 연결됩니다. 둘째, 많은 클라이언트가 웹 앱에 연결하여 액세스 토큰 및 끝점을 사용하여 클라이언트를 Azure SignalR 서비스로 리디렉션합니다. 그런 다음 클라이언트는 Azure SignalR 서비스를 사용하여 WebSocket 연결을 설정합니다.

모든 클라이언트가 연결을 설정하면 매초 특정 허브에 타임스탬프가 포함된 메시지를 보내기 시작합니다. 허브는 메시지를 원래 클라이언트에 다시 에코합니다. 모든 클라이언트는 에코 메시지를 다시 받을 때 대기 시간을 계산합니다.

다음 다이어그램에서 5~8(빨간색 강조 표시된 트래픽)은 루프에 있습니다. 루프는 기본 기간(5분)동안 실행되며 모든 메시지 대기 시간의 통계를 가져옵니다.

![에코 사용 사례의 트래픽](./media/signalr-concept-performance/echo.png)

**에코의** 동작은 최대 인바운드 대역폭이 최대 아웃바운드 대역폭과 같다고 결정합니다. 자세한 내용은 아래 표를 참조하세요.

|       Echo                        | 단위 1 | 단위 2 | 유닛 5 | 단위 10 | 단위 20 | 단위 50 | 단위 100 |
|-----------------------------------|-------|-------|-------|--------|--------|--------|---------|
| Connections                       | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 초당 인바운드/아웃바운드 메시지 | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 인바운드/아웃바운드 대역폭 | 2MBps   | 4MBps   | 10MBps  | 20MBps   | 40MBps   | 100mbps  | 200MBps   |

이 사용 사례에서 모든 클라이언트는 앱 서버에 정의된 허브를 호출합니다. 허브는 원래 클라이언트 측에 정의된 메서드를 호출합니다. 이 허브는 **에코에**대한 가장 가벼운 허브입니다.

```
        public void Echo(IDictionary<string, object> data)
        {
            Clients.Client(Context.ConnectionId).SendAsync("RecordLatency", data);
        }
```

이 간단한 허브의 경우에도 **에코** 인바운드 메시지 로드가 증가함에 따라 앱 서버의 트래픽 압력이 두드러집니다. 이러한 트래픽 압박으로는 대규모 SKU 계층에 대해 많은 앱 서버가 필요합니다. 다음 표에는 모든 계층에 대한 앱 서버 수가 나열되어 있습니다.


|    Echo          | 단위 1 | 단위 2 | 유닛 5 | 단위 10 | 단위 20 | 단위 50 | 단위 100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| Connections      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 3      | 3      | 10     | 20      |

> [!NOTE]
> 앱 서버의 클라이언트 연결 번호, 메시지 크기, 메시지 전송 속도, SKU 계층 및 CPU/메모리는 **에코의**전반적인 성능에 영향을 미칩니다.

#### <a name="broadcast"></a>Broadcast

**브로드캐스트의**경우 웹 앱이 메시지를 수신하면 모든 클라이언트에 브로드캐스트됩니다. 브로드캐스트할 클라이언트가 많을수록 모든 클라이언트에 더 많은 메시지 트래픽이 있습니다. 다음 다이어그램을 참조하세요.

![방송 사용 사례의 트래픽](./media/signalr-concept-performance/broadcast.png)

소수의 클라이언트가 방송하고 있습니다. 인바운드 메시지 대역폭은 작지만 아웃바운드 대역폭은 엄청납니다. 클라이언트 연결 또는 브로드캐스트 속도가 증가함에 따라 아웃바운드 메시지 대역폭이 증가합니다.

다음 표에는 최대 클라이언트 연결, 인바운드/아웃바운드 메시지 수 및 대역폭이 요약되어 있습니다.

|     Broadcast             | 단위 1 | 단위 2 | 유닛 5  | 단위 10 | 단위 20 | 단위 50  | 단위 100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| Connections               | 1,000 | 2,000 | 5,000  | 10000 | 20,000 | 50,000  | 100,000 |
| 초당 인바운드 메시지  | 2     | 2     | 2      | 2      | 2      | 2       | 2       |
| 초당 아웃바운드 메시지 | 2,000 | 4,000 | 10000 | 20,000 | 40,000 | 100,000 | 200,000 |
| 인바운드 대역폭  | 4KBps   | 4KBps   | 4KBps    | 4KBps    | 4KBps    | 4KBps     | 4KBps     |
| 아웃바운드 대역폭 | 4MBps   | 8MBps   | 20MBps   | 40MBps   | 80MBps   | 200MBps   | 400MBps   |

메시지를 게시하는 브로드캐스팅 클라이언트는 4개 이하입니다. 인바운드 메시지 양이 적기 때문에 **에코에** 비해 앱 서버수가 줄어듭니다. 두 개의 앱 서버는 SLA 및 성능 고려 사항에 모두 적합합니다. 그러나 특히 Unit50 및 Unit100의 경우 불균형을 방지하려면 기본 서버 연결을 늘려야 합니다.

|   Broadcast      | 단위 1 | 단위 2 | 유닛 5 | 단위 10 | 단위 20 | 단위 50 | 단위 100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| Connections      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 2      | 2      | 2      | 2       |

> [!NOTE]
> Azure SignalR 서비스에 대한 불균형 서버 연결을 방지하려면 모든 앱 서버에서 기본 서버 연결을 5개에서 40으로 늘립니다.
>
> 클라이언트 연결 번호, 메시지 크기, 메시지 전송 속도 및 SKU 계층은 **브로드캐스트의**전반적인 성능에 영향을 미칩니다.

#### <a name="send-to-group"></a>그룹에 보내기

그룹 사용 **사례로 보내는 경우** **브로드캐스트할**트래픽 패턴이 비슷합니다. 차이점은 클라이언트가 Azure SignalR Service를 사용하여 WebSocket 연결을 설정한 후 특정 그룹에 메시지를 보내기 전에 그룹에 가입해야 한다는 점입니다. 다음 다이어그램은 트래픽 흐름을 보여 줍니다.

![그룹 간 송신 사용 사례에 대한 트래픽](./media/signalr-concept-performance/sendtogroup.png)

그룹 구성원 및 그룹 수는 성능에 영향을 주는 두 가지 요소입니다. 분석을 단순화하기 위해 두 가지 종류의 그룹을 정의합니다.

- **소그룹**: 모든 그룹에는 10개의 연결이 있습니다. 그룹 번호는 (최대 연결 수) / 10과 같습니다. 예를 들어 Unit1의 경우 연결 수가 1,000인 경우 1000/10 = 100개의 그룹이 있습니다.

- **빅그룹**: 그룹 번호는 항상 10입니다. 그룹 구성원 수는 (최대 연결 수) / 10과 같습니다. 예를 들어 Unit1의 경우 연결 수가 1,000인 경우 모든 그룹에는 1000/10 = 100멤버가 있습니다.

**그룹에 보내기는** 분산 데이터 구조를 통해 대상 연결을 찾아야 하기 때문에 Azure SignalR 서비스에 라우팅 비용을 제공합니다. 송신 연결이 증가하면 비용이 증가합니다.

##### <a name="small-group"></a>소그룹

라우팅 비용은 많은 소규모 그룹에 메시지를 보내는 데 중요합니다. 현재 Azure SignalR 서비스 구현은 Unit50에서 라우팅 비용 제한에 도달하면 됩니다. CPU와 메모리를 더 추가하는 것은 도움이 되지 않으므로 Unit100은 의도적으로 더 개선할 수 없습니다. 더 많은 인바운드 대역폭이 필요한 경우 고객 지원에 문의하십시오.

|   소그룹으로 보내기     | 단위 1 | 단위 2 | 유닛 5  | 단위 10 | 단위 20 | 단위 50 | 단위 100 |
|---------------------------|-------|-------|--------|--------|--------|--------|---------|
| Connections               | 1,000 | 2,000 | 5,000  | 10000 | 20,000 | 50,000 | 100,000
| 그룹 구성원 수        | 10    | 10    | 10     | 10     | 10     | 10     | 10 
| 그룹 수               | 100   | 200   | 500    | 1,000  | 2,000  | 5,000  | 10000 
| 초당 인바운드 메시지  | 200   | 400   | 1,000  | 2,500  | 4,000  | 7,000  | 7,000   |
| 인바운드 대역폭  | 400KBps  | 800KBps  | 2MBps     | 5MBps     | 8MBps     | 14MBps    | 14MBps     |
| 초당 아웃바운드 메시지 | 2,000 | 4,000 | 10000 | 25,000 | 40,000 | 70,000 | 70,000  |
| 아웃바운드 대역폭 | 4MBps    | 8MBps    | 20MBps    | 50MBps     | 80MBps    | 140MBps   | 140MBps    |

많은 클라이언트 연결이 허브를 호출하므로 앱 서버 번호도 성능에 매우 중요합니다. 다음 표에는 제안된 앱 서버 수가 나열되어 있습니다.

|  소그룹으로 보내기   | 단위 1 | 단위 2 | 유닛 5 | 단위 10 | 단위 20 | 단위 50 | 단위 100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| Connections      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 3      | 3      | 10     | 20      |

> [!NOTE]
> 클라이언트 연결 번호, 메시지 크기, 메시지 전송 속도, 라우팅 비용, SKU 계층 및 앱 서버의 CPU/메모리는 소규모 그룹으로 보내는 전체 **성능에**영향을 미칩니다.

##### <a name="big-group"></a>큰 그룹

**큰 그룹에 보낼**때 아웃바운드 대역폭은 라우팅 비용 제한에 도달하면 병목 현상이 됩니다. 다음 표에는 **브로드캐스트의**최대 아웃바운드 대역폭과 거의 동일합니다.

|    큰 그룹에 보내기      | 단위 1 | 단위 2 | 유닛 5  | 단위 10 | 단위 20 | 단위 50  | 단위 100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| Connections               | 1,000 | 2,000 | 5,000  | 10000 | 20,000 | 50,000  | 100,000
| 그룹 구성원 수        | 100   | 200   | 500    | 1,000  | 2,000  | 5,000   | 10000 
| 그룹 수               | 10    | 10    | 10     | 10     | 10     | 10      | 10
| 초당 인바운드 메시지  | 20    | 20    | 20     | 20     | 20     | 20      | 20      |
| 인바운드 대역폭  | 80KBps   | 40KBps   | 40KBps    | 20 KBps    | 40KBps    | 40KBps     | 40KBps     |
| 초당 아웃바운드 메시지 | 2,000 | 4,000 | 10000 | 20,000 | 40,000 | 100,000 | 200,000 |
| 아웃바운드 대역폭 | 8MBps    | 8MBps    | 20MBps    | 40MBps    | 80MBps    | 200MBps    | 400MBps    |

전송 연결 수는 40을 넘지 않습니다. 앱 서버의 부담이 적기 때문에 제안된 웹 앱 수가 적습니다.

|  큰 그룹에 보내기  | 단위 1 | 단위 2 | 유닛 5 | 단위 10 | 단위 20 | 단위 50 | 단위 100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| Connections      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 2      | 2      | 2      | 2       |

> [!NOTE]
> Azure SignalR 서비스에 대한 불균형 서버 연결을 방지하려면 모든 앱 서버에서 기본 서버 연결을 5개에서 40으로 늘립니다.
> 
> 클라이언트 연결 번호, 메시지 크기, 메시지 전송 속도, 라우팅 비용 및 SKU 계층은 큰 그룹에 보내는 전체 **성능에**영향을 미칩니다.

#### <a name="send-to-connection"></a>연결로 보내기

연결 사용 **사례로 보내는** 경우 클라이언트가 Azure SignalR 서비스에 대한 연결을 설정할 때 모든 클라이언트는 고유한 연결 ID를 얻기 위해 특수 허브를 호출합니다. 성능 벤치마크는 모든 연결 아이디를 수집하고 섞은 다음 모든 클라이언트에 송신 대상으로 다시 할당합니다. 클라이언트는 성능 테스트가 완료될 때까지 대상 연결로 메시지를 계속 보냅니다.

![송신-클라이언트 사용 사례에 대한 트래픽](./media/signalr-concept-performance/sendtoclient.png)

**연결로 보내는** 라우팅 비용은 **소규모 그룹에 보내는**비용과 유사합니다.

연결 수가 증가하면 라우팅 비용이 전체 성능을 제한합니다. Unit50이 한도에 도달했습니다. 결과적으로 Unit100은 더 이상 개선할 수 없습니다.

다음 표는 연결 벤치마크로 보내기를 실행하는 여러 라운드 후에 통계 **요약입니다.**

|   연결로 보내기   | 단위 1 | 단위 2 | 유닛 5 | 단위 10 | 단위 20 | 단위 50          | 단위 100         |
|------------------------------------|-------|-------|-------|--------|--------|-----------------|-----------------|
| Connections                        | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000          | 100,000         |
| 초당 인바운드/아웃바운드 메시지 | 1,000 | 2,000 | 5,000 | 8,000  | 9,000  | 20,000 | 20,000 |
| 인바운드/아웃바운드 대역폭 | 2MBps    | 4MBps    | 10MBps   | 16MBps    | 18MBps    | 40MBps       | 40MBps       |

이 사용 사례는 앱 서버 측에 높은 부하가 필요합니다. 다음 표에서 제안된 앱 서버 수를 참조하십시오.

|  연결로 보내기  | 단위 1 | 단위 2 | 유닛 5 | 단위 10 | 단위 20 | 단위 50 | 단위 100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| Connections      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 3      | 3      | 10     | 20      |

> [!NOTE]
> 앱 서버의 클라이언트 연결 번호, 메시지 크기, 메시지 전송 속도, 라우팅 비용, SKU 계층 및 CPU/메모리는 **연결로 보내는**전체 성능에 영향을 미칩니다.

#### <a name="aspnet-signalr-echo-broadcast-and-send-to-small-group"></a>ASP.NET SignalR 에코, 방송 및 소그룹으로 전송

Azure SignalR 서비스는 ASP.NET SignalR에 대해 동일한 성능 용량을 제공합니다. 

성능 테스트에서는 ASP.NET SignalR에 표준 [서비스 계획 S3의](https://azure.microsoft.com/pricing/details/app-service/windows/) Azure 웹 앱을 사용합니다.

다음 표는 ASP.NET SignalR **에코에**대한 제안된 웹 앱 수를 제공합니다.

|   Echo           | 단위 1 | 단위 2 | 유닛 5 | 단위 10 | 단위 20 | 단위 50 | 단위 100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| Connections      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 4     | 4      | 8      | 32      | 40       |

다음 표에서는 signalR **브로드캐스트에**대해 제안된 웹 앱 수를 ASP.NET.

|  Broadcast       | 단위 1 | 단위 2 | 유닛 5 | 단위 10 | 단위 20 | 단위 50 | 단위 100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| Connections      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 2      | 2      | 2      | 2       |

다음 표는 SignalR이 **소규모 그룹에 보내는**ASP.NET 대한 제안된 웹 앱 수를 제공합니다.

|  소그룹으로 보내기     | 단위 1 | 단위 2 | 유닛 5 | 단위 10 | 단위 20 | 단위 50 | 단위 100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| Connections      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 4     | 4      | 8      | 32      | 40       |

### <a name="serverless-mode"></a>서버리스 모드

클라이언트와 Azure SignalR 서비스는 서버리스 모드에 참여합니다. 모든 클라이언트는 단일 연결을 의미합니다. 클라이언트는 REST API를 통해 다른 클라이언트로 메시지를 보내거나 모두에게 메시지를 브로드캐스트합니다.

REST API를 통해 고밀도 메시지를 보내는 것은 WebSocket을 사용하는 것만큼 효율적이지 않습니다. 매번 새 HTTP 연결을 빌드해야 하며 서버리스 모드에서는 추가 비용이 듭니다.

#### <a name="broadcast-through-rest-api"></a>REST API를 통한 브로드캐스트
모든 클라이언트는 Azure SignalR 서비스를 사용하여 WebSocket 연결을 설정합니다. 그런 다음 일부 클라이언트는 REST API를 통해 브로드캐스트를 시작합니다. 메시지 전송(인바운드)은 모두 HTTP Post를 통해 전송되며 WebSocket과 비교할 때 효율적이지 않습니다.

|   REST API를 통한 브로드캐스트     | 단위 1 | 단위 2 | 유닛 5  | 단위 10 | 단위 20 | 단위 50  | 단위 100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| Connections               | 1,000 | 2,000 | 5,000  | 10000 | 20,000 | 50,000  | 100,000 |
| 초당 인바운드 메시지  | 2     | 2     | 2      | 2      | 2      | 2       | 2       |
| 초당 아웃바운드 메시지 | 2,000 | 4,000 | 10000 | 20,000 | 40,000 | 100,000 | 200,000 |
| 인바운드 대역폭  | 4KBps    | 4KBps    | 4KBps     | 4KBps     | 4KBps     | 4KBps      | 4KBps      |
| 아웃바운드 대역폭 | 4MBps    | 8MBps    | 20MBps    | 40MBps    | 80MBps    | 200MBps    | 400MBps    |

#### <a name="send-to-user-through-rest-api"></a>REST API를 통해 사용자에게 보내기
벤치마크는 Azure SignalR 서비스에 연결하기 전에 모든 클라이언트에 사용자 이름을 할당합니다. 클라이언트가 Azure SignalR Service로 WebSocket 연결을 설정하면 HTTP Post를 통해 다른 사람에게 메시지를 보내기 시작합니다.

|   REST API를 통해 사용자에게 보내기 | 단위 1 | 단위 2 | 유닛 5  | 단위 10 | 단위 20 | 단위 50  | 단위 100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| Connections               | 1,000 | 2,000 | 5,000  | 10000 | 20,000 | 50,000  | 100,000 |
| 초당 인바운드 메시지  | 300   | 600   | 900    | 1,300  | 2,000  | 10000  | 18,000  |
| 초당 아웃바운드 메시지 | 300   | 600   | 900    | 1,300  | 2,000  | 10000  | 18,000 |
| 인바운드 대역폭  | 600KBps  | 1.2MBps  | 1.8MBps   | 2.6MBps   | 4MBps     | 10MBps     | 36MBps    |
| 아웃바운드 대역폭 | 600KBps  | 1.2MBps  | 1.8MBps   | 2.6MBps   | 4MBps     | 10MBps     | 36MBps    |

## <a name="performance-test-environments"></a>성능 테스트 환경

앞에서 나열한 모든 사용 사례에 대해 Azure 환경에서 성능 테스트를 수행했습니다. 대부분의 경우 50개의 클라이언트 VM과 20개의 앱 서버 VM을 사용했습니다. 다음은 몇 가지 세부 정보입니다.

- 클라이언트 VM 크기: 표준DS2V2(2vCPU, 7G 메모리)

- 앱 서버 VM 크기: 표준F4sV2(4vCPU, 8G 메모리)

- Azure SignalR SDK 서버 연결: 15

## <a name="performance-tools"></a>성능 도구

[GitHub에서](https://github.com/Azure/azure-signalr-bench/)Azure SignalR 서비스에 대한 성능 도구를 찾을 수 있습니다.

## <a name="next-steps"></a>다음 단계

이 문서에서는 일반적인 사용 사례 시나리오에서 Azure SignalR 서비스 성능에 대한 개요를 얻었습니다.

서비스의 내부 및 확장에 대한 세부 정보를 얻으려면 다음 가이드를 읽으십시오.

* [Azure SignalR Service 내부 기능](signalr-concept-internals.md)
* [Azure 신호R 서비스 확장](signalr-howto-scale-multi-instances.md)
