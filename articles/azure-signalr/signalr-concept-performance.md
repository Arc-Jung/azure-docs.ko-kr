---
title: Azure SignalR Service에 대 한 성능 가이드
description: Azure SignalR Service의 성능 간략히 설명 합니다.
author: sffamily
ms.service: signalr
ms.topic: conceptual
ms.date: 04/08/2019
ms.author: zhshang
ms.openlocfilehash: 53139dd253c491ea6578fd0b9cbada4e7b331c7d
ms.sourcegitcommit: 1a19a5845ae5d9f5752b4c905a43bf959a60eb9d
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/11/2019
ms.locfileid: "59502040"
---
# <a name="performance-guide-for-azure-signalr-service"></a>Azure SignalR Service에 대 한 성능 가이드

Azure SignalR Service를 사용 하기 위한 주요 이점 중 하나는 SignalR 응용 프로그램을 확장할 간편 하 게입니다. 대규모 시나리오에서 성능이 중요 한 요인이 됩니다. 이 가이드의 일반적인 성능 이란 다양 한 사용 사례 시나리오에서 SignalR 응용 프로그램 성능에 영향을 주는 요소를 소개 합니다. 결과적으로 소개 합니다 환경 및 도구 성능 보고서를 생성 하는 데 사용 합니다.

## <a name="terms-definition"></a>용어 정의

*ASRS*: Azure SignalR Service

*인바운드*: Azure SignalR Service로 들어오는 메시지

*아웃 바운드*: Azure SignalR Service에서 보내는 메시지

*대역폭*: 1 초에서 모든 메시지의 크기를 합계

*기본 모드*: ASRS는 클라이언트 연결을 수락 하기 전에 연결 된 응용 프로그램 서버에 필요 합니다. ASRS 만들어질 때 기본 작업 모드입니다.

*서버 리스 모드*: ASRS는 클라이언트 연결만 허용 합니다. 서버 연결 없음 허용 됩니다.

## <a name="overview"></a>개요

ASRS 다른 성능 용량에 대 한 표준 계층 7를 정의 하 고이 가이드에서 다음 질문에 대답 하려고 합니다.

-   각 계층에 대 한 일반적인 ASRS 성능 이란?

-   ASRS 내 요구 사항에 맞지 메시지 처리량, 예를 들어, 초당 100,000 메시지를 보내는?

-   내 특정 시나리오의 경우 계층 내에 적합 한? 또는 적절 한 계층을 선택할 수는 어떻게?

-   앱 서버 (VM 크기)의 종류는 저에 적합 하며 얼마나 많은 다음을 배포 합니까?

이러한 질문에 답하기 위해이 성능 가이드 먼저 성능에 영향을 주는 요소에 대 한 대략적인 설명 다음 일반적인 사용 사례에 대 한 모든 계층에 대 한 최대 인바운드 및 아웃 바운드 메시지를 보여 줍니다. **echo**, **브로드캐스트**합니다 **그룹에 송신**, 및 **송신 연결** (피어 투 피어 채팅).

이 문서의 모든 시나리오 (및 다른 사용 사례, 다양 한 메시지 크기 또는 메시지 전송 패턴 등)를 포함 하는 것이 불가능 합니다. 그러나 약 인바운드 또는 아웃 바운드 메시지의 해당 요구 사항을 평가 하 고 성능 테이블을 확인 하 여 적절 한 계층을 찾을 수 있도록 몇 가지 평가 메서드를 제공 합니다.

## <a name="performance-insight"></a>성능 insight

이 섹션에서는 성능 평가 방법에 설명 합니다. 다음 성능에 영향을 주는 요소를 모두 나열 합니다. 결과적으로 성능 요구 사항을 평가 하는 데는 메서드를 제공 합니다.

### <a name="methodology"></a>방법

**처리량** 하 고 **대기 시간** 다음 두 가지 일반적인 성능 검사 합니다. ASRS를 다른 SKU 계층 정책 제한 하는 다양 한 처리량을 있습니다. 이 문서는 정의 **허용 되는 최대 처리량 (인바운드 및 아웃 바운드 대역폭)** 때 메시지의 99 %1 초 미만의 대기 시간이 최대 달성 된 처리량으로 합니다.

대기 시간은 ASRS에서 응답 메시지를 수신 하는 메시지를 보내는 연결의 시간 범위입니다. 살펴보겠습니다 **echo** 예를 들어 모든 클라이언트 연결이 메시지에 타임 스탬프를 추가 합니다. 앱 서버 허브 클라이언트에 다시 원래 메시지를 보냅니다. 따라서 전파 지연 모든 클라이언트 연결에서 쉽게 계산 됩니다. 모든 메시지에 대 한 연결 된 타임 스탬프 **브로드캐스트**를 **그룹에 송신**, 및 **송신 연결**합니다.

수천 개의 동시 클라이언트 연결을 시뮬레이트하기 위해 여러 Vm은 Azure에서 개인 가상 네트워크에 생성 됩니다. 이러한 Vm의 모든 동일한 ASRS 인스턴스에 연결 합니다.

ASRS 기본 모드에서 앱 서버 Vm도 클라이언트 Vm으로 동일한 가상 개인 네트워크에 배포 됩니다.

모든 클라이언트 Vm 및 앱 서버 Vm 간 지역 대기 시간을 방지 하려면 동일한 지역의 동일한 네트워크에 배포 됩니다.

### <a name="performance-factors"></a>성능 요인

이론적으로 ASRS 용량 계산 리소스에 의해 제한 됩니다. CPU, 메모리 및 네트워크를 선택 합니다. ASRS 연결할 자세한 예를 들어, 더 많은 메모리 ASRS 사용 합니다. 큰 메시지 트래픽에 대 한 모든 메시지는 2048 바이트 보다 큰 예를 들어도 처리 하는 데 더 많은 CPU 주기를 사용해 ASRS 필요 합니다. 한편 Azure 네트워크 대역폭은 최대 트래픽에 대 한 제한을 적용 합니다.

전송 유형을 [WebSocket](https://en.wikipedia.org/wiki/WebSocket), [서버 전송 이벤트](https://en.wikipedia.org/wiki/Server-sent_events), 또는 [긴 폴링](https://en.wikipedia.org/wiki/Push_technology), 다른 요소에 영향을 줍니다 성능입니다. WebSocket은 TCP 연결 하나를 통해 양방향 및 전체 이중 통신 프로토콜. 그러나 서버 전송 이벤트는 단방향 프로토콜 푸시 메시지를 서버에서 클라이언트로의입니다. 긴 폴링 클라이언트가 HTTP 요청을 통해 서버에서 정보를 정기적으로 폴링하여 필요 합니다. 동일한 조건에서 동일한 API에 대 한 WebSocket에 최상의 성능을, 서버 전송 이벤트는 느립니다 이며 긴 폴링 가장 느린 작업입니다. ASRS는 기본적으로 WebSocket을 권장합니다.

또한 메시지 라우팅 비용에는 또한 성능을 제한합니다. ASRS 다른 클라이언트 또는 서버에 클라이언트 또는 서버 집합에서 메시지를 라우팅하는 메시지 라우터 역할을 합니다. 다른 시나리오 또는 API에는 여러 라우팅 정책이 필요합니다. 에 대 한 **echo**, 클라이언트 자체에 메시지를 보냅니다 및 라우팅 대상 자체 이기도 합니다. 이 패턴에 가장 낮은 라우팅 비용. 대해서 **브로드캐스트**, **그룹에 송신**를 **송신 연결**, ASRS 분산된 된 내부 데이터 구조를 통해 대상 연결을 조회 해야 하는 더 많은 CPU, 메모리 및 네트워크 대역폭도 사용합니다. 결과적으로 성능이 더 느려지므로 **echo**합니다.

기본 모드에서 응용 프로그램 서버도 병목 현상이 발생할 수 특정 시나리오에 대 한 Azure SignalR SDK 하트 비트 신호를 통해 모든 클라이언트를 사용 하 여 라이브 연결 유지 관리 하는 한편 허브 호출 하기 때문입니다.

서버 리스 모드 클라이언트 WebSocket 만큼 효율적이 지 되지 않는 HTTP post로 메시지를 보냅니다.

또 다른 요소는 프로토콜: JSON 및 [MessagePack](https://msgpack.org/index.html)합니다. MessagePack은 JSON 보다 빠르게 크기가 작고 배달 됩니다. 직관적으로 MessagePack 성능에 도움이 되는 아닌 ASRS 성능 프로토콜을 사용 하 여 중요 한 이후 서버로 또는 그 반대로 클라이언트에서 메시지를 전달 하는 동안 메시지 페이로드 디코드 하지 않습니다.

요약 하면 다음 요소를 인바운드 및 아웃 바운드 용량에 영향을 미칩니다.

-   SKU 계층 (U/메모리)

-   연결 수

-   메시지 크기

-   메시지 전송 속도

-   전송 유형 (WebSocket/서버-전송-이벤트/긴 폴링)

-   사용 사례 시나리오 (라우팅 비용)

-   앱 서버 및 서비스 연결 (서버 모드)


### <a name="find-a-proper-sku"></a>적절 한 SKU를 찾을

인바운드/아웃 바운드 용량을 평가 하는 방법 또는 계층은 특정 사용 사례에 대 한 적합을 찾는 방법?

앱 서버 만큼 충분히 강력 하 고 성능에 병목 현상이 없는 가정 합니다. 그런 다음 모든 계층에 대 한 최대 인바운드 및 아웃 바운드 대역폭을 확인할 수 있습니다.

#### <a name="quick-evaluation"></a>빠른 평가

일부 기본 설정 가정 하 여 계산을 먼저 단순화 해 보겠습니다. WebSocket이 사용 됩니다, 메시지 크기는 2048 바이트를 1 초 마다 메시지를 전송 및 기본 모드입니다.

모든 계층에는 고유한 최대 인바운드 대역폭 및 아웃 바운드 대역폭입니다. 인바운드 또는 아웃 바운드 제한을 초과 되 면 원활한 사용자 환경을 보장 되지 않습니다.

**Echo** 라우팅 최저 비용 있기 때문에 최대 인바운드 대역폭을 제공 합니다. **브로드캐스트** 아웃 바운드 메시지를 최대 대역폭을 정의 합니다.

수행할 **되지** 다음 두 테이블에서 강조 표시 된 값을 초과 합니다.

|       echo                        | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|-----------------------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결                       | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| **인바운드 대역폭 (바이트/s)** | **2M**    | **4M**    | **10M**   | **20M**    | **40M**    | **1억 개**   | **200M**    |
| 아웃 바운드 대역폭 (바이트/s) | 2M    | 4M    | 10M   | 20M    | 40M    | 1억 개   | 200M    |


|     브로드캐스트             | Unit1 | Unit2 | Unit5  | Unit10 | Unit20 | Unit50  | Unit100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| 연결               | 1,000 | 2,000 | 5,000  | 10000 | 20,000 | 50,000  | 100,000 |
| 인바운드 대역폭 (바이트/s)  | 4K    | 4K    | 4K     | 4K     | 4K     | 4K      | 4K     |
| **아웃 바운드 대역폭 (바이트/s)** | **4M**    | **8M**    | **20M**    | **40M**    | **80M**    | **200M**    | **400 M**   |

인바운드 대역폭 및 아웃 바운드 대역폭 수식:
```
  inboundBandwidth = inboundConnections * messageSize / sendInterval
  outboundBandwidth = outboundConnections * messageSize / sendInterval
```

*inboundConnections*: 메시지를 보내는 연결 수

*outboundConnections*: 메시지를 수신 하는 연결 수

*messageSize*: 단일 메시지 (평균 값)의 크기입니다. 1024 바이트 보다 작은 크기가 작은 메시지에 1024 바이트 메시지로 비슷한 성능에 미치는 영향을 합니다.

*sendInterval*: 하나의 메시지를 전송 하는 일반적으로 시간은 1 초당 1 초 마다 하나의 메시지를 보내는 것을 의미 하는 메시지입니다. 더 작은 sendInterval 보낼 자세한 메시지 지정 된 기간을 의미 합니다. 예를 들어 메시지당 0.5 초는 1 초 마다 두 개의 메시지를 보내는 의미 합니다.

*연결* 모든 계층에 대 한 ASRS 커밋된 최대 임계값입니다. 연결 수를 더 늘어날 경우에 연결 제한에서 저하 됩니다.

*인바운드 대역폭* 하 고 *아웃 바운드 대역폭* 초당 총 메시지 크기입니다. 저는 여기 ' 편의상 메가바이트를 의미 합니다.

#### <a name="evaluation-for-complex-use-cases"></a>복잡 한 사용 사례에 대 한 평가

##### <a name="bigger-message-size-or-different-sending-rate"></a>큰 메시지 크기 또는 다른 송신 율

실제 사용 사례는 더 복잡 합니다. 2048 바이트 보다 큰 메시지에 보낼 수 있습니다 또는 보내는 메시지 속도가 초당 하나의 메시지에 없습니다. 예를 들어 해당 성능을 평가 하는 방법을 찾을 unit100의 브로드캐스트를 살펴보겠습니다.

다음 테이블의 실제 사례를 보여 줍니다 **브로드캐스트**, 하지만 메시지 크기, 연결 수 및 속도 보내는 메시지는 이전 섹션에서 가정에서는 다릅니다. 질문 하는 방법을 추론할 수 있습니다 (메시지 크기, 연결 개수 또는 메시지 송신 율) 이러한 항목 중 하나라도 2만 알고 있다면입니다.

| 브로드캐스트  | 메시지 크기 (바이트) | 인바운드 (메시지/s) | 연결 | 간격 (초) 보내기 |
|---|---------------------|--------------------------|-------------|-------------------------|
| 1 | 20K                 | 1                        | 100,000     | 5                       |
| 2 | 256 K                | 1                        | 8,000       | 5                       |

다음 수식은 다음과 같습니다. 쉽게 기존 수식을 이전을 기준으로 유추할 수 있도록

```
outboundConnections = outboundBandwidth * sendInterval / messageSize
```

이전 테이블에서 최대 아웃 바운드 대역폭은 400 M 다음 20k 메시지 크기에 대 한 최대 아웃 바운드 연결 해야 400 M 알게 unit100에 대 한 \* 5 / 20 K = 100,000, 실제 값과 일치 하는 합니다.

##### <a name="mixed-use-cases"></a>혼합된 사용 사례

실제 사용 사례는 일반적으로 혼합 네 가지 기본 사용 사례를 함께: **echo**를 **브로드캐스트**를 **그룹에 송신**, 또는 **연결 보내기**합니다. 용량을 평가 하는 데 사용 방법은 네 가지 기본 사용 사례, 혼합된 사용 사례를 나누고 **인바운드 및 아웃 바운드 메시지를 최대 대역폭을 계산할** 개별적으로 위의 수식을 사용 하 여 합계를 계산 하 고 최대 인바운드/아웃 바운드 대역폭입니다. 최대 인바운드/아웃 바운드 대역폭 테이블에서 적절 한 계층을 선택 합니다.

한편, 수백 또는 수천 개의 작은 그룹 또는 수천 개의 서로 메시지를 보내는 클라이언트의 메시지를 보내기에 대 한 라우팅 비용 기준 있게 됩니다. 계정에이 영향을 취해야 합니다. 자세한 내용은 다음 "사례 연구" 섹션에 나와 있습니다.

클라이언트에 메시지를 보내는 사용 사례에 대 한 앱 서버 인지 확인 **되지** 병목 상태가 발생 합니다. "사례 연구" 섹션 해야 얼마나 많은 앱 서버 및 서버 연결 수를 구성 해야 지침을 제공 합니다.

## <a name="case-study"></a>사례 연구

WebSocket 전송에 대 한 4 가지 일반적인 사용 사례를 통해 다음 섹션에서는 이동: **echo**를 **브로드캐스트**를 **그룹에 송신**, 및 **송신-연결** . 현재 ASRS 나열 각 시나리오에 대 한 인바운드 및 아웃 바운드 용량 한편 주요 요인이 성능에 새로운 기능을 설명 합니다.

기본 모드에서는 기본적으로 Azure SignalR Service SDK를 통해 응용 프로그램 서버, ASRS를 사용 하 여 5 서버 연결을 만듭니다. 성능에서 테스트 결과 아래 연결 15 (또는 브로드캐스트 및 큰 그룹에 보내는 메시지에 대 한 자세한 내용은) 증가 하는 서버입니다.

앱 서버에서 서로 다른 요구 사항이 하는 다양 한 사용 사례. **브로드캐스트** 적은 수의 앱 서버가 필요 합니다. **Echo** 또는 **연결 송신** 많은 앱 서버가 필요 합니다.

모든 사용 사례, 기본 메시지 크기는 2048 바이트 및 메시지 송신 간격은 1 초입니다.

## <a name="default-mode"></a>기본 모드

이 모드에서는 클라이언트, 웹 앱 서버 및 ASRS 포함 됩니다. 모든 클라이언트는 단일 연결을 나타냅니다.

### <a name="echo"></a>echo

첫째, 웹 앱 ASRS에 연결합니다. 둘째, 많은 클라이언트 연결 웹 앱에 액세스 토큰 및 끝점을 사용 하 여 ASRS에 클라이언트를 리디렉션하는 합니다. 그런 다음 클라이언트 ASRS 사용 하 여 WebSocket 연결을 설정합니다.

모든 클라이언트 연결을 설정 후 1 초 마다 특정 허브에 타임 스탬프를 포함 하는 메시지를 보내기 시작 합니다. 허브 메시지는 원래 클라이언트를 다시 에코합니다. 모든 클라이언트 다시 에코 메시지를 받을 때 대기 시간을 계산 합니다.

5 단계\~8 (빨간색 강조 표시 된 트래픽)은 루프의 기본 기간 (5 분)을 실행 하 고 모든 메시지 대기 시간 통계를 가져옵니다.
성능 가이드에서는 최대 클라이언트 연결 수입니다.

![echo](./media/signalr-concept-performance/echo.png)

**Echo**의 동작 최대 인바운드 대역폭 최대 아웃 바운드 대역폭와 같은지를 확인 합니다. 다음 표를 참조 하십시오.

|       echo                        | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|-----------------------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결                       | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 인바운드/아웃 바운드 (메시지/s) | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 인바운드/아웃 바운드 대역폭 (바이트/s) | 2M    | 4M    | 10M   | 20M    | 40M    | 1억 개   | 200M    |

이 사용 사례에서 모든 클라이언트 응용 프로그램 서버에 정의 된 허브를 호출 합니다. 허브 원래 클라이언트 쪽에 정의 된 메서드를 호출 합니다. 이 허브는에 대 한 가장 간단한 weighed 허브 **echo**합니다.

```
        public void Echo(IDictionary<string, object> data)
        {
            Clients.Client(Context.ConnectionId).SendAsync("RecordLatency", data);
        }
```

이 간단한 허브에 대해서도 응용 프로그램 서버에 대 한 트래픽을 압력 이기도으로 유명한 합니다 **echo** 인바운드 메시지 증가 합니다. 따라서 큰 SKU 계층에 대 한 많은 앱 서버가 필요합니다. 다음 표에서 모든 계층에 대 한 앱 서버 수를 나열합니다.


|    echo          | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 3      | 3      | 10     | 20      |

> [!NOTE]
>
> 클라이언트 연결 수, 메시지 크기, 메시지 전송 속도, SKU 계층 및 앱 서버의 CPU/메모리는의 전반적인 성능에 영향을 미칠 **echo**합니다.

### <a name="broadcast"></a>브로드캐스트

에 대 한 **브로드캐스트**웹 앱에는 메시지를 수신 하는 경우 모든 클라이언트에 전파 합니다. 모든 클라이언트에 더 많은 메시지 트래픽을 브로드캐스트를 더 많은 클라이언트입니다. 다음 다이어그램을 참조 하세요.

![브로드캐스트](./media/signalr-concept-performance/broadcast.png)

브로드캐스트의 특징에는 인바운드 메시지 대역폭은 작은 되므로 적은 수의 클라이언트 브로드캐스팅을 있지만 아웃 바운드 대역폭은 엄청난입니다. 클라이언트 연결으로 아웃 바운드 메시지 대역폭 증가 또는 브로드캐스트 속도가 증가 합니다.

최대 클라이언트 연결, 인바운드/아웃 바운드 메시지 개수 및 대역폭은 다음 표에 요약 되어 있습니다.

|     브로드캐스트             | Unit1 | Unit2 | Unit5  | Unit10 | Unit20 | Unit50  | Unit100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| 연결               | 1,000 | 2,000 | 5,000  | 10000 | 20,000 | 50,000  | 100,000 |
| 인바운드 (메시지/s)  | 2     | 2     | 2      | 2      | 2      | 2       | 2       |
| 아웃 바운드 (메시지/s) | 2,000 | 4,000 | 10000 | 20,000 | 40,000 | 100,000 | 200,000 |
| 인바운드 대역폭 (바이트/s)  | 4K    | 4K    | 4K     | 4K     | 4K     | 4K      | 4K      |
| 아웃 바운드 대역폭 (바이트/s) | 4M    | 8M    | 20M    | 40M    | 80M    | 200M    | 400 M    |

메시지를 게시 하는 브로드캐스트 클라이언트는 4 개 이하로, 적은 수의 앱 서버와 비교 해야 **echo** 인바운드 메시지 크기는 작으므로 합니다. 두 앱 서버는 SLA 및 성능 고려 사항에 적합 합니다. 하지만 특히 한 Unit50 Unit100 불균형된 문제를 방지 하려면 기본 서버 연결을 늘려야 합니다.

|   브로드캐스트      | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 2      | 2      | 2      | 2       |

> [!NOTE]
>
> 5에서 기본 서버 연결 수를 40 ASRS에 대 한 가능한 불균형된 서버 연결을 방지 하려면 모든 앱 서버의 늘립니다.
>
> 클라이언트 연결 수, 메시지 크기, 메시지 송신 율 및 SKU 계층에 대 한 전반적인 성능에 영향을 미칠 **브로드캐스트**

### <a name="send-to-group"></a>그룹에 송신

**그룹에 송신** 패턴이 비슷한 트래픽을 제외 하 고 클라이언트 ASRS 사용 하 여 WebSocket 연결을 설정 후에 연결 해야 그룹을 특정 그룹에 메시지를 보낼 수 있습니다. 다음 다이어그램에서 트래픽 흐름을 보여 줍니다.

![그룹에 보내기](./media/signalr-concept-performance/sendtogroup.png)

그룹 구성원 그룹 수와 성능에 영향을 사용 하 여 두 가지 요인입니다. 두 종류의 그룹 정의 간소화 하기 위해 분석: 소규모 및 대규모 그룹입니다.

- `small group`: 모든 그룹에 10 개의 연결 합니다. 그룹 수입니다 (최대 연결 수) / 10입니다. 예를 들어, 단위 1, 1000 연결 수 없으면 다음 했습니다 1000 / 10 = 100 그룹입니다.

- `Big group`: 그룹 번호는 항상 10입니다. 그룹 멤버 수 (최대 연결 수)는 / 10입니다. 예를 들어, 단위 1에 대 한 연결 수가 1000을 하는 경우 다음 모든 그룹에 1000 / 10 = 100 명의 멤버입니다.

**그룹에 송신** 분산된 데이터 구조를 통해 대상 연결을 찾을 수 있기 때문에 라우팅 비용 ASRS를 제공 합니다. 전송 연결을 늘리려면 비용도 증가 합니다.

#### <a name="small-group"></a>소규모 그룹

라우팅 비용은 여러 작은 그룹에 메시지를 보내기 위해 중요 합니다. 현재 ASRS 구현 unit50 라우팅 비용 제한에 도달 합니다. 더 많은 CPU와 메모리를 추가지 않습니다 도움말, unit100 개선할 수 있도록 디자인 하 여 추가 되지 않습니다. 인바운드 대역폭을 요구 하는 경우 사용자 지정에 대 한 고객 지원에 문의 합니다.

|   소규모 그룹 보내기     | Unit1 | Unit2 | Unit5  | Unit10 | Unit20 | Unit50 | Unit100 |
|---------------------------|-------|-------|--------|--------|--------|--------|---------|
| 연결               | 1,000 | 2,000 | 5,000  | 10000 | 20,000 | 50,000 | 100,000
| 그룹 구성원 수        | 10    | 10    | 10     | 10     | 10     | 10     | 10 
| 그룹 수               | 100   | 200   | 500    | 1,000  | 2,000  | 5,000  | 10000 
| 인바운드 (메시지/s)  | 200   | 400   | 1,000  | 2,500  | 4,000  | 7,000  | 7,000   |
| 인바운드 대역폭 (바이트/s)  | 400 K  | 800 K  | 2M     | 5M     | 8M     | 14M    | 14M     |
| 아웃 바운드 (메시지/s) | 2,000 | 4,000 | 10000 | 25,000 | 40,000 | 70,000 | 70,000  |
| 아웃 바운드 대역폭 (바이트/s) | 4M    | 8M    | 20M    | 50M     | 80M    | 140M   | 140M    |

따라서 앱 서버 수는 성능에 대 한 중요 한도, 허브를 호출 하는 클라이언트 연결 수 있습니다. 제안 된 앱 서버 수는 다음 표에 나열 됩니다.

|  소규모 그룹 보내기   | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 3      | 3      | 10     | 20      |

> [!NOTE]
>
> 클라이언트 연결 수, 메시지 크기, 메시지 송신 율, 라우팅 비용, SKU 계층 및 앱 서버의 CPU/메모리의 전반적인 성능에 영향을 미칠 **송신-작은 그룹**합니다.

#### <a name="big-group"></a>큰 그룹

에 대 한 **송신 큰-그룹**, 아웃 바운드 대역폭 제한을 비용 라우팅에 도달 하기 전에 병목 상태가 발생 합니다. 다음 표에서 최대 아웃 바운드 대역폭으로 **브로드캐스트**합니다.

|    큰 그룹 보내기      | Unit1 | Unit2 | Unit5  | Unit10 | Unit20 | Unit50  | Unit100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| 연결               | 1,000 | 2,000 | 5,000  | 10000 | 20,000 | 50,000  | 100,000
| 그룹 구성원 수        | 100   | 200   | 500    | 1,000  | 2,000  | 5,000   | 10000 
| 그룹 수               | 10    | 10    | 10     | 10     | 10     | 10      | 10
| 인바운드 (메시지/s)  | 20    | 20    | 20     | 20     | 20     | 20      | 20      |
| 인바운드 대역폭 (바이트/s)  | 80 K   | 40K   | 40K    | 20K    | 40K    | 40K     | 40K     |
| 아웃 바운드 (메시지/s) | 2,000 | 4,000 | 10000 | 20,000 | 40,000 | 100,000 | 200,000 |
| 아웃 바운드 대역폭 (바이트/s) | 8M    | 8M    | 20M    | 40M    | 80M    | 200M    | 400 M    |

전송 연결 수는 40 개 이하의 앱 서버의 부담 작습니다, 그리고 따라서 제안 된 웹 앱 수가 작습니다도 합니다.

|  큰 그룹 보내기  | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 2      | 2      | 2      | 2       |

> [!NOTE]
>
> 5에서 기본 서버 연결 수를 40 ASRS에 대 한 가능한 불균형된 서버 연결을 방지 하려면 모든 앱 서버의 늘립니다.
> 
> 클라이언트 연결 수, 메시지 크기, 메시지 송신 율, 라우팅 비용 및 SKU 계층의 전반적인 성능에 영향을 미칠 **송신 큰-그룹**합니다.

### <a name="send-to-connection"></a>연결에 보내기

이 사용 사례에서 클라이언트 ASRS에 대 한 연결을 설정 하는 경우 모든 클라이언트 호출 특수 허브 고유한 연결 ID를 가져옵니다. 성능 벤치 마크는 모든 연결 Id를 수집, 하는 순서 섞기를 및 보내는 대상인 모든 클라이언트에 다시 할당 합니다. 성능 테스트를 완료 될 때까지 클라이언트 대상 연결에 메시지를 보내는 유지.

![클라이언트에 보낼](./media/signalr-concept-performance/sendtoclient.png)

에 대 한 비용 라우팅을 **연결 송신** 와 비슷합니다 **송신-작은 그룹**합니다.

연결 수 증가 하면 전반적인 성능 라우팅 비용으로 제한 됩니다. 50 단위 제한에 도달 했습니다. 결과적으로, 단위 100을 추가로 개선할 수 없습니다.

다음 표에서 여러 차례의 실행 후 요약 통계 **연결 송신** 벤치 마크

|   연결에 보내기   | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50          | Unit100         |
|------------------------------------|-------|-------|-------|--------|--------|-----------------|-----------------|
| 연결                        | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000          | 100,000         |
| 인바운드 / 아웃 바운드 (메시지/s) | 1,000 | 2,000 | 5,000 | 8,000  | 9,000  | 20,000 | 20,000 |
| 인바운드 / 아웃 바운드 대역폭 (바이트/s) | 2M    | 4M    | 10M   | 16M    | 18 M    | 40M       | 40M       |

이 사용 사례에는 서버 쪽 앱에 대 한 높은 부하에 필요합니다. 제안 된 앱 서버를 참조 하세요. 다음 테이블의 수입니다.

|  연결에 보내기  | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 3      | 3      | 10     | 20      |

> [!NOTE]
>
> 클라이언트 연결 수, 메시지 크기, 메시지 송신 율, 라우팅 비용, SKU 계층 및 앱 서버의 CPU/메모리의 전반적인 성능에 영향을 미칠 **연결 송신**합니다.

### <a name="aspnet-signalr-echobroadcastsend-to-connection"></a>ASP.NET SignalR echo/브로드캐스트/송신-연결

ASRS는 ASP.NET SignalR에 대 한 동일한 성능 용량을 제공합니다. 이 섹션에서는 ASP.NET SignalR에 대 한 제안 된 웹 앱 수가 제공 **echo**를 **브로드캐스트**, 및 **송신-작은 그룹**합니다.

Azure 웹 앱을 사용 하는 성능 테스트 [표준 서비스 계획 S3](https://azure.microsoft.com/pricing/details/app-service/windows/) ASP.NET SignalR에 대 한 합니다.

- `echo`

|   echo           | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 4     | 4      | 8      | 32      | 40       |

- `broadcast`

|  브로드캐스트       | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 2     | 2      | 2      | 2      | 2       |

- `Send-to-small-group`

|  소규모 그룹 보내기     | Unit1 | Unit2 | Unit5 | Unit10 | Unit20 | Unit50 | Unit100 |
|------------------|-------|-------|-------|--------|--------|--------|---------|
| 연결      | 1,000 | 2,000 | 5,000 | 10000 | 20,000 | 50,000 | 100,000 |
| 앱 서버 수 | 2     | 2     | 4     | 4      | 8      | 32      | 40       |

## <a name="serverless-mode"></a>서버 리스 모드

이 모드에서는 클라이언트와 ASRS 포함 됩니다. 모든 클라이언트는 단일 연결을 나타냅니다. 클라이언트는 모든 다른 클라이언트 또는 브로드캐스트 메시지를 REST API를 통해 메시지를 보냅니다.

REST API를 통해 고밀도 메시지를 보내는 아니므로 WebSocket을 만큼 효율적이 지 새 HTTP 연결 될 때마다-때 추가 비용이 서버 리스 모드로 작성 해야 합니다.

### <a name="broadcast-through-rest-api"></a>REST API를 통해 브로드캐스트
모든 클라이언트 ASRS 사용 하 여 WebSocket 연결을 설정합니다. 다음 일부 클라이언트는 REST API를 통해 브로드캐스트를 시작 합니다. 메시지 보내기 (인바운드)는 없는 효율적인 WebSocket 비교할 HTTP Post를 지원 합니다.

|   REST API를 통해 브로드캐스트     | Unit1 | Unit2 | Unit5  | Unit10 | Unit20 | Unit50  | Unit100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| 연결               | 1,000 | 2,000 | 5,000  | 10000 | 20,000 | 50,000  | 100,000 |
| 인바운드 (메시지/s)  | 2     | 2     | 2      | 2      | 2      | 2       | 2       |
| 아웃 바운드 (메시지/s) | 2,000 | 4,000 | 10000 | 20,000 | 40,000 | 100,000 | 200,000 |
| 인바운드 대역폭 (바이트/s)  | 4K    | 4K    | 4K     | 4K     | 4K     | 4K      | 4K      |
| 아웃 바운드 대역폭 (바이트/s) | 4M    | 8M    | 20M    | 40M    | 80M    | 200M    | 400 M    |

### <a name="send-to-user-through-rest-api"></a>REST API를 통해 사용자에 게 보내기
벤치 마크는 ASRS에 연결을 시작 하기 전에 모든 클라이언트에 사용자 이름을 할당 합니다. 클라이언트 ASRS 사용 하 여 WebSocket 연결을 설정한 후 HTTP Post를 통해 다른 사용자에 게 메시지를 보내기 시작 합니다.

|   REST API를 통해 사용자에 게 보내기 | Unit1 | Unit2 | Unit5  | Unit10 | Unit20 | Unit50  | Unit100 |
|---------------------------|-------|-------|--------|--------|--------|---------|---------|
| 연결               | 1,000 | 2,000 | 5,000  | 10000 | 20,000 | 50,000  | 100,000 |
| 인바운드 (메시지/s)  | 300   | 600   | 900    | 1,300  | 2,000  | 10000  | 18,000  |
| 아웃 바운드 (메시지/s) | 300   | 600   | 900    | 1,300  | 2,000  | 10000  | 18,000 |
| 인바운드 대역폭 (바이트/s)  | 600 K  | 1.2M  | 1.8M   | 2.6M   | 4M     | 10M     | 36M    |
| 아웃 바운드 대역폭 (바이트/s) | 600 K  | 1.2M  | 1.8M   | 2.6M   | 4M     | 10M     | 36M    |

## <a name="performance-test-environments"></a>성능 테스트 환경

위에 나열 된 모든 사용 사례에 대 한 성능 테스트를 Azure 환경에서 수행 되었습니다. 대부분의 50 클라이언트 Vm 및 20 앱 서버 Vm이 사용 됩니다.

클라이언트 VM 크기: StandardDS2V2 (2 vCPU, 7 G 메모리)

앱 서버 VM 크기: StandardF4sV2 (4 vCPU, 8g 메모리)

Azure SignalR SDK 서버 연결: 15

## <a name="performance-tools"></a>성능 도구

https://github.com/Azure/azure-signalr-bench/tree/master/SignalRServiceBenchmarkPlugin

## <a name="next-steps"></a>다음 단계

이 문서에서는 일반적인 사용 사례 시나리오에서 SignalR Service 성능의 개요를 봅니다.

SignalR Service 및 SignalR 서비스에 대 한 크기 조정의 내부에서 자세한 내용을 보려면, 다음 가이드를 읽습니다.

* [Azure SignalR Service 내부](signalr-concept-internals.md)
* [Azure SignalR Service 크기 조정](signalr-howto-scale-multi-instances.md)