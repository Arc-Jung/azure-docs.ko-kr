---
title: Azure 정문 구성 문제 해결
description: 이 자습서에서는 Front Door에 발생할 수 있는 일반적인 문제 몇 가지를 자체적으로 해결하는 방법을 알아보세요.
services: frontdoor
documentationcenter: ''
author: sharad4u
editor: ''
ms.service: frontdoor
ms.workload: infrastructure-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 09/22/2018
ms.author: sharadag
ms.openlocfilehash: 962c884eb8adc05e5d50b6b254d5c3f0b18af556
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/28/2020
ms.locfileid: "79471509"
---
# <a name="troubleshooting-common-routing-issues"></a>일반적인 라우팅 문제 해결

이 문서에서는 Azure 정문 구성에서 직면할 수 있는 몇 가지 일반적인 라우팅 문제를 해결하는 방법을 설명합니다.

## <a name="503-response-from-front-door-after-a-few-seconds"></a>몇 초 후 정문에서 503 응답

### <a name="symptom"></a>증상

- 정문을 통과하지 않고 백 엔드로 전송되는 일반 요청은 성공하지만, 정문을 통해 가면 503 오류 응답이 발생합니다.

- 정문에서 오류가 몇 초 후에 표시됩니다(일반적으로 30초 후)

### <a name="cause"></a>원인

이 증상은 백 엔드가 정문에서 요청을 수신하는 데 시간 초과 구성(기본값은 30초)을 초과하거나 이 시간 초과 값을 초과하여 Front Door에서 요청에 대한 응답을 보내는 경우에 발생합니다. 

### <a name="troubleshooting-steps"></a>문제 해결 단계

- (정문을 통과하지 않고) 직접 백 엔드에 요청을 보내고 백 엔드가 응답하는 데 걸리는 일반적인 시간을 참조하십시오.
- 정문을 통해 요청을 보내고 503 개의 응답이 표시되는지 확인하십시오. 그렇지 않은 경우 시간 지정 문제가 아닐 수 있습니다. 지원 담당자에게 문의하세요.
- 정문을 통해 503개의 오류 응답 코드가 생성되는 경우 정문에 대한 sendReceiveTimeout 필드를 구성하여 기본 시간 초과를 최대 4분(240초)까지 연장합니다. 설정아래에 `backendPoolSettings` 있으며 을 호출합니다. `sendRecvTimeoutSeconds` 

## <a name="requests-sent-to-the-custom-domain-returns-400-status-code"></a>사용자 지정 도메인으로 전송된 요청은 400 상태 코드를 반환합니다.

### <a name="symptom"></a>증상

- 정문(Front Door)을 만들었지만 도메인 또는 프런트 엔드 호스트에 대한 요청이 HTTP 400 상태 코드를 반환합니다.

- 사용자 지정 도메인에서 사용자가 구성한 프런트 엔드 호스트로의 DNS 매핑을 만들었습니다. 하지만 사용자 지정 도메인 호스트 이름으로 요청을 보내면 HTTP 400 상태 코드가 반환되고, 사용자가 구성한 백 엔드로 라우팅하는 것으로 나타나지 않습니다.

### <a name="cause"></a>원인

프런트 엔드 호스트로 추가한 사용자 지정 도메인에 대한 회람 규칙을 구성하지 않은 경우 이러한 현상이 발생할 수 있습니다. 사용자 지정 도메인이 DNS 매핑을 가지고 있는 Front Door 하위 도메인(*.azurefd.net) 아래에서 프런트 엔드 호스트에 이미 구성되어 있더라도 프런트 엔드 호스트에 회람 규칙을 명시적으로 추가해야 합니다.

### <a name="troubleshooting-steps"></a>문제 해결 단계

사용자 지정 도메인에서 원하는 백 엔드 풀로의 회람 규칙을 추가합니다.

## <a name="front-door-is-not-redirecting-http-to-https"></a>정문이 HTTP를 HTTPS로 리디렉션하지 않습니다.

### <a name="symptom"></a>증상

Front Door에는 HTTP를 HTTPS로 리디렉션하라는 라우팅 규칙이 있지만 도메인에 액세스하면 HTTP가 프로토콜로 유지됩니다.

### <a name="cause"></a>원인

이 문제는 Front Door의 라우팅 규칙을 올바르게 구성하지 않은 경우 발생할 수 있습니다. 기본적으로 현재 구성은 구체적이지 않으며 규칙이 충돌할 수 있습니다.

### <a name="troubleshooting-steps"></a>문제 해결 단계

## <a name="request-to-frontend-hostname-returns-404-status-code"></a>프런트 엔드 호스트 이름에 대한 요청이 404 상태 코드 반환

### <a name="symptom"></a>증상

- Front Door를 만들고 프런트 엔드 호스트, 하나 이상의 백 엔드가 있는 백 엔드 풀, 프런트 엔드 호스트를 백 엔드 풀로 연결하는 회람 규칙을 구성했습니다. HTTP 404 상태 코드가 반환된 것으로 보아 구성된 프런트 엔드 호스트로 요청을 보낼 때 콘텐츠가 보이지 않는 것 같습니다.

### <a name="cause"></a>원인

이 증상의 잠재적 원인에는 몇 가지가 있습니다.

- 백 엔드는 공용을 향한 백 엔드가 아니며 정문에 표시되지 않습니다.
- 백 엔드가 잘못 구성되어 있어 정문이 잘못된 요청을 보내게 됩니다(즉, 백 엔드는 HTTP만 허용하지만 HTTPS를 허용하지 않도록 선택 취소하지 않은 경우 Front Door가 HTTPS 요청을 전달하려고 시도합니다).
- 백 엔드가 백 엔드에 대한 요청으로 전달된 호스트 헤더를 거부하고 있습니다.
- 백 엔드 구성이 아직 완전히 배포되지 않았습니다.

### <a name="troubleshooting-steps"></a>문제 해결 단계

1. 배포 시간
   - 구성이 배포될 때까지 기다린 시간이 10분 이내인지 확인하세요.

2. 백 엔드 설정 확인
    - 요청을 라우팅해야 하는 백 엔드 풀(회람 규칙이 구성된 방식에 따라 다름)로 이동하고, _백 엔드 호스트 유형_ 및 백엔드 호스트 이름이 올바른지 확인합니다. 백 엔드가 사용자 지정 호스트일 경우 철자라 올바른지 확인하십시오. 

    - HTTP 및 HTTPS 포트를 확인합니다. 대부분의 경우 80 및 443(각각)이 올바르며, 변경 작업은 필요하지 않습니다. 하지만 백 엔드가 이런 식으로 구성되지 않아서 다른 포트에서 수신 대기 중일 가능성이 있습니다.

        - 프런트 엔드 호스트를 라우팅해야 하는 백 엔드에 _백 엔드 호스트 헤더_가 구성되어 있는지 확인하세요. 대부분의 경우 이 헤더는 _백 엔드 호스트 이름_과 동일해야 합니다. 그러나 백 엔드에서 기대한 값과 다를 경우 다양한 HTTP 4xx 상태 코드가 반환될 수 있습니다. 백 엔드의 IP 주소를 입력하는 경우 _백 엔드 호스트 헤더_를 백 엔드의 호스트 이름으로 설정해야 할 수 있습니다.


3. 회람 규칙 설정 확인
    - 해당 프런트 엔드 호스트 이름에서 백 엔드 풀로 라우팅되어야 하는 회람 규칙으로 이동합니다. 허용되는 프로토콜이 올바르게 구성되었는지, 그렇지 않다면 요청 전달 시 Front Door에서 사용할 프로토콜이 올바르게 구성되었는지 확인하세요. _허용된 프로토콜_ 필드는 Front Door가 수락해야 하는 요청을 결정하고 _전달 프로토콜은_ 프런트 도어가 요청을 백 엔드로 전달하는 데 사용해야 하는 프로토콜을 결정합니다.
         - 예를 들어 백 엔드가 HTTP 요청만 허용하는 경우 다음과 같은 구성이 유효합니다.
            - _허용되는 프로토콜_은 HTTP 및 HTTPS입니다. _전달 프로토콜_은 HTTP입니다. HTTPS가 허용되는 프로토콜이므로 일치 요청이 작동하지 않으며, 요청이 HTTPS 형식으로 수행될 경우 Front Door가 HTTPS를 사용하여 전달을 시도합니다.

            - _허용되는 프로토콜_은 HTTP입니다. _전달 프로토콜_은 일치 요청 또는 HTTPS입니다.

    - _Url 다시 쓰기_는 기본적으로 비활성화되며, 사용 가능하게 만들려는 백 엔드 호스트 리소스의 범위를 좁히려는 경우에만 이 필드를 사용해야 합니다. 비활성화될 경우 Front Door가 수신한 요청 경로를 전달합니다. 이 필드가 잘못 구성되었고 Front Door가 사용할 수 없는 백 엔드에서 리소스를 요청하는 경우 HTTP 404 상태 코드가 반환됩니다.

