<properties linkid="develop-dotnet-performance" urlDisplayName="Performance" pageTitle="Performance best practices - Azure" metaKeywords="Azure optimization, Azure best practice performance" description="Learn about best practices for performance in Azure." metaCanonical="" services="cloud-services,sql-database,storage,service-bus,virtual-network" documentationCenter=".NET" title="" authors="" solutions="" manager="" editor="" />

Azure 응용 프로그램의 성능 모범 사례
====================================

이 가이드에서는 Azure 응용 프로그램의 성능 최적화를 위해 따라야 할 모범 사례와 기술에 대한 규범적인 지침을 제공합니다.

Azure를 사용하면 많은 이점을 누릴 수 있으며 성능은 그중 하나에 불과합니다. 이 문서의 권장 사항에서는 주로 성능에 초점을 맞춥니다. 성능이 가장 중요한 요소가 아닌 다른 시나리오도 있습니다. 예를 들면, Azure를 통해 물리적인 하드웨어 관리의 부담을 덜고자 할 수도 있고 "종량제" 기능에 특별히 매력을 느낄 수도 있습니다. 이 문서에서는 성능이 최고 우선 순위가 아닌 시나리오를 평가하지 않습니다.

개요
----

성능은 [투입한 시간과 리소스에 대비하여 "달성하는 유용한 작업량"](http://go.microsoft.com/fwlink/?LinkId=252650)이라고 정의할 수 있습니다.

이 정의에는 메트릭과 리소스라는 두 가지 면이 있습니다. 성능 메트릭은 비즈니스 요구 사항을 충족하기 위해 실현해야 할 수치로서 응답 시간, 처리량, 가용성 등을 포함합니다. 성능 메트릭의 일정 수준에 도달하는 데 필요한 리소스 사용량 수준도 성능에 포함됩니다. 비용 절감은 거의 언제나 비즈니스 요구 사항이며 리소스 사용에는 비용이 발생하므로, 성능은 리소스를 최대한 효율적으로 사용하는 것을 의미합니다.

### 성능 수명 주기

응용 프로그램 수명 주기에서 다음과 같은 두 지점이 성능에 영향을 미칠 수 있습니다.

-   설계 기간 - 성능에 영향을 미칠 수 있는 기본적인 아키텍처 관련 결정을 내립니다.
-   런타임 시 - 병목을 파악하고 모니터링과 조치를 수행합니다.

두 가지 활동 모두 필요하지만 이 백서에서는 주로 설계 부문에 초점을 맞춥니다. 아키텍처 관련 실수는 런타임 시 수정하기가 더 어렵기 때문입니다.

#### 응용 프로그램 모델링

가장 중요한 응용 프로그램 고객 시나리오의 모델을 구축하는 것이 중요합니다. 여기서 "중요한"이란 말은 성능에 가장 큰 영향을 미친다는 뜻입니다. 이러한 시나리오와 필요한 응용 프로그램 활동을 파악하면 개념 증명 테스트를 수행할 수 있습니다.

#### 개념 증명 성능 테스트

완전한 종단 간 성능 테스트는 응용 프로그램 설계 및 배포 과정에서 매우 중요한 단계입니다. Azure 응용 프로그램은 많은 요소로 구성되어 있는데, 여기에는 사용자 지정 빌드 구성 요소는 물론 Microsoft에서 제공한 구성 요소도 포함될 수 있습니다. Microsoft에서 이런 구성 요소의 모든 가능한 조합을 테스트할 수는 없습니다. 따라서 응용 프로그램의 성능 테스트를 적절하고 완전하게 수행하는 것이 배포에서 매우 중요한 단계입니다.

응용 프로그램 모델을 빌드한 후에는 가능한 한 빨리 응용 프로그램의 개념 증명 테스트를 수행해야 합니다. 그런 다음, 그 결과를 로드하여 응용 프로그램 아키텍처의 유효성을 검사하고 응용 프로그램이 확장성과 대기 시간과 관련한 성능 요구 사항을 충족하는지 확인해야 합니다. 초기 아키텍처와 가정의 유효성을 검사하는 것이 매우 중요합니다. 응용 프로그램이 라이브 상태가 된 후 예상 부하를 처리할 수 없음을 알게 되는 곤란한 상황에 처할 수 있기 때문입니다. Visual Studio는 부하 테스트를 수행하기 위한 기능을 제공합니다. 자세한 내용은 [Azure에서 Visual Studio 부하 테스트 개요](http://www.visualstudio.com/get-started/load-test-your-app-vs)를 참조하십시오.

### Azure에서 제공하는 성능의 차별성

Azure 응용 프로그램에서는 리소스의 확장과 분할을 통해 가장 극적인 성능 개선을 달성할 수 있습니다. Azure에서 확장 가능한 응용 프로그램을 빌드하려면 SQL 데이터베이스, 저장소, 컴퓨터 노드 등의 리소스를 물리적으로 분할하여 확장할 수 있어야 합니다. 이러한 분할은 응용 프로그램 작업의 병렬 실행을 가능하게 하므로 고성능의 기반이 됩니다. Azure에서는 사용 가능한 전체 데이터 센터의 리소스를 보유하며 사용자를 위해 물리적 분할을 처리하기 때문입니다. 이 수준의 전체적인 성능을 달성하려면 적절한 규모 확장 설계 패턴을 사용해야 합니다.

역설적이게도, 응용 프로그램에서는 전체적으로 이러한 고성능을 달성하지만 네트워크 대기 시간 증가, 장애 조치(Failover) 작업으로 인한 안정성 향상 등으로 인해 개별적인 각 작업의 성능은 온-프레미스보다 Azure에서 더 떨어집니다. 그러나 리소스 분할의 적절한 사용에 따른 병렬 처리는 개별적인 성능 저하를 보충하고도 남습니다.

### 필요한 설계 활동

응용 프로그램 시나리오에 따라 일부 성능 요소도 변경됩니다. 다음 장에서는 리소스의 확대와 분할, 데이터를 적절히 배치하기, Azure 서비스 사용 최적화 등에 대해 설명합니다.

그다음 장에서는 Azure 응용 프로그램과 관련된 성능 요소, 즉 네트워크 대기 시간, 일시적 연결 등에 대해 설명합니다.

클라우드 환경에서 성능을 높이기 위한 설계
-----------------------------------------

Azure 응용 프로그램을 설계하거나 온-프레미스 응용 프로그램을 Azure로 마이그레이션할 때 다음과 같은 시나리오별 영역을 고려해야 합니다.

-   리소스 확장과 분할: 병렬 처리, 나아가 고성능을 달성하기 위한 기본 메커니즘
-   데이터 아키텍처: 응용 프로그램 데이터의 서로 다른 부분을 사용하기 위한 데이터 저장소 유형
-   개별 Azure 서비스 최적화

Azure는 활동의 대규모 병렬 처리가 가능한 리소스 확장 및 분할 기능을 통해 최대 성능 이점을 얻습니다. 이러한 이점은 대규모 Azure SQL 데이터베이스를 생각해보면 매우 분명하지만, 병목 지점이 될 수 있는 리소스가 있는 것도 사실입니다.

Azure는 데이터 저장소에 대해 다음과 같은 선택 사항을 제공합니다. 올바른 선택이 성능에 큰 영향을 미치게 됩니다.

-   Azure SQL 데이터베이스
-   Azure 캐싱
-   Azure 테이블 저장소
-   Azure Blob 저장소
-   Azure 드라이브
-   Azure 큐
-   Azure 서비스 버스 조정된 메시징
-   Hadoop과 같은 "빅데이터" 저장소 솔루션

자세한 내용은 상황에 따라 다를 수 있으므로 다음과 같은 시나리오를 기반으로 방법을 설명하겠습니다.

-   SQL 데이터베이스를 사용하는 Azure 클라우드 서비스
-   저장소 큐의 사용량이 매우 많은 Azure 클라우드 서비스
-   MySQL을 백엔드 데이터베이스로 사용하는 Azure 웹 사이트
-   "빅데이터" 응용 프로그램
-   MySQL 백엔드 데이터베이스를 사용하는 응용 프로그램

### 시나리오: 클라우드 서비스에서의 SQL 데이터베이스

훌륭한 데이터베이스 설계의 원칙은 대부분 Azure SQL 데이터베이스에도 적용됩니다. 효과적인 SQL Server 또는 Azure SQL 데이터베이스 스키마를 설계하는 방법을 설명하는 자료는 매우 방대하지만, SQL 데이터베이스 스키마 설계에 대한 몇 가지 참조 자료는 다음과 같습니다.

-   [데이터베이스 설계 및 모델링 기본 사항(영문)](http://go.microsoft.com/fwlink/?LinkId=252675)
-   [데이터베이스 설계 단계별 설명(영문)](http://go.microsoft.com/fwlink/?LinkId=252676)
-   [데이터베이스 설계(영문)](http://go.microsoft.com/fwlink/?LinkId=252677)

Azure에서 차별화되는 두 가지 주요 설계 활동은 다음과 같습니다.

-   데이터를 적절히 배치하기: 일부 관계형 데이터를 Azure Blob 또는 필요한 경우 Azure 테이블로 이동하는 것과 관련될 수 있습니다.
-   최대 확장성 보장: 데이터 분할 여부 및 방법을 결정합니다.

#### 데이터 아키텍처: SQL 데이터베이스의 외부로 데이터 이동

온-프레미스 SQL Server에 주로 상주하는 일부 데이터를 Azure 외부로 이동해야 합니다.

##### 데이터를 Azure Blob으로 이동

이미지나 문서 같은 Blob 데이터는 SQL 데이터베이스가 아니라 Azure Blob 저장소에 저장해야 합니다. 그런 데이터도 온-프레미스 SQL Server에 종종 저장되지만, 클라우드에서 Blob 저장소를 사용하는 편이 훨씬 저렴합니다. 일반적으로 Blob 데이터 검색 능력을 유지 관리하기 위해 Blob 데이터를 가리키는 외래 키를 Blob 저장소 식별자와 교체하게 되며, 데이터를 참조한 쿼리를 수정해야 합니다.

##### SQL 테이블을 Azure 테이블 저장소로 이동

Azure 테이블 저장소 사용 여부를 결정할 때에는 비용과 성능을 살펴보아야 합니다. 테이블 저장소를 사용하는 것이 SQL 데이터베이스에 동일한 데이터를 저장하는 것보다 훨씬 경제적입니다. 그러나 데이터에서 조인, 필터링, 쿼리 등 SQL의 관계형 기능을 어느 정도 사용할지를 신중하게 고려해야 합니다. 데이터에서 그런 기능을 거의 사용하지 않는다면 Azure 테이블의 저장소를 활용하는 것이 매우 효과적입니다.

테이블 저장소를 고려할 수 있는 한 가지 설계 패턴은 일반적인 AdventureWorks 샘플 데이터베이스의 Customers 테이블처럼 행이 많은 테이블입니다. 이 경우 Customers의 대다수가 아니라 소수의 하위 집합에서만 많은 열을 사용합니다. Customer와 두 번째 테이블 간에 선택적으로 1대 0 관계를 지정하여 열을 두 번째 테이블(CustomerMiscellany로 명명할 수 있음)로 분할하는 것이 일반적인 설계 패턴입니다. 두 번째 테이블을 테이블 저장소로 이동하는 것을 고려할 수 있습니다. 이렇게 할 경우 테이블의 크기와 액세스 패턴이 비용 효과적일지를 평가해야 합니다.

테이블 저장소에 대한 자세한 내용은 다음을 참조하십시오.

-   [Azure 테이블 저장소 및 Azure SQL 데이터베이스 - 비교 및 대조](http://msdn.microsoft.com/en-us/library/jj553018.aspx)
-   [Azure 테이블 저장소 성능 고려 사항(영문)](http://go.microsoft.com/fwlink/?LinkId=252663)
-   [SQL 데이터베이스 및 Azure 테이블 저장소(영문)](http://go.microsoft.com/fwlink/?LinkId=252664)
-   [Azure 테이블 저장소 삽입 일괄 처리로 성능 향상(영문)](http://go.microsoft.com/fwlink/?LinkID=252665). 이 문서에서는 몇 가지 성능 결과에 대해 설명합니다.
-   [SQL 데이터베이스 성과 및 탄력성 가이드(영문)](http://go.microsoft.com/fwlink/?LinkId=221876)

#### 데이터 분할

가장 자주 분할되는 리소스 중 하나는 데이터입니다. Azure 클라우드 서비스를 만드는 경우 페더레이션을 통해 사용 가능한 SQL 데이터베이스의 기본 제공 분할 기능을 사용하는 옵션을 고려해야 합니다.

SQL 데이터베이스 페더레이션의 개요를 보려면 [SQL 데이터베이스의 페더레이션](http://go.microsoft.com/fwlink/?LinkId=252668)을 참조하십시오.

##### SQL 페더레이션의 설계 작업

Azure 클라우드 서비스에서 SQL 데이터베이스 페더레이션을 사용하려면 기존의 설계 원칙 중 몇 가지를 수정해야 합니다. 그러나 훌륭한 온-프레미스 SQL Server 데이터베이스용 설계에 적용되는 대부분의 원칙은 SQL 데이터베이스 페더레이션 설계에 반드시 필요한 출발점입니다. 두 가지 주요 설계 작업은 다음을 결정하는 것입니다.

-   무엇을 페더레이션할지 결정

-   페더레이션되지 않은 테이블을 어디에 둘지 결정

무엇을 페더레이션할지 결정하려면 데이터베이스 스키마를 점검하고 관련 테이블의 집계를 식별해야 합니다. 집계는 외래 키를 통해 일대다 관계로 연결된 테이블의 집합입니다(집계의 루트 제외).

예를 들어, 잘 알려진 AdventureWorks 샘플 데이터베이스에서 가능한 집계 중 하나는 {Customer, Order, OrderLine 외 몇 가지} 집합입니다. 또 다른 가능한 집계의 예는 {Supplier, Product, OrderLine, Order}입니다.

각 집계는 페더레이션의 후보가 됩니다. 크기의 확장 가능성을 평가해야 하며 응용 프로그램의 작업도 검토해야 합니다. 페더레이션하는 스키마와 "잘 어울리는" 쿼리, 즉 둘 이상의 페더레이션 멤버로부터 데이터를 요청하지 않는 쿼리가 잘 실행됩니다. 잘 어울리지 않는 쿼리는 응용 프로그램 계층에서 논리를 요구하게 되는데, 이는 SQL 데이터베이스가 현재 데이터베이스 간 조인을 지원하지 않기 때문입니다.

페더레이션을 위해 AdventureWorks 데이터베이스를 점검하고 설계 관련 단계별 고려 사항을 제공하는 설계 분석의 예를 살펴보려면 [페더레이션을 이용한 데이터베이스 설계의 확장 우선 접근 방식: 1부 - 페더레이션 선택 및 페더레이션 키 선택](http://go.microsoft.com/fwlink/?LinkId=252671)(영문)을 참조하십시오.

페더레이션할 테이블을 결정했으면 집계 루트 테이블의 기본 키를 열로서 각각의 관련 테이블에 추가해야 합니다.

페더레이션할 테이블을 결정한 후에는 참조 테이블 및 기타 데이터베이스 개체를 어디에 둘 것인가 하는 문제를 해결해야 합니다. 자세한 내용은 이 주제를 완벽하게 다룬 [페더레이션을 이용한 데이터베이스 설계의 확장 우선 접근 방식: 2부 - 페더레이션용 스키마 주석 달기 및 배포](http://go.microsoft.com/fwlink/?LinkId=252672)(영문)를 참조하십시오. 고급 쿼리에 대한 더 많은 내용은 [2부](http://go.microsoft.com/fwlink/?LinkId=252673)에 설명되어 있습니다.

##### 직접 분할하기

데이터 분할 방법을 보여 주는 몇 가지 샘플이 있습니다. SQL 데이터베이스 인스턴스의 분할에 페더레이션을 사용하지 않으려는 경우 응용 프로그램에 적합한 분할 방법을 선택해야 합니다. 다음은 몇 가지 예제입니다.

-   페더레이션이 발표되기 전에 작성된 포괄적인 문서인 [SQL 데이터베이스 분할 방법](http://go.microsoft.com/fwlink/?LinkId=252678)(영문)
-   [SQL Server 및 SQL 분할된 데이터베이스 라이브러리(영문)](http://go.microsoft.com/fwlink/?LinkId=252679)

##### 기타 리소스 분할

SQL 데이터베이스 외의 다른 리소스도 분할할 수 있습니다. 예를 들면, 응용 프로그램 서버를 분할하여 각각 특정 데이터베이스 전용으로 사용할 수 있습니다. 응용 프로그램에 앱 서버 N개와 데이터베이스 N개가 포함되어 있다고 가정해보겠습니다. 각 앱 서버가 각 데이터베이스에 액세스할 수 있는 경우 N 제곱의 데이터베이스 연결이 사용되는데, 이렇게 되면 심각한 Azure 한계에 도달할 수 있습니다. 그러나 각 앱 서버를 소스의 데이터베이스로만 제한하면 사용되는 연결 수가 크게 줄어듭니다.

응용 프로그램에 따라 다른 리소스에도 비슷한 논리를 적용할 수 있습니다.

#### 캐싱

Azure 캐싱 서비스는 ASP.net 세션 상태 또는 SQL 데이터베이스 참조 테이블에서 일반적으로 참조되는 값 등을 캐시하기 위한 탄력적인 분산 메모리를 제공합니다. 개체가 분산 메모리에 있으므로 상당한 성능 향상을 누릴 수 있습니다. Azure에서 캐싱 인프라를 처리하므로 구현하는 데 개발비가 거의 들지 않습니다.

자주 액세스하는 개체를 캐시할 수 있도록 캐싱 용량을 충분히 제공할 수 있는 계획을 세우십시오. SQL 데이터베이스에는 숫자 코드를 좀 더 긴 설명 문자열로 변환하는 데 사용할 수 있는 자주 참조되는 테이블이 있습니다. 이러한 테이블에는 종종 국가와 도시 이름, 유효한 우편 번호 값, 회사 내 부서 이름 등이 포함됩니다. 좀 더 작은 테이블에는 캐시에 있는 전체 테이블을 저장할 수 있고, 나머지 테이블에는 가장 자주 사용하는 값만 저장할 수도 있습니다. 이 데이터를 포함하는 다중 조인 쿼리에서 성능 향상을 누릴 수 있습니다. 캐시에서 발견되는 각 값을 통해 여러 디스크 액세스가 줄어듭니다. Azure의 성능과 캐시에 대해 잘 소개하고 설명한 [Azure 캐싱 서비스 소개](http://go.microsoft.com/fwlink/?LinkId=252680)를 참조하십시오. 이 주제를 다룬 최신 블로그 게시물 [Windows \#Azure 캐싱 성능 고려 사항](http://go.microsoft.com/fwlink/?LinkId=252681)(영문)도 참조하실 수 있습니다.

#### 시나리오: Azure 응용 프로그램에서 큐 사용

이 시나리오의 예는 StreamInsight를 사용하여 큐를 나중에 처리될 메시지로 채우는 것입니다.

Azure 큐는 메시지를 전달하고, 하위 시스템을 일시적으로 분리하고, 부하 분산과 부하 평준화를 제공하는 데 사용됩니다.

Azure에는 두 가지 대체 큐 기술, 즉 Azure 저장소 큐 및 서비스 버스가 있습니다.

Azure 저장소 큐는 대규모 큐 크기, 진행 상황 추적 등의 기능을 제공합니다. 서비스 버스는 게시/구독, WCF(Windows Communication Foundation)와의 완전한 통합, 자동 중복 검색, FIFO(선입 선출) 배달 보장 등의 기능을 제공합니다.

두 가지 기술을 전체적으로 자세히 비교한 자료를 보려면 [Azure 큐 및 Azure 서비스 버스 큐 - 비교 및 대조](http://go.microsoft.com/fwlink/?LinkId=252682)를 참조하십시오.

서비스 버스 성능에 대한 자세한 내용은 [Service Bus 조정된 메시징을 사용한 성능 개선 모범 사례](http://go.microsoft.com/fwlink/?LinkID=252683)를 참조하십시오.

#### 시나리오: "빅데이터" 응용 프로그램

"빅데이터"는 다른 시스템이나 응용 프로그램의 부산물인 경우가 많습니다. 예를 들면 다음과 같습니다.

-   웹 로그

-   기타 진단, 감사 및 모니터링 파일

-   석유회사 지진 로그

-   인터넷을 탐색하는 사람들이 남긴 클릭 데이터 및 기타 정보

"빅데이터"는 다음과 같은 기준으로 식별할 수 있습니다.

-   크기(일반적으로 수백 테라바이트 이상)

-   유형: 비관계형, 가변 스키마, 파일 시스템의 파일

일반적으로 관계형 데이터베이스에서 처리하기에 적합한 데이터가 아닙니다.

비 SQL 데이터 저장소의 네 가지 주요 유형은 다음과 같습니다.

-   키-값

-   문서

-   그래프

-   열 패밀리(Column-Family)

Azure는 Hadoop을 직접 지원하며 기타 기술의 사용도 지원합니다. Azure HDInsight Service에 대한 자세한 내용은 다음을 참조하십시오.

-   [빅데이터](/en-us/solutions/big-data/)
-   [Azure HDInsight Service](/en-us/documentation/services/hdinsight/)
-   [Azure HDInsight Service 시작](/en-us/documentation/articles/hdinsight-get-started/)

다양한 noSQL 저장 방법과 관련된 문제를 다룬 다음과 같은 문서를 참조하십시오.

-   [Azure에서 NoSQL에 익숙해지기(영문)](http://go.microsoft.com/fwlink/?LinkId=252729)
-   [AggregateOrientedDatabase(영문)](http://go.microsoft.com/fwlink/?LinkID=252731)
-   [PolyglotPersistence(영문)](http://go.microsoft.com/fwlink/?LinkId=252732)

#### 기타 Azure 개별 서비스 성과 최적화

개별 Azure 서비스 중 다수는 성능에 크게 영향을 미칠 수 있는 기능과 설정을 가지고 있으므로 분석이 필요합니다.

##### Azure 드라이브

Windows Blob의 지원을 받으므로 개별 컴퓨터에 장애가 발생해도 지속적으로 운영되는 Azure 드라이브를 통해 기존 응용 프로그램의 하드 드라이브 사용법을 시뮬레이트할 수 있습니다.

##### 로컬 저장소

로컬 저장소는 컴퓨터 장애 시 지속적으로 운영되지는 못하지만 자주 액세스하는 정보를 저장하거나 다른 방법으로 사용할 중간 결과를 저장하는 데 사용할 수 있습니다. 사용에 비용이 들지 않으므로 경제적입니다.

##### Azure ACS(액세스 제어 서비스)

ACS 리소스 사용량에 영향을 미치고 따라서 성능에도 영향을 미치는 두 가지 주요 요소는 토큰 크기와 암호화입니다. 자세한 내용은 [ACS 성능 가이드라인](http://go.microsoft.com/fwlink/?LinkId=252747)(영문)을 참조하십시오.

##### 직렬화

직렬화는 성능 최적화에서 중요한 부분을 차지하지는 않지만, 몇몇 응용 프로그램 시나리오에서는 상당한 네트워크 트래픽 감소 효과를 볼 수 있습니다. 프로토콜에 따라 직렬화 크기가 어떻게 달라질 수 있는지 알아보려면 [Azure 웹 응용 프로그램 및 직렬화](http://go.microsoft.com/fwlink/?LinkId=252749)에서 설명하는 크기 감소 예제를 참조하십시오.

이동하는 데이터의 양이 성능 문제를 일으키는 경우 최대한 작은 직렬화를 사용하십시오. 직렬화 성능이 충분하지 않은 경우 사용자 지정 직렬화 형식 또는 Microsoft가 아닌 타사 직렬화 형식을 사용해보십시오. 늘 그렇듯이 개념 증명 테스트가 관건입니다.

### mySQL을 사용하는 Azure 웹 사이트

다음 링크에서는 MySQL의 성능 관련 정보를 얻을 수 있습니다.

-   [http://mysql.com](http://go.microsoft.com/fwlink/?LinkId=252775)에서 *performance*로 검색하면 많은 리소스를 찾을 수 있습니다.
-   [http://forums.mysql.com/list.php?24](http://go.microsoft.com/fwlink/?LinkId=252776)의 포럼에서도 참조할 만한 기타 리소스가 제공됩니다.

공유 시스템 설계
----------------

Azure는 여러 개의 동시 응용 프로그램을 실행하도록 설계되었으며, 여러 컴퓨터에서 장애 조치(Failover)를 위한 복제를 지원합니다. 이러한 기능은 여러 가지 면에서 응용 프로그램 성능에 영향을 미칩니다.

-   일시적인 연결

-   리소스의 최대 사용량 제한

-   네트워크 대기 시간

-   서비스의 물리적 위치

이러한 고려 사항은 Azure 데이터 센터의 물리적 인프라에 의해 결정되므로 모든 응용 프로그램 아키텍처에 적용됩니다. 자세한 내용은 [SQL 데이터베이스 성능 및 탄력성 가이드](http://go.microsoft.com/fwlink/?LinkID=252666)(영문)를 참조하십시오.

### 네트워크 대기 시간

Azure는 서비스 기반의 공유 리소스 플랫폼입니다. 즉, 두 가지 유형의 대기 시간 또는 중단이 규칙적으로 발생합니다. 첫 번째 유형은 요청을 보내고 인터넷을 통해 응답을 받는 데 걸리는 시간입니다. 이러한 요청과 응답은 클라이언트로 돌아오기까지 여러 라우터를 통과할 수 있으므로, 고정된 로컬 네트워크에 비해 시간 초과와 연결 해제가 빈번하게 발생합니다. 두 번째 유형은 Azure와 같은 공유 리소스 시스템이 내구성을 위해 데이터의 백업 버전을 만들고, 제거된 인스턴스에 대한 요청을 교체하고 경로를 전환하는 데 걸리는 시간입니다. 이러한 대기 시간과 실패는 응용 프로그램의 성능 요구 사항을 달성하기 위한 보완 방법을 이해하는 데 중요한 요소입니다. 실무 환경 수준에서 로드 테스트를 수행하면 대기 시간에 대해 더 자세히 알아볼 수 있습니다.

클라우드 데이터 센터는 온-프레미스 서버보다 물리적으로 더 떨어져 있을 가능성이 높기 때문에 대기 시간이 더 길어질 수 있음을 고려해야 합니다.

### 서비스의 물리적 위치

가능하면 동일한 데이터 센터 내에서 여러 노드 또는 응용 프로그램 계층을 함께 배치하십시오. 그렇지 않으면 네트워크 대기 시간과 비용이 증가할 수 있습니다.

예를 들어 동일한 데이터 센터에 있는 웹 응용 프로그램의 경우 다른 데이터 센터 또는 온-프레미스에 배치하기보다는 해당 응용 프로그램이 액세스하는 SQL 데이터베이스 인스턴스와 함께 배치하십시오.

### 일시적인 연결

응용 프로그램에서는 연결 끊김을 처리할 수 있어야 합니다. 연결 끊김은 클라우드 아키텍처에서 발생하는 본질적이고 불가피한 문제입니다(예: 데드 노드 교체, SQL 데이터베이스에서 페더레이션 멤버 분할 등). 현재 이 문제를 해결하기 위한 최고의 프레임워크는 [일시적인 오류 처리 응용 프로그램 블록](http://go.microsoft.com/fwlink/?LinkID=236901)(영문)입니다.

### 제한

서비스의 세계에서는 리소스를 매우 세분화할 수 있으며 사용한 만큼만 지불합니다. 그러나 모든 리소스에는 최소 보증 단위의 크기, 속도 또는 처리량이 있으며(예를 들어 특정 크기의 데이터베이스 이상이 필요한 경우 중요), 중요한 서비스에 대한 외부 제한이 있는 경우도 있습니다. Azure 응용 프로그램은 공유 환경에서 다른 응용 프로그램과 함께 실행되므로 Azure에서는 고려해야 할 여러 리소스 제한을 적용합니다. 리소스의 제한을 초과한 경우 해당 리소스를 추가로 요청하면 예외가 발생합니다.

### 물리적 용량

필요한 성능 계획 중 하나는 용량 계획입니다. 다양한 종류의 저장소를 충분히 제공하지 못하면 응용 프로그램을 실행하지 못할 수 있습니다. 마찬가지로 메모리나 프로세서의 용량이 적절하지 못하면 응용 프로그램의 실행 속도가 크게 저하될 수 있습니다.

Azure에서는 기존의 활동 중 다수(특히 컴퓨터 구매 및 프로비저닝)가 크게 변경되었으므로 용량 계획과 관련된 업무가 대폭 감소합니다. Azure에서는 용량 계획의 초점을 더 이상 컴퓨팅의 물리적 요소에 두지 않습니다. 대신 더 높은 추상화 수준에서 작업하며 다음이 얼마나 필요한지를 확인합니다.

-   컴퓨터 노드
-   Blob 저장소
-   테이블 저장소
-   큐 등

Azure의 확장성 덕분에 초기에 결정한 용량이 고정불변인 것은 아닙니다. Azure 리소스는 비교적 쉽게 확장 또는 축소할 수 있습니다. 그렇더라도 용량 계획을 정확히 세우는 것이 중요합니다. 그래야만 응용 프로그램이 라이브 상태가 될 때 용량과 관련된 시행착오 기간을 피할 수 있습니다.

리소스 요구 사항이 시간이 지남에 따라 심하게 변동하는 응용 프로그램에서는 [자동 크기 조정 응용 프로그램 블록](http://go.microsoft.com/fwlink/?LinkId=252873)(영문) 사용을 고려해보십시오. 이 블록을 사용하면 역할 인스턴스의 확장 및 축소에 대한 규칙을 설정할 수 있습니다. 다음과 같은 두 가지 종류의 규칙을 정의할 수 있습니다.

-   제약 조건 규칙 - 하루 중 일정 시간까지 최대/최소의 인스턴스 수를 설정합니다.

-   반응적 규칙 - CPU 사용량 % 등의 일부 조건이 충족될 때 발생합니다.

사용자 지정 규칙을 정의할 수도 있습니다. 자세한 내용은 [자동 크기 조정 응용 프로그램 블록](http://go.microsoft.com/fwlink/?LinkId=252873)(영문)을 참조하십시오.

용량 계획은 그 자체로도 매우 전문적인 분야이므로 이 문서에서는 용량 계획이 이미 완료된 것으로 가정합니다. Azure에서의 용량 계획에 대해 자세히 알아보려면 [서비스 버스 큐 및 항목에 대한 용량 계획](http://go.microsoft.com/fwlink/?LinkId=252875)을 참조하십시오.

런타임 시 성능 모니터링 및 조정
-------------------------------

아무리 신중하게 설계하더라도 런타임 시 성능 문제가 전혀 발생하지 않을 것이라고 보장할 수는 없습니다. 따라서 응용 프로그램 성능을 지속적으로 모니터링하고, 필요한 성능 메트릭을 달성하는지 확인하고, 그렇지 못할 경우 상황을 바로잡는 것이 필요합니다. 잘 설계된 응용 프로그램이라도 기하급수적인 사용량 증가 또는 런타임 환경에서 발생할 수 있는 변경 등 예기치 않은 상황의 영향을 받아 성능 문제가 발생할 수 있습니다. 이러한 경우에는 조정이 필요합니다. 병목 지점을 자주 확인하여 해결하는 것이 이 프로세스의 중요한 부분입니다.

런타임 시 성능 문제를 해결할 수 있으려면 선행 작업을 통해 로깅 및 적절한 예외 처리를 구축해야 합니다. 그래야만 문제가 발생할 때마다 적절히 해결할 수 있습니다. 이 분야에 대해 포괄적으로 알아보려면 [Azure 응용 프로그램 개발을 위한 문제 해결 모범 사례](http://go.microsoft.com/fwlink/?LinkID=252876)(영문)를 참조하십시오.

이러한 도구는 모든 Azure 서비스의 지속적인 성능을 모니터링하는 데 사용할 수 있습니다. 로깅 외에도 성능 문제를 해결하는 데 필요한 자세한 정보를 제공하는 기능을 응용 프로그램에 내장해야 합니다.

### SQL 데이터베이스

SQL 프로파일러는 현재 Azure에서 이용할 수 없습니다. 필요한 성능 정보를 얻기 위한 몇 가지 대안이 있습니다. 개발 중에 이용할 수 있는 한 가지 대안은 SQL 프로파일러가 사용 가능한 데이터베이스의 온-프레미스 버전에서 초기 테스트를 수행하는 것입니다.

SET STATISTICS Transact-SQL 명령을 사용할 수도 있고, SQL Server Management Studio를 사용하여 쿼리에 의해 생성되는 실행 계획을 볼 수도 있습니다. 효율적인 쿼리를 코딩하는 것이 성능에 매우 중요하기 때문입니다. 자세한 설명과 단계적인 수행 방법은 [SQL 데이터베이스에 대한 성능 정보 얻기](http://go.microsoft.com/fwlink/?LinkId=252877)(영문)를 참조하십시오. [SQL 데이터베이스와 SQL Server 온-프레미스 간 성능 분석](http://go.microsoft.com/fwlink/?LinkId=252878)(영문)에서 또 다른 흥미로운 접근 방법을 알아볼 수 있습니다.

동적 관리 뷰에 대한 두 가지 참고 자료는 다음과 같습니다.

-   [동적 관리 뷰를 사용하여 SQL 데이터베이스 모니터링](http://go.microsoft.com/fwlink/?LinkId=236195)
-   [SQL 프로파일러가 없는 경우 SQL 데이터베이스 분석에 유용한 DMV(영문)](http://go.microsoft.com/fwlink/?LinkId=252879)

### 분석 리소스 및 도구

Azure 성능 분석에 Microsoft 이외의 여러 타사 도구를 사용할 수 있습니다.

-   [Cerebrata](http://go.microsoft.com/fwlink/?LinkId=252880)
-   [SQL Server 및 SQL 데이터베이스 성능 테스트: Enzo SQL 기본(영문)](http://enzosqlbaseline.codeplex.com/)

기타 리소스

-   [SQL 데이터베이스 성과 및 탄력성 가이드(영문)](http://go.microsoft.com/fwlink/?LinkID=252666)
-   [SQL 데이터베이스](http://go.microsoft.com/fwlink/?LinkId=246930)
-   [저장소](http://go.microsoft.com/fwlink/?LinkId=246933)
-   [네트워킹](http://go.microsoft.com/fwlink/?LinkId=252882)
-   [서비스 버스](http://go.microsoft.com/fwlink/?LinkId=246934)
-   [Azure 계획 - 환경에 Azure를 통합하기 위한 사후 결정 가이드(영문)](http://go.microsoft.com/fwlink/?LinkId=252884)

