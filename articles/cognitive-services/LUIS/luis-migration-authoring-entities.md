---
title: V3 머신 학습 엔터티로 마이그레이션
titleSuffix: Azure Cognitive Services
description: V3 작성은 기계 학습된 엔터티 와 응용 프로그램의 다른 엔터티 또는 기능에 관계를 추가하는 기능과 함께 하나의 새 엔터티 유형인 기계 학습 엔터티를 제공합니다.
services: cognitive-services
author: diberry
manager: nitinme
ms.service: cognitive-services
ms.subservice: language-understanding
ms.topic: conceptual
ms.date: 12/30/2019
ms.author: diberry
ms.openlocfilehash: b5dbcd9033d9a41e43ea907d043e0c0486b236db
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/28/2020
ms.locfileid: "75563852"
---
# <a name="migrate-to-v3-authoring-entity"></a>V3 작성 엔터티로 마이그레이션

V3 작성은 기계 학습된 엔터티 와 응용 프로그램의 다른 엔터티 또는 기능에 관계를 추가하는 기능과 함께 하나의 새 엔터티 유형인 기계 학습 엔터티를 제공합니다.

## <a name="entities-are-decomposable-in-v3"></a>V3에서 엔터티를 분해할 수 있습니다.

[Api를](https://westeurope.dev.cognitive.microsoft.com/docs/services/luis-programmatic-apis-v3-0-preview) 사용하거나 [미리 보기 포털을](https://preview.luis.ai/)사용하여 V3 작성 API로 만든 엔터티를 사용하면 부모 및 자식이 있는 계층화된 엔터티 모델을 빌드할 수 있습니다. 부모는 **기계 학습 엔터티로** 알려져 있으며 자식은 학습된 컴퓨터 엔터티의 **하위 구성 요소라고** 합니다.

각 하위 구성 요소는 기계 학습 엔터티이기도 하지만 제약 조건 및 설명자의 추가 된 구성 옵션입니다.

* **제약 조건은** 규칙과 일치할 때 엔터티가 추출되도록 보장하는 정확한 텍스트 일치 규칙입니다. 규칙은 현재 [미리 빌드된 엔터티,](luis-reference-prebuilt-entities.md) [정규식 엔터티](reference-entity-regular-expression.md)또는 [목록 엔터티와](reference-entity-list.md)같은 정확한 텍스트 일치 엔터티에 의해 정의됩니다.
* **설명자는 엔터티를** 강력하게 나타내는 데 사용되는 구 목록 또는 엔터티와 같은 [기능입니다.](luis-concept-feature.md)

V3 작성은 기계 학습된 엔터티 와 응용 프로그램의 다른 엔터티 또는 기능에 관계를 추가하는 기능과 함께 하나의 새 엔터티 유형인 기계 학습 엔터티를 제공합니다.

## <a name="how-do-these-new-relationships-compare-to-v2-authoring"></a>이러한 새 관계는 V2 작성과 어떻게 비교합니까?

V2 작성은 이 같은 작업을 수행하는 역할 및 기능과 함께 계층및 복합 엔터티를 제공했습니다. 엔터티, 기능 및 역할이 서로 명시적으로 관련되지 않았기 때문에 LUIS가 예측 하는 동안 관계를 암시하는 방법을 이해하기가 어려웠습니다.

V3을 사용하면 앱 작성자는 관계를 명시적으로 지정하고 디자인합니다. 이렇게 하면 앱 작성자로서 다음을 수행할 수 있습니다.

* 예제 발언에서 LUIS가 이러한 관계를 예측하는 방법을 시각적으로 볼 수 있습니다.
* [대화형 테스트 창](luis-interactive-test.md) 또는 끝점에서 이러한 관계를 테스트합니다.
* 클라이언트 응용 프로그램에서 잘 구성된 중첩된 [.json 개체를](reference-entity-machine-learned-entity.md) 사용하여 이러한 관계를 사용합니다.

## <a name="planning"></a>계획

마이그레이션할 때 마이그레이션 계획에서 다음을 고려하십시오.

* LUIS 앱을 백업하고 별도의 앱에서 마이그레이션을 수행합니다. V2 및 V3 앱을 동시에 사용할 수 있으면 필요한 변경 내용과 예측 결과에 미치는 영향을 확인할 수 있습니다.
* 현재 예측 성공 메트릭 캡처
* 앱 상태의 스냅샷으로 현재 대시보드 정보 캡처
* 기존 의도, 엔터티, 구 목록, 패턴 및 일괄 처리 테스트 검토
* 다음 요소는 **변경 없이**마이그레이션할 수 있습니다.
    * 의도
    * 엔터티
        * 정규식 엔터티
        * 목록 엔터티
    * 기능
        * 구문 목록
* 다음 요소는 **변경 내용으로**마이그레이션해야 합니다.
    * 엔터티
        * 계층적 엔터티
        * 복합 엔터티
    * 역할 - 역할은 기계 학습(상위) 엔터티에만 적용할 수 있습니다. 하위 구성 요소에는 역할을 적용할 수 없습니다.
    * 계층 및 복합 엔터티를 사용하는 일괄 처리 테스트 및 패턴

마이그레이션 계획을 디자인할 때 모든 계층 및 복합 엔터티가 마이그레이션된 후 최종 기계 학습 엔터티를 검토할 시간을 둡니다. 직선 마이그레이션이 작동하지만 일괄 처리 테스트 결과 및 예측 JSON을 변경하고 검토한 후 JSON을 통합할수록 클라이언트 측 앱에 전달되는 최종 정보가 다르게 구성되도록 변경할 수 있습니다. 이는 코드 리팩터링과 유사하며 조직에서 시행하는 것과 동일한 검토 프로세스로 처리해야 합니다.

V2 모델에 대한 일괄 처리 테스트가 없고 마이그레이션의 일부로 일괄 처리 테스트를 V3 모델로 마이그레이션하는 경우 마이그레이션이 엔드포인트 예측 결과에 미치는 영향을 확인할 수 없습니다.

## <a name="migrating-from-v2-entities"></a>V2 엔터티에서 마이그레이션

V3 작성 모델로 이동하기 시작하면 기계 학습 엔터티및 제약 조건 및 설명기를 포함한 하위 구성 요소로 이동하는 방법을 고려해야 합니다.

다음 표는 V2에서 V3 엔터티 디자인으로 마이그레이션해야 하는 엔터티를 나타냅니다.

|V2 작성 엔터티 유형|V3 작성 엔터티 유형|예제|
|--|--|--|
|복합 엔터티|기계 학습 엔터티|[더 알아보세요](#migrate-v2-composite-entity)|
|계층적 엔터티|기계 학습 된 엔터티의 역할|[더 알아보세요](#migrate-v2-hierarchical-entity)|

## <a name="migrate-v2-composite-entity"></a>V2 복합 엔터티 마이그레이션

V2 컴포지토리의 각 자식은 V3 컴퓨터 학습 엔터티의 하위 구성 요소로 표시되어야 합니다. 복합 자식이 미리 빌드된, 정규식 또는 목록 엔터티인 경우 이 엔터티는 자식을 나타내는 하위 구성 요소에 대한 **제약 조건으로** 적용되어야 합니다.

복합 엔터티를 기계 학습 엔터티로 마이그레이션할 계획일 때 고려해야 합니다.
* 패턴에서 자식 엔터티를 사용할 수 없습니다.
* 자식 엔터티가 더 이상 공유되지 않습니다.
* 하위 엔터티는 기계 학습되지 않은 경우 레이블을 지정해야 합니다.

### <a name="existing-descriptors"></a>기존 설명자

복합 엔터티에서 단어를 향상시키는 데 사용되는 모든 구 목록은 기계 학습(상위) 엔터티, 하위 구성 요소(하위) 엔터티 또는 의도(구 목록이 하나의 의도에만 적용되는 경우)에 대한 설명자로 적용되어야 합니다. 가장 크게 향상해야 하는 엔터티에 설명기를 추가하도록 계획합니다. 하위 구성 요소(하위)의 예측을 크게 향상시키는 경우 일반적으로 컴퓨터 학습(상위) 엔터티에 설명기를 추가하지 마십시오.

### <a name="new-descriptors"></a>새 설명자

V3 작성에서 계획 단계를 추가하여 엔터티를 모든 엔터티 및 의도에 대해 가능한 설명자로 평가합니다.

### <a name="example-entity"></a>예제 엔터티

이 엔터티는 예제일 뿐입니다. 고유한 엔터티 마이그레이션에는 다른 고려 사항이 필요할 수 있습니다.

다음을 사용하는 피자를 `order` 수정하기 위한 V2 합성을 고려하십시오.
* 배달 시간에 대 한 미리 빌드된 datetimeV2
* 피자, 파이, 크러스트, 토핑 과 같은 특정 단어를 향상시키기 위한 문구 목록
* 버섯, 올리브, 페퍼로니 와 같은 토핑을 감지하는 목록 엔티티.

이 엔터티에 대한 예는 다음과 같은 경우입니다.

`Change the toppings on my pie to mushrooms and delivery it 30 minutes later`

다음 표에서는 마이그레이션을 보여 줍니다.

|V2 모델|V3 모델|
|--|--|
|부모 - 명명된 구성 요소 엔터티`Order`|부모 - 기계 학습 엔터티라는 이름`Order`|
|자식 - 미리 빌드된 날짜시간V2|* 미리 빌드된 엔터티를 새 앱으로 마이그레이션합니다.<br>* 미리 빌드된 날짜시간V2에 대한 부모에 제약 조건을 추가합니다.|
|자식 - 토핑에 대한 목록 엔터티|* 목록 엔터티를 새 앱으로 마이그레이션합니다.<br>* 그런 다음 목록 엔터티에 대한 부모에 제약 조건을 추가합니다.|


## <a name="migrate-v2-hierarchical-entity"></a>V2 계층 적 엔터티 마이그레이션

V2 작성에서 LUIS에 있는 역할 전에 계층 적 엔터티가 제공되었습니다. 둘 다 컨텍스트 사용량에 따라 엔터티를 추출하는 동일한 목적을 제공했습니다. 계층 적 엔터티가 있는 경우 역할이 있는 간단한 엔터티로 생각할 수 있습니다.

V3 작성시:
* 기계 학습(상위) 엔터티에 역할을 적용할 수 있습니다.
* 하위 구성 요소에는 역할을 적용할 수 없습니다.

이 엔터티는 예제일 뿐입니다. 고유한 엔터티 마이그레이션에는 다른 고려 사항이 필요할 수 있습니다.

피자를 `order`수정하기 위한 V2 계층 적 엔터티를 고려하십시오.
* 각 어린이가 원래 토핑 또는 최종 토핑을 결정하는 위치

이 엔터티에 대한 예는 다음과 같은 경우입니다.

`Change the topping from mushrooms to olives`

다음 표에서는 마이그레이션을 보여 줍니다.

|V2 모델|V3 모델|
|--|--|
|부모 - 명명된 구성 요소 엔터티`Order`|부모 - 기계 학습 엔터티라는 이름`Order`|
|자식 - 원본 및 최종 피자 토핑이 있는 계층적 엔터티|* 각 `Order` 토핑에 대한 역할을 추가합니다.|

## <a name="next-steps"></a>다음 단계

* [개발자 리소스](developer-reference-resource.md)
