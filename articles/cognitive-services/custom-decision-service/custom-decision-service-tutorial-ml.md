---
title: '자습서: 기능 개발 및 기능 사양 - Custom Decision Service'
titlesuffix: Azure Cognitive Services
description: Custom Decision Service의 기계 학습 기능 개발 및 기능 사양에 대한 자습서입니다.
services: cognitive-services
author: slivkins
manager: cgronlun
ms.service: cognitive-services
ms.component: custom-decision-service
ms.topic: tutorial
ms.date: 05/08/2018
ms.author: slivkins
ms.openlocfilehash: 1e5d012706d1de5a201eecb8ad805b4d6faaf411
ms.sourcegitcommit: 0bb8db9fe3369ee90f4a5973a69c26bff43eae00
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/08/2018
ms.locfileid: "48869593"
---
# <a name="tutorial-featurization-and-feature-specification"></a>자습서: 기능 개발 및 기능 사양

이 자습서에서는 Custom Decision Service의 고급 Machine Learning 기능에 대해 설명합니다. 자습서는 [기능 개발](#featurization-concepts-and-implementation) 및 [기능 사양](#feature-specification-format-and-apis)의 두 부분으로 구성되어 있습니다. 기능 개발은 Machine Learning을 위한 “기능”으로 데이터를 나타내는 것을 가리킵니다. 기능 사양은 기능을 지정하는 데 필요한 보조 API 및 JSON 형식을 다룹니다.

기본적으로 Custom Decision Service의 Machine Learning은 고객에게 투명합니다. 콘텐츠에서 자동으로 기능이 추출되고, 표준 보충 학습 알고리즘이 사용됩니다. 기능 추출은 [엔터티 링크 설정](../entitylinking/home.md), [텍스트 분석](../text-analytics/overview.md), [Emotion](../emotion/home.md), [Computer Vision](../computer-vision/home.md) 등 다른 여러 Azure Cognitive Services를 활용합니다. 기본 기능만 사용하는 경우 이 자습서를 건너뛰어도 됩니다.

## <a name="featurization-concepts-and-implementation"></a>기능 개발: 개념 및 구현

Custom Decision Service는 하나씩 결정을 내립니다. 각 결정에는 여러 가지 대안(예: 작업) 중에서 선택하는 과정이 포함됩니다. 애플리케이션에 따라 결정은 단일 작업 또는 순위가 지정된(짧은) 작업 목록을 선택할 수 있습니다.

예를 들어 웹 사이트의 앞 페이지에 표시되는 기사 선택을 개인 설정할 수 있습니다. 여기서 작업은 기사에 해당하고, 각 결정은 지정된 사용자에게 표시할 기사입니다.

각 작업은 속성 벡터로 표현되므로, 앞으로 *기능*이라고 부르겠습니다. 자동으로 추출된 기능 외에 새 기능을 지정할 수 있습니다. Custom Decision Service에 일부 기능을 기록하되 Machine Learning에서는 무시하도록 지정할 수도 있습니다.

### <a name="native-vs-internal-features"></a>기본 기능 및 내부 기능

애플리케이션에 가장 자연스러운 형식으로 기능을 지정할 수 있으며 숫자, 문자열 또는 배열일 수 있습니다. 이러한 기능을 “기본 기능”이라고 합니다. Custom Decision Service는 각 기본 기능을 “내부 기능”이라는 하나 이상의 숫자 기능으로 변환합니다.

내부 기능으로의 변환은 다음과 같이 수행됩니다.

- 숫자 기능은 동일하게 유지됩니다.
- 숫자 배열은 배열의 각 요소당 하나씩, 여러 숫자 기능으로 변환됩니다.
- 문자열 값 기능인 `"Name":"Value"`는 기본적으로 이름이 `"NameValue"`이고 값이 1인 기능으로 변환됩니다.
- 필요에 따라 문자열을 [단어 모음](https://en.wikipedia.org/wiki/Bag-of-words_model)으로 표현할 수 있습니다. 그런 다음, 문자열의 각 단어에 대해 내부 기능이 생성되며 해당 값은 이 단어의 발생 횟수입니다.
- 값이 0인 내부 기능은 생략됩니다.

### <a name="shared-vs-action-dependent-features"></a>공유 기능 및 작업 종속 기능

일부 기능은 전체 결정을 가리키며, 모든 작업에서 동일합니다. 이러한 기능을 *공유 기능*이라고 합니다. 다른 일부 기능은 특정 작업과 관련이 있습니다. 이러한 기능을 ADF(*작업 종속 기능*)라고 합니다.

실행 중인 예제에서 공유 기능은 사용자 및/또는 세계의 상태를 설명할 수 있습니다. 사용자의 지리적 위치, 연령 및 성별과 같은 기능과 현재 발생 중인 주요 이벤트입니다. 작업 종속 기능은 이 문서에서 다루는 토픽 등 지정된 문서의 속성을 설명할 수 있습니다.

### <a name="interacting-features"></a>상호 작용하는 기능

기능은 “상호 작용”하는 경우가 많습니다. 한 기능의 효과가 다른 기능에 따라 달라집니다. 예를 들어 X 기능은 사용자가 스포츠에 관심이 있는지 여부입니다. Y 기능은 지정된 문서가 스포츠 관련 문서인지 여부입니다. 이 경우 Y 기능의 효과는 X 기능에 매우 종속됩니다.

X 기능과 Y 기능 간의 상호 작용을 고려하려면 값이 X\*Y인 *정방형* 기능을 만듭니다. X와 Y의 “교차”라고도 합니다. 교차되는 기능 쌍을 선택할 수 있습니다.

> [!TIP]
> 순위에 영향을 주려면 공유 기능이 작업 종속 기능과 교차되어야 합니다. 개인 설정에 기여하려면 작업 종속 기능이 공유 기능과 교차되어야 합니다.

즉, ADF와 교차되지 않은 공유 기능은 각 작업에 동일한 방식으로 영향을 줍니다. 공유 기능과 교차되지 않은 ADF는 각 결정에도 영향을 줍니다. 이러한 유형의 기능은 보상 예상의 분산을 줄일 수 있습니다.

### <a name="implementation-via-namespaces"></a>네임스페이스를 통한 구현

포털에서 “VW 명령줄”을 통해 교차된 기능(및 기타 기능 개발 개념)을 구현할 수 있습니다. 구문은 [Vowpal Wabbit](http://hunch.net/~vw/) 명령줄을 기반으로 합니다.

이 구현은 명명된 기능 하위 집합인 *네임스페이스* 개념을 중심으로 합니다. 각 기능은 정확히 하나의 네임스페이스에 속합니다. 기능 값이 Custom Decision Service에 제공되면 네임스페이스를 명시적으로 지정할 수 있습니다. VW 명령줄에서 기능을 참조하는 유일한 방법입니다.

네임스페이스는 “공유” 또는 “작업 종속”입니다. 즉, 공유 기능만으로 구성되거나 동일한 작업의 작업 종속 기능만으로 구성됩니다.

> [!TIP]
> 명시적으로 지정된 네임스페이스에 기능을 래핑하는 것이 좋습니다. 관련 기능을 동일한 네임스페이스에 그룹화합니다.

네임스페이스가 제공되지 않은 경우에는 기능이 기본 네임스페이스에 자동으로 할당됩니다.

> [!IMPORTANT]
> 기능과 네임스페이스가 작업 전체에서 일치할 필요는 없습니다. 특히, 네임스페이스는 작업마다 다른 기능을 가질 수 있습니다. 또한 일부 작업에 대해서만 지정된 네임스페이스를 정의하고 다른 작업에 대해서는 정의하지 않을 수 있습니다.

동일한 문자열 값 기본 기능에서 나온 여러 개의 내부 기능은 동일한 네임스페이스로 그룹화됩니다. 서로 다른 네임스페이스에 있는 두 개의 기본 기능은 기능 이름이 같더라도 별개로 처리됩니다.

> [!IMPORTANT]
> 길고 설명적인 네임스페이스 ID가 일반적이지만, VW 명령줄은 ID가 동일한 문자로 시작하는 네임스페이스를 구분하지 않습니다. 뒤에 나오는 내용에서 네임스페이스 ID는 `x` 및 `y`와 같은 단일 문자입니다.

구현 정보는 다음과 같습니다.

- `x` 및 `y` 네임스페이스를 교차하려면 `-q xy` 또는 `--quadratic xy`를 작성합니다. 그러면 `x`의 각 기능이 `y`의 각 기능과 교차됩니다. `-q x:`를 사용하여 `x`를 모든 네임스페이스와 교차하고, `-q ::`를 사용하여 모든 네임스페이스 쌍을 교차합니다.

- `x` 네임스페이스의 모든 기능을 무시하려면 `--ignore x`를 작성합니다.

이러한 명령은 네임스페이스를 정의할 때마다 각 작업에 개별적으로 적용됩니다.

### <a name="estimated-average-as-a-feature"></a>예상 평균(기능)

사고 실험으로, 모든 결정에 대해 선택할 경우 지정된 작업의 평균 보상은 어느 정도일까요? 이러한 평균 보상은 이 작업의 “전반적인 품질” 측정값으로 사용할 수 있습니다. 일부 결정에서 다른 작업이 대신 선택될 때마다 이러한 사실을 정확하게 알 수 없습니다. 그러나 보충 학습 기술을 통해 예상은 가능합니다. 이 예상의 품질은 일반적으로 시간에 따라 향상됩니다.

지정된 작업에 대한 기능으로 이 “예상 평균 보상”을 포함할 수 있습니다. 그러면 새 데이터가 도착할 경우 Custom Decision Service에서 이 예상을 자동으로 업데이트합니다. 이 기능을 이 작업의 *한계 기능*이라고 합니다. 한계 기능은 Machine Learning 및 감사에 사용할 수 있습니다.

한계 기능을 추가하려면 VW 명령줄에 `--marginal <namespace>`를 작성합니다. JSON에서 `<namespace>`를 다음과 같이 정의합니다.

```json
{<namespace>: {"mf_name":1 "action_id":1}
```

지정된 작업의 다른 작업 종속 기능과 함께 이 네임스페이스를 삽입합니다. 모든 결정에 대해 동일한 `mf_name` 및 `action_id`를 사용하여 각 결정에 이 정의를 제공합니다.

한계 기능은 `<namespace>`와 함께 각 작업에 대해 추가됩니다. `action_id`는 작업을 고유하게 식별하는 임의 기능 이름일 수 있습니다. 기능 이름은 `mf_name`으로 설정됩니다. 특히, `mf_name`이 서로 다른 한계 기능은 다른 기능으로 처리됩니다. 각 `mf_name`에 대해 다른 가중치가 학습됩니다.

기본 사용법은 모든 작업에 대해 동일한 `mf_name`을 사용하는 것입니다. 그러면 모든 한계 기능에 대해 하나의 가중치가 학습됩니다.

동일한 작업에 대해 값은 동일하고 기능 이름만 다른 여러 개의 한계 기능을 지정할 수도 있습니다.

```json
{<namespace>: {"mf_name1":1 "action_id":1 "mf_name2":1 "action_id":1}}
```

### <a name="1-hot-encoding"></a>1-핫 인코딩

일부 기능을 비트 벡터로 나타낼 수 있습니다. 여기서 각 비트는 가능한 값의 범위에 해당합니다. 이 비트는 기능이 이 범위에 있는 경우에만 1로 설정됩니다. 따라서 1로 설정된 “핫” 비트는 하나뿐이고, 나머지 비트는 0으로 설정됩니다. 일반적으로 이 표현을 *1-핫 인코딩*이라고 합니다.

1-핫 인코딩은 본질적으로 의미 있는 숫자 표현이 없는 “지역” 등의 범주 기능에서 주로 사용됩니다. 보상에 대한 영향이 비선형일 가능성이 큰 숫자 기능에도 도움이 됩니다. 예를 들어 지정된 문서가 특정 연령 그룹과 관련이 있고, 더 젊거나 나이든 사람과는 관련이 없을 수 있습니다.

모든 문자열 값 기능은 기본적으로 1-핫으로 인코드됩니다. 가능한 모든 값에 대해 별도의 내부 기능이 생성됩니다. 사용자 지정 범위가 있는, 숫자 기능에 대한 자동 1-핫 인코딩은 현재 제공되지 않습니다.

> [!TIP]
> Machine Learning 알고리즘은 공통 “가중치”를 통해 지정된 내부 기능의 모든 가능한 값을 균일한 방식으로 처리합니다. 1-핫 인코딩을 사용하면 각 값 범위에 대해 별도의 “가중치”를 지정할 수 있습니다. 범위를 더 작게 설정하면 충분한 데이터가 수집된 후 보상이 향상되지만, 더 나은 보상을 위해 수렴해야 하는 데이터 양이 늘어날 수 있습니다.

## <a name="feature-specification-format-and-apis"></a>기능 사양: 형식 및 API

여러 보조 API를 통해 기능을 지정할 수 있습니다. 모든 API는 공통 JSON 형식을 사용합니다. 다음은 개념 수준의 API 및 형식입니다. 사양은 Swagger 스키마를 통해 보완됩니다.

기능 사양에 대한 기본 JSON 템플릿은 다음과 같습니다.

```json
{
"<name>":<value>, "<name>":<value>, ... ,
"namespace1": {"<name>":<value>, ... },
"namespace2": {"<name>":<value>, ... },
...
}
```

`<name>` 및 `<value>`는 각각 기능 이름과 기능 값을 나타냅니다. `<value>`는 문자열, 정수, float, 부울 또는 배열일 수 있습니다. 네임스페이스에 래핑되지 않은 기능은 기본 네임스페이스에 자동으로 할당됩니다.

문자열을 단어 모음으로 표현하려면 `"<name>":<value>` 대신 특수 구문 `"_text":"string"`을 사용합니다. 실제로는 문자열의 각 단어에 대해 별도의 내부 기능이 생성됩니다. 해당 값은 이 단어의 발생 횟수입니다.

`<name>`이 “_”로 시작하고 `"_text"`가 아닌 경우에는 기능이 무시됩니다.

> [!TIP]
> 여러 JSON 원본의 기능을 병합하는 경우도 있습니다. 편의상 다음과 같이 나타낼 수 있습니다.
>
> ```json
> {
> "source1":<features>,
> "source2":<features>,
> ...
> }
> ```

여기서 `<features>`는 이전에 정의된 기본 기능 사양을 나타냅니다. 더 깊은 수준의 “중첩”도 허용됩니다. Custom Decision Service는 `<features>`로 해석될 수 있는 “가장 깊은” JSON 개체를 자동으로 찾습니다.

#### <a name="feature-set-api"></a>기능 집합 API

기능 집합 API는 앞에서 설명한 JSON 형식으로 기능 목록을 반환합니다. 여러 개의 기능 집합 API 엔드포인트를 사용할 수 있습니다. 각 엔드포인트는 기능 집합 ID와 URL로 식별됩니다. 기능 집합 ID와 URL 간의 매핑은 포털에서 설정됩니다.

JSON에서 적절한 위치에 해당 기능 집합 ID를 삽입하여 기능 집합 API를 호출합니다. 작업 종속 기능의 경우 작업 ID를 통해 호출이 자동으로 매개 변수화됩니다. 동일한 작업에 대해 여러 개의 기능 집합 ID를 지정할 수 있습니다.

#### <a name="action-set-api-json-version"></a>작업 집합 API(JSON 버전)

작업 집합 API에는 JSON에서 작업과 기능이 지정되는 버전이 있습니다. 기능은 명시적으로 및/또는 기능 집합 API를 통해 지정할 수 있습니다. 공유 기능은 모든 작업에 대해 한 번 지정할 수 있습니다.

#### <a name="ranking-api-http-post-call"></a>순위 API(HTTP POST 호출)

순위 API에는 HTTP POST 호출을 사용하는 버전이 있습니다. 이 호출의 본문은 유연한 JSON 구문을 통해 작업과 기능을 지정합니다.

작업은 명시적으로 및/또는 작업 집합 API를 통해 지정할 수 있습니다. 작업 집합 ID가 발견될 때마다 해당 작업 집합 API 엔드포인트에 대한 호출이 실행됩니다.

작업 집합 API의 경우 명시적으로 및/또는 기능 집합 API를 통해 기능을 지정할 수 있습니다. 공유 기능은 모든 작업에 대해 한 번 지정할 수 있습니다.