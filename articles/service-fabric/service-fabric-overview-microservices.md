---
title: Azure의 마이크로 서비스 소개
description: 마이크로 서비스 접근 방식을 통해 클라우드 애플리케이션을 빌드하는 것이 왜 현대 애플리케이션 개발에서 중요하며 Azure Service Fabric이 어떻게 이를 위한 플랫폼을 제공하는지에 대한 개요
ms.topic: conceptual
ms.date: 01/07/2020
ms.custom: sfrev
ms.openlocfilehash: af18a6cb45808c0af5ec2782a3fd2100e3b7bf99
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/27/2020
ms.locfileid: "75750625"
---
# <a name="why-use-a-microservices-approach-to-building-applications"></a>응용 프로그램 빌드에 마이크로 서비스 접근 방식을 사용하는 이유

소프트웨어 개발자의 경우 응용 프로그램을 구성 요소 부분으로 팩터링하는 것은 새로운 것이 없습니다. 일반적으로 백 엔드 저장소, 중간 계층 비즈니스 논리 및 프런트 엔드 사용자 인터페이스(UI)를 사용하는 계층화 된 접근 방식이 사용됩니다. 지난 몇 년 동안 *변경된* 점은 개발자가 클라우드용 분산 응용 프로그램을 빌드하고 있다는 것입니다.

다음은 변화하는 비즈니스 요구 사항입니다.

* 새로운 지리적 지역의 고객에게 도달하기 위해 대규모로 구축 및 운영되는 서비스입니다.
* 민첩한 방식으로 고객의 요구에 대응할 수 있는 기능 및 기능을 더 빠르게 제공합니다.
* 리소스 사용률 향상으로 비용을 줄여야 합니다.

이러한 비즈니스 요구가 애플리케이션을 구축하는 *방식* 에 영향을 미칩니다.

마이크로 서비스에 대한 Azure 접근 방식에 대한 자세한 내용은 [마이크로 서비스: 클라우드에서 제공하는 응용 프로그램 혁명을](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/)참조하십시오.

## <a name="monolithic-vs-microservices-design-approach"></a>모놀리식 대 마이크로 서비스 설계 접근 방식

모든 애플리케이션은 시간에 따라 진화합니다. 성공적인 애플리케이션은 사람들에게 유용하게 되어 진화합니다. 실패한 응용 프로그램은 진화하지 않으며 결국 더 이상 사용되지 않습니다. 여기에 질문이 있습니다 : 당신은 당신의 요구 사항에 대해 얼마나 알고 오늘과 그들이 미래에 있을 거야? 예를 들어 회사의 부서에 대한 보고 응용 프로그램을 빌드한다고 가정해 보겠습니다. 응용 프로그램이 회사의 범위 내에서만 적용되며 보고서가 오래 보관되지 않는다는 것을 확신할 수 있습니다. 수천만 명의 고객에게 비디오 콘텐츠를 제공하는 서비스를 구축하는 것과 는 다른 접근 방식입니다.

때로는 개념 증명으로 문 밖으로 무언가를 얻는 것이 원동력입니다. 나중에 응용 프로그램을 다시 디자인할 수 있습니다. 결코 사용되지 않는 오버 엔지니어링 에는 별 의미가 없습니다. 반면, 기업이 클라우드를 구축할 때 기대는 성장과 사용량입니다. 성장과 규모는 예측할 수 없습니다. 우리는 미래의 성공을 처리할 수 있는 길을 걷고 있다는 것을 알면서도 빠르게 프로토타입을 제작하고자 합니다. 이것이 구축, 측정, 학습, 반복으로 이루어진 간결한 시작 접근 방식입니다.

클라이언트/서버 시대에는 각 계층의 특정 기술을 사용하여 계층화 된 응용 프로그램을 빌드하는 데 중점을 두는 경향이 있었습니다. 이러한 접근 방식을 설명하기 위해 *모놀리식* 응용 이라는 용어가 등장했습니다. 인터페이스가 계층 사이에 속하는 경향이 있기 때문에 각 계층 내의 구성 요소 사이에는 더 긴밀히 연결된 설계가 적용되었습니다. 개발자는 라이브러리로 컴파일되어 몇 가지 실행 파일 및 DLL에 함께 연결된 클래스를 설계하고 팩터링했습니다.

모놀리식 디자인 접근 방식에는 이점이 있습니다. 모놀리식 응용 프로그램은 설계가 더 간단하며 이러한 호출은 종종 IPC(프로세스 간 통신)를 통해 호출되기 때문에 구성 요소 간의 호출이 더 빠릅니다. 또한 모든 사람이 인적 자원을 보다 효율적으로 사용하는 경향이 있는 단일 제품을 테스트합니다. 단점은 계층화 된 레이어 간에 긴밀한 결합이 있으며 개별 구성 요소를 확장할 수 없다는 것입니다. 수정 또는 업그레이드를 수행해야 하는 경우 다른 사용자가 테스트를 완료할 때까지 기다려야 합니다. 민첩하기는 더 어렵습니다.

마이크로 서비스는 이러한 단점을 해결하고 이전 비즈니스 요구 사항과 보다 밀접하게 일치합니다. 그러나 그들은 또한 혜택과 책임이 있습니다. 마이크로 서비스의 장점은 일반적으로 각각이 더 간단한 비즈니스 기능을 캡슐화하며 독립적으로 확장/축소, 테스트, 배포 및 관리할 수 있다는 점입니다. 마이크로 서비스 접근 방식의 한 가지 중요한 이점은 팀이 기술보다는 비즈니스 시나리오에 의해 더 많이 구동된다는 것입니다. 소규모 팀은 고객 시나리오를 기반으로 마이크로 서비스를 개발하고 사용하려는 모든 기술을 사용합니다.

다시 말해 조직에서는 마이크로 서비스 애플리케이션을 유지하기 위해 기술을 표준화할 필요가 없습니다. 자체 서비스를 보유한 개별 팀은 팀의 전문 지식을 바탕으로 합리적이거나 문제 해결에 가장 적합한 것을 수행할 수 있습니다. 실제로 특정 NoSQL 저장소 또는 웹 응용 프로그램 프레임워크와 같은 권장 기술 집합이 바람직합니다.

마이크로 서비스의 단점은 더 많은 개별 엔터티를 관리하고 보다 복잡한 배포 및 버전 관리를 처리해야 한다는 것입니다. 해당 네트워크 대기 시간처럼 마이크로 서비스 간의 네트워크 트래픽이 증가합니다. 많은 수다스럽고 세분화된 서비스는 성능 저하를 일으킬 수 있습니다. 이러한 종속성을 확인하는 데 도움이 되는 도구가 없으면 전체 시스템을 보기가 어렵습니다.

표준은 마이크로 서비스 접근 방식을 사용하여 통신 하는 방법을 지정 하 고 서비스에서 필요한 것 만 용납 하 여 작동 하 게, 엄격한 계약 보다는. 서비스는 서로 독립적으로 업데이트되므로 설계에서 이러한 계약을 미리 정의하는 것이 중요합니다. 마이크로 서비스 접근 방식을 통한 설계와 연결된 또 다른 설명은 "세분화된 서비스 지향 아키텍처(SOA)"입니다.

***간단하게, 마이크로 서비스 디자인 접근 방식은 각각의 독립적 인 변경 및 통신에 대한 합의 된 표준과 함께 서비스의 분리 된 연합에 관한 것입니다.***

더 많은 클라우드 응용 프로그램이 생성됨에 따라 사람들은 전체 응용 프로그램을 독립적이고 시나리오 중심의 서비스로 분해하는 것이 더 장기적인 접근 방식이라는 것을 발견했습니다.

## <a name="comparison-between-application-development-approaches"></a>애플리케이션 개발 접근 방식 비교

![서비스 패브릭 플랫폼 애플리케이션 개발][Image1]

1) 모놀리식 응용 프로그램은 도메인별 기능을 포함하며 일반적으로 웹, 비즈니스 및 데이터와 같은 기능 계층으로 나뉩니다.

2) 여러 서버/가상 시스템/컨테이너에서 복제하여 모놀리식 응용 프로그램을 확장합니다.

3) 마이크로 서비스 애플리케이션은 기능을 더 작은 개별 서비스로 구분합니다.

4) 마이크로 서비스 접근 방식에서는 각 서비스를 독립적으로 배포하여 확장하며 서버/가상 머신/컨테이너 간에 이러한 서비스의 인스턴스를 만듭니다.

마이크로 서비스 접근 방식을 사용 하 여 디자인 하는 모든 프로젝트에 적합 하지 않습니다 하지만 그것은 앞서 설명한 비즈니스 목표와 더 밀접 하 게 정렬 않습니다. 모놀리식 접근 법으로 시작하는 것이 나중에 코드를 마이크로 서비스 디자인으로 다시 작업할 수 있다는 것을 알고 있다면 의미가 있을 수 있습니다. 모놀리식 애플리케이션을 시작하고, 확장성 또는 민첩성이 더 필요한 기능 영역부터 천천히 단계별로 분할하는 것이 더 일반적입니다.

마이크로 서비스 접근 방식을 사용하는 경우 많은 소규모 서비스의 응용 프로그램을 구성합니다. 이러한 서비스는 컴퓨터 클러스터에 배포되는 컨테이너에서 실행됩니다. 소규모 팀은 시나리오에 중점을 둔 서비스를 개발하고 전체 응용 프로그램이 발전할 수 있도록 각 서비스를 독립적으로 테스트, 버전, 배포 및 확장합니다.

## <a name="what-is-a-microservice"></a>마이크로 서비스란?

마이크로 서비스에 대한 정의는 여러 가지가 있습니다. 그러나 마이크로 서비스의 이러한 특성의 대부분은 널리 허용됩니다 :

* 고객 또는 비즈니스 시나리오를 캡슐화합니다. 어떤 문제를 해결하고 있습니까?
* 소규모 엔지니어링 팀에서 개발합니다.
* 모든 프레임 워크를 사용하여 모든 프로그래밍 언어로 작성됩니다.
* 코드와 선택적으로 구성되며 둘 다 독립적으로 버전화, 배포 및 확장됩니다.
* 잘 정의된 인터페이스와 프로토콜을 통해 타 마이크로 서비스와 상호 작용합니다.
* 위치를 해결하는 데 사용되는 고유한 이름(URL)이 있어야 합니다.
* 일관되며 오류 시 사용 가능한 상태를 유지합니다.

요약하면 다음과 같은

***마이크로 서비스 애플리케이션은 독립적으로 버전 관리되며 확장성 있는 소규모 고객 중심 서비스로 구성됩니다. 이 서비스들은 잘 정의된 인터페이스가 있는 표준 프로토콜을 통해 서로 통신합니다.***

### <a name="written-in-any-programming-language-using-any-framework"></a>모든 프레임워크를 사용하여 모든 프로그래밍 언어로 작성

개발자로서 우리는 우리의 기술과 우리가 만드는 서비스의 요구에 따라 언어 나 프레임 워크를 자유롭게 선택할 수 있기를 원합니다. 일부 서비스의 경우 C++의 성능 이점을 다른 서비스보다 높게 평가할 수 있습니다. 다른 사람의 경우 C# 또는 Java에서 얻는 관리되는 개발의 용이성이 더 중요할 수 있습니다. 경우에 따라 특정 파트너 라이브러리, 데이터 저장소 기술 또는 클라이언트에 서비스를 노출하는 방법을 사용해야 할 수 있습니다.

기술을 선택한 후에는 서비스의 운영 또는 수명 주기 관리 및 확장을 고려해야 합니다.

### <a name="allows-code-and-state-to-be-independently-versioned-deployed-and-scaled"></a>개별적으로 버전 관리, 배포 및 확장되는 코드와 상태 허용

마이크로 서비스를 작성하는 방법에 관계없이 코드 및 선택사항 상태는 독립적으로 배포, 업그레이드 및 확장해야 합니다. 이 문제는 기술의 선택에 달려 있기 때문에 해결하기 어렵다. 크기 조정의 경우 코드와 상태를 분할(또는 샤드)하는 방법을 이해하는 것은 쉽지 않습니다. 코드와 상태가 오늘날 일반적인 서로 다른 기술을 사용하는 경우 마이크로 서비스에 대한 배포 스크립트를 모두 확장할 수 있어야 합니다. 이러한 분리는 민첩성과 유연성에 관한 것이므로 모든 마이크로 서비스를 한 번에 업그레이드하지 않고도 일부 마이크로 서비스를 업그레이드할 수 있습니다.

모놀리식 및 마이크로 서비스 접근 방식을 잠시 비교해 보겠습니다. 이 다이어그램은 상태를 저장하는 접근 방식의 차이점을 보여 주며 다음과 같은 방법을 보여 주며 있습니다.

#### <a name="state-storage-for-the-two-approaches"></a>두 가지 방법에 대한 상태 저장소

![서비스 패브릭 플랫폼 상태 스토리지][Image2]

***왼쪽의 모놀리식 접근 방식에는 단일 데이터베이스와 특정 기술의 계층이 있습니다.***

***마이크로 서비스 접근 방식에는 일반적으로 상태가 마이크로 서비스로 범위가 정해지고 다양한 기술이 사용되는 상호 연결된 마이크로 서비스의 그래프가 있습니다.***

모놀리식 접근 방식에서 애플리케이션은 일반적으로 단일 데이터베이스를 사용합니다. 하나의 데이터베이스를 사용하면 단일 위치에 있으므로 쉽게 배포할 수 있다는 장점이 있습니다. 각 구성 요소에는 상태 저장을 위한 단일 테이블이 있습니다. 팀은 상태를 엄격히 구분해야 하지만, 이는 어려운 일입니다. 필연적으로 누군가는 기존 고객 테이블에 열을 추가하고, 테이블 간에 조인을 하고, 저장소 계층에서 종속성을 만들려는 유혹을 받게 됩니다. 이러한 경우가 발생하면, 개별 구성 요소를 확장할 수 없습니다.

마이크로 서비스 접근 방식에서는 각 서비스가 자체 상태를 관리 및 저장합니다. 각 서비스는 서비스의 수요에 맞게 코드와 상태를 함께 확장해야 합니다. 단점은 응용 프로그램의 데이터에 대한 뷰 또는 쿼리를 만들어야 할 때 여러 상태 저장소에서 쿼리해야 한다는 것입니다. 이 문제는 일반적으로 마이크로 서비스 컬렉션에 걸쳐 보기를 빌드하는 별도의 마이크로 서비스에 의해 해결됩니다. 데이터에 대해 여러 개의 즉석 쿼리를 실행해야 하는 경우 오프라인 분석을 위해 각 마이크로 서비스의 데이터를 데이터 웨어하우징 서비스에 쓰는 것이 좋습니다.

마이크로 서비스는 버전이 정해져 있습니다. 서로 다른 버전의 마이크로 서비스가 나란히 실행될 수 있습니다. 업그레이드 중에 최신 버전의 마이크로 서비스가 실패할 수 있으며 이전 버전으로 롤백해야 합니다. 버전 버전은 다른 사용자가 다른 버전의 서비스를 경험하는 A/B 테스트에도 유용합니다. 예를 들어 특정 고객 집합에 대해 마이크로 서비스를 업그레이드하여 새 기능을 보다 광범위하게 롤아웃하기 전에 테스트하는 것이 일반적입니다.

### <a name="interacts-with-other-microservices-over-well-defined-interfaces-and-protocols"></a>잘 정의된 인터페이스와 프로토콜을 통해 타 마이크로 서비스와 상호 작용

지난 10년 동안 서비스 지향 아키텍처의 통신 패턴을 설명하는 광범위한 정보가 게시되었습니다. 일반적으로 서비스 통신은 직렬화 형식으로 HTTP 및 TCP 프로토콜과 XML 또는 JSON이 있는 REST 접근 방식을 사용합니다. 인터페이스 관점에서, 그것은 웹 디자인 접근 방식을 복용에 관한 것입니다. 그러나 바이너리 프로토콜이나 사용자 고유의 데이터 형식을 사용하는 것을 막을 수는 없습니다. 이러한 프로토콜과 형식을 공개적으로 사용할 수 없는 경우 사람들이 마이크로 서비스를 사용하는 데 더 많은 시간을 할애할 수 있다는 점에 유의하십시오.

### <a name="has-a-unique-name-url-used-to-resolve-its-location"></a>자신의 위치를 확인하기 위해 사용하는 고유 이름(URL)이 있음

마이크로 서비스는 어디서 실행되든지 주소 지정 가능해야 합니다. 컴퓨터에 대해 생각하고 특정 마이크로 서비스를 실행하는 컴퓨터에 대해 생각하고 있다면 상황이 빠르게 악화 될 수 있습니다.

DNS가 특정 URL을 특정 머신으로 확인하는 것과 동일한 방법으로 마이크로 서비스는 현재 위치를 검색할 수 있는 고유의 이름이 필요합니다. 마이크로 서비스에는 실행 중인 인프라와 독립적인 주소 지정 가능한 이름이 필요합니다. 서비스 레지스트리가 있어야 하기 때문에 서비스 배포 방법과 검색 방법 간에 상호 작용이 필요합니다. 컴퓨터가 실패하면 레지스트리 서비스는 서비스가 이동된 위치를 알려야 합니다.

### <a name="remains-consistent-and-available-in-the-presence-of-failures"></a>일관되며 오류 시 사용 가능한 상태 유지

예기치 않은 오류를 처리하는 것은 특히 분산된 시스템에서는 가장 까다로운 문제 중 하나입니다. 개발자로 작성하는 대부분의 코드는 예외를 처리하기 위한 것입니다. 테스트 하는 동안, 우리는 또한 예외 처리에 가장 많은 시간을 보낸다. 이 프로세스는 오류를 처리하기 위해 코드를 작성하는 것보다 더 많이 관련됩니다. 마이크로 서비스가 실행 중인 컴퓨터가 실패하면 어떻게 됩니까? 자체적으로 어려운 문제인 오류를 감지해야 합니다. 그러나 마이크로 서비스를 다시 시작해야 합니다.

가용성을 위해 마이크로 서비스는 오류에 대한 복원력이 있어야 하며 다른 컴퓨터에서 다시 시작할 수 있어야 합니다. 이러한 복원력 요구 사항 외에도 데이터가 손실되지 않아야 하며 데이터가 일관되게 유지되어야 합니다.

애플리케이션 업그레이드 중에 오류가 발생하면 복원력을 얻기가 어렵습니다. 배포 시스템과 작업하는 마이크로 서비스는 복구할 필요가 없습니다. 일관된 상태를 유지하기 위해 최신 버전으로 계속 이동하거나 이전 버전으로 롤백할 수 있는지 여부를 결정해야 합니다. 앞으로 계속 진행할 수 있는 충분한 컴퓨터가 있는지 여부와 이전 버전의 마이크로 서비스를 복구하는 방법과 같은 몇 가지 질문을 고려해야 합니다. 이러한 결정을 내리려면 상태 정보를 내보사려면 마이크로 서비스가 필요합니다.

### <a name="reports-health-and-diagnostics"></a>보고서 상태 및 진단

그것은 명백한 보일 수 있습니다., 그리고 그것은 종종 간과, 하지만 마이크로 서비스는 그것의 상태 및 진단을 보고 해야. 그렇지 않으면 운영 관점에서 해당 상태와 거의 통하지 않습니다. 일련의 독립적인 서비스를 통틀어 진단 이벤트 간의 상관 관계를 파악하고 이벤트 순서를 알기 위해 머신의 시간 차이를 이해하는 것은 어려운 작업입니다. 협의된 프로토콜과 데이터 형식을 통해 마이크로 서비스와 상호 작용하는 것과 같은 방식으로, 로그 상태와 진단 이벤트를 로깅하는 방법을 표준화해야 하며 이는 궁극적으로 쿼리 및 보기를 위한 이벤트 저장소로 귀결됩니다. 마이크로 서비스 접근 방식을 사용하면 여러 팀이 단일 로깅 형식에 동의해야 합니다. 애플리케이션에서 진단 이벤트를 전체적으로 보는 데 일관된 접근 방식이 필요합니다.

상태는 진단과 다릅니다. 상태는 적절한 조치를 취하도록 마이크로 서비스가 현재 상태를 보고하는 것입니다. 좋은 예는 가용성 유지를 위한 업그레이드 및 배포 메커니즘과의 상호 작용입니다. 프로세스 충돌 또는 컴퓨터 재부팅으로 인해 서비스가 현재 비정상일 수 있지만 서비스는 여전히 작동 중일 수 있습니다. 마지막으로 필요한 것은 업그레이드를 시작하여 상황을 악화시게 하는 것입니다. 가장 좋은 방법은 먼저 조사하거나 마이크로 서비스가 복구될 수 있는 시간을 허용하는 것입니다. 마이크로 서비스의 상태 이벤트를 통해 정보에 입각한 의사 결정을 내리고 효과적인 자체 복구 서비스를 만들 수 있습니다.

## <a name="guidance-for-designing-microservices-on-azure"></a>Azure에서 마이크로 서비스 디자인에 대한 지침

Azure에서 마이크로 서비스 설계 및 빌드에 대한 지침을 보려면 Azure 아키텍처 센터를 [방문하십시오.](https://docs.microsoft.com/azure/architecture/microservices/)

## <a name="service-fabric-as-a-microservices-platform"></a>마이크로 서비스 플랫폼으로서의 서비스 패브릭

Azure 서비스 패브릭은 Microsoft가 일반적으로 모놀리식 인 박스형 제품을 제공하는 것에서 서비스 제공으로 전환할 때 나타났습니다. Azure SQL 데이터베이스 및 Azure Cosmos DB와 같은 대규모 서비스를 빌드하고 운영하는 경험입니다. 플랫폼은 시간이 지남에 따라 더 많은 서비스가 채택됨에 따라 발전했습니다. Service Fabric이 Azure뿐 아니라 독립 실행형 Windows Server 배포에서 실행되어야 했다는 점입니다.

***Service Fabric의 목적은 서비스를 구축하고 실행하는 어려운 문제를 해결하고 인프라 리소스를 효율적으로 사용하는 것이므로 팀은 마이크로 서비스 접근 방식을 사용하여 비즈니스 문제를 해결할 수 있습니다.***

Service Fabric은 마이크로 서비스 접근 방식을 사용하는 애플리케이션을 쉽게 빌드할 수 있도록 다음을 제공합니다.

* 실패한 서비스를 배포, 업그레이드, 검색 및 다시 시작하고 서비스를 검색하며 메시지를 라우팅하고 상태를 관리 및 모니터링하는 시스템 서비스를 제공하는 플랫폼입니다.
* 컨테이너 또는 프로세스로 실행되는 응용 프로그램을 배포할 수 있는 기능입니다. Service Fabric은 컨테이너 및 프로세스 조정자입니다.
* ASP.NET [코어, 신뢰할 수 있는 행위자 및 신뢰할 수 있는 서비스](service-fabric-choose-framework.md): 마이크로 서비스로 응용 프로그램을 구축하는 데 도움이 되는 생산적인 프로그래밍 API. 예를 들어 상태 및 진단 정보를 받거나 기본 제공되는 고가용성을 활용할 수 있습니다.

***서비스 패브릭은 서비스를 구축하는 방법에 대해 독립적이며 모든 기술을 사용할 수 있습니다. 그러나 마이크로 서비스를 보다 쉽게 빌드할 수 있도록 기본 제공 프로그래밍 API를 제공합니다.***

### <a name="migrating-existing-applications-to-service-fabric"></a>Service Fabric으로 기존 애플리케이션 마이그레이션

서비스 패브릭을 사용하면 기존 코드를 재사용하고 새로운 마이크로 서비스로 현대화할 수 있습니다. 응용 프로그램 현대화에는 5단계가 있으며 모든 단계에서 시작하고 중지할 수 있습니다. 단계는 다음과 같습니다.

1) 기존의 모놀리식 애플리케이션을 시작합니다.  
2) 마이그레이션할. 컨테이너 또는 게스트 실행 을 사용하여 서비스 패브릭에서 기존 코드를 호스팅합니다.  
3) 현대화. 기존 컨테이너화된 코드와 함께 새 마이크로 서비스를 추가합니다.  
4) 혁신. 필요에 따라 모놀리식 응용 프로그램을 마이크로 서비스로 나누기합니다.  
5) 응용 프로그램을 마이크로 서비스로 변환합니다. 기존 모놀리식 응용 프로그램을 변환하거나 새로운 그린필드 애플리케이션을 빌드합니다.

![마이크로 서비스로 마이그레이션][Image3]

이러한 단계 *중 어느 단계에서든 시작하고 중지할*수 있습니다. 다음 단계로 진행할 필요가 없습니다. 

이러한 각 단계에 대한 예제를 살펴보겠습니다.

**마이그레이션할**  
두 가지 이유로 많은 회사에서 기존 모놀리식 응용 프로그램을 컨테이너로 마이그레이션하고 있습니다.

* 기존 하드웨어의 통합 및 제거 또는 더 높은 밀도의 응용 프로그램 실행으로 인한 비용 절감.
* 개발과 운영 간의 일관된 배포 계약입니다.

비용 절감은 간단합니다. Microsoft에서는 많은 기존 응용 프로그램이 컨테이너화되어 수백만 달러의 비용을 절감할 수 있습니다. 일관된 배포는 평가하기 어렵지만 똑같이 중요합니다. 즉, 개발자는 자신에게 맞는 기술을 선택할 수 있지만 작업은 응용 프로그램을 배포하고 관리하는 단일 방법만 허용합니다. 개발자가 특정 기술만 선택하도록 강요하지 않고 서로 다른 기술을 지원하는 복잡성을 처리하지 않아도 되는 작업을 완화합니다. 기본적으로 모든 응용 프로그램은 독립적인 배포 이미지로 컨테이너화됩니다.

대부분의 조직에서는 여기까지만 수행합니다. 이미 컨테이너의 이점이 있으며 Service Fabric은 배포, 업그레이드, 버전 관리, 롤백 및 상태 모니터링을 비롯한 완벽한 관리 환경을 제공합니다.

**현대화**  
현대화는 기존 컨테이너화 코드와 함께 새로운 서비스를 추가하는 것입니다. 새 코드를 작성하려는 경우 마이크로 서비스 경로를 작은 단계로 낮추는 것이 가장 좋습니다. 이는 새 REST API 끝점 또는 새 비즈니스 논리를 추가하는 것을 의미할 수 있습니다. 이러한 방식으로 새 마이크로 서비스를 빌드하는 프로세스를 시작하고 이를 개발 및 배포하는 연습을 수행할 수 있습니다.

**혁신**  
마이크로 서비스 접근 방식은 변화하는 비즈니스 요구 사항을 수용합니다. 이 단계에서는 모놀리식 응용 프로그램을 서비스로 분할할지 또는 혁신을 시작할지 결정해야 합니다. 여기서 대표적인 예로 워크플로 큐로 사용하는 데이터베이스가 처리 병목 현상이 되는 경우를 들 수 있습니다. 워크플로 요청의 수가 증가하므로 작업은 크기에 따라 배포되야 합니다. 확장되지 않거나 더 자주 업데이트해야 하는 응용 프로그램의 특정 부분을 사용하여 마이크로 서비스로 분할하고 혁신합니다.

**애플리케이션을 마이크로 서비스로 변환**  
이 단계에서 응용 프로그램은 완전히 마이크로 서비스(또는 마이크로 서비스로 분할)로 구성됩니다. 이 시점에 도달하기 위해 마이크로 서비스 여정을 만들었습니다. 여기에서 시작할 수 있지만 마이크로 서비스 플랫폼없이 그렇게하려면 상당한 투자가 필요합니다.

### <a name="are-microservices-right-for-my-application"></a>마이크로 서비스가 내 애플리케이션에 적합할까요?

아마도 그렇습니다. Microsoft에서는 비즈니스상의 이유로 더 많은 팀이 클라우드를 구축하기 시작하면서 많은 팀이 마이크로 서비스(microservice)와 같은 접근 방식을 취하는 이점을 깨달았습니다. 예를 들어 Bing은 수년 동안 마이크로 서비스를 사용해 왔습니다. 다른 팀의 경우 마이크로 서비스 접근 방식은 새로웠습니다. 팀은 핵심 역량이 아니면서 해결이 필요한 까다로운 문제를 찾았습니다. 이것이 서비스 패브릭이 서비스 구축 기술로 견인력을 얻은 이유입니다.

Service Fabric의 목적은 비용이 많이 드는 재설계를 거치지 않아도 되도록 마이크로 서비스 응용 프로그램을 빌드하는 복잡성을 줄이는 것입니다. 처음에는 소규모로 시작해서 고객의 사용량에 따라 확장하고, 서비스를 중단하고, 새 서비스를 추가하고, 발전해 가는 것이 바로 이 접근 방식입니다. 대부분의 개발자들이 더 쉽게 마이크로 서비스에 접근할 수 있게 하기 위해서는 아직 많은 문제들을 해결해야 한다는 점도 알고 있습니다. 컨테이너 및 행위자 프로그래밍 모델은 해당 방향의 작은 단계의 예입니다. 우리는 마이크로 서비스 접근 방식을 더 쉽게 만들기 위해 더 많은 혁신이 나타날 것이라고 확신합니다.

## <a name="next-steps"></a>다음 단계

* [마이크로 서비스: 클라우드가 지원하는 애플리케이션 혁명](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/)
* [Azure 아키텍처 센터: Azure에서 마이크로 서비스 구축](https://docs.microsoft.com/azure/architecture/microservices/)
* [Azure Service Fabric 애플리케이션 및 클러스터에 대한 모범 사례](service-fabric-best-practices-overview.md)
* [서비스 패브릭 용어 개요](service-fabric-technical-overview.md)

[Image1]: media/service-fabric-overview-microservices/monolithic-vs-micro.png
[Image2]: media/service-fabric-overview-microservices/statemonolithic-vs-micro.png
[Image3]: media/service-fabric-overview-microservices/microservices-migration.png
