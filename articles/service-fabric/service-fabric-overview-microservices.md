---
title: Azure 마이크로 서비스 소개 | Microsoft Docs
description: 마이크로 서비스 접근 방식을 통해 클라우드 애플리케이션을 빌드하는 것이 왜 현대 애플리케이션 개발에서 중요하며 Azure Service Fabric이 어떻게 이를 위한 플랫폼을 제공하는지에 대한 개요
services: service-fabric
documentationcenter: .net
author: athinanthny
manager: chackdan
editor: ''
ms.assetid: fae2be85-0ab4-4cd3-9d1f-e0d95fe1959b
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: conceptual
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/18/2019
ms.author: atsenthi
ms.openlocfilehash: 5bcb52165c7cae18b807eff03c80b51eae8e2717
ms.sourcegitcommit: b7a44709a0f82974578126f25abee27399f0887f
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/18/2019
ms.locfileid: "67204800"
---
# <a name="why-use-a-microservices-approach-to-building-applications"></a>응용 프로그램을 구축 하는 마이크로 서비스 접근 방식을 사용 하는 이유?

소프트웨어 개발자를 위한 구성 요소로 응용 프로그램을 팩터링 경우 표시할 새 소식 없음 일반적으로 백엔드 스토어, 중간 계층 비즈니스 논리 및 프런트 엔드 사용자 인터페이스 (UI)를 사용 하 여 계층화 된 접근 방식을 사용 됩니다. 어떤 *가* 는 개발자의 클라우드에 대 한 분산된 응용 프로그램 작성 하는 지난 몇 년간 변경 합니다.

몇 가지 변화 하는 비즈니스 요구는 다음과 같습니다.

* 가 빌드 및 새 지역에서 고객에 게 도달에 대규모로 운영 하는 서비스입니다.
* 특징과 기능을 신속 하 게에서 고객의 요구에 응답할 더 빠르게 배달 합니다.
* 리소스 사용률 향상으로 비용을 줄여야 합니다.

이러한 비즈니스 요구가 애플리케이션을 구축하는 *방식* 에 영향을 미칩니다.

Azure 마이크로 서비스 접근 방식에 대 한 자세한 내용은 참조 하세요. [마이크로 서비스: 클라우드가 지원하는 애플리케이션 혁명](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/)을 참조하세요.

## <a name="monolithic-vs-microservices-design-approach"></a>모놀리식 마이크로 서비스 디자인 방법 비교

모든 애플리케이션은 시간에 따라 진화합니다. 성공적인 애플리케이션은 사람들에게 유용하게 되어 진화합니다. 실패 한 응용 프로그램 진화 하지 및 최종적으로 사용 되지 않습니다. 다음 질문은: 얼마나 알고 요구 사항에 대 한 현재 및 어떤 수 나중에? 예를 들어 회사에서 부서에 대 한 보고 응용 프로그램을 작성 중인 가정해 보겠습니다. 회사의 범위 내 에서만 적용 되는 응용 프로그램 및 보고서 않습니다을 유지 하는 긴 확실 합니다. 접근 방식으로 다른 예를 들어, 수천만의 고객에 비디오 콘텐츠를 제공 하는 서비스를 작성 합니다.

요인인 경우에 따라는 개념 증명으로 가져오는 내놓는 것입니다. 응용 프로그램이 향후 재설계 될 수를 알 수 있습니다. 아무런 의미가 무언가 과하게 가져옵니다를 사용한 적이 없는 합니다. 반면에 회사는 클라우드 용 개발을 기대 때 성장 및 사용 합니다. 이러한 성장과 확장을 예측할 수 없습니다. 하고자 프로토타입을 신속 하 게도 미래의 성공을 처리할 수 있는 경로에 있는지를 파악 하는 동안 합니다. 이것이 구축, 측정, 학습, 반복으로 이루어진 간결한 시작 접근 방식입니다.

클라이언트/서버 시절에 각 계층에서 특정 기술을 사용 하 여 계층화 된 응용 프로그램 구축에 전념할 수 경향이 있습니다. 용어 *모놀리식* 응용 프로그램은 이러한 접근 방식을 설명 하기 위해 부상 했습니다. 인터페이스가 계층 사이에 속하는 경향이 있기 때문에 각 계층 내의 구성 요소 사이에는 더 긴밀히 연결된 설계가 적용되었습니다. 개발자 설계 및 팩터링 된 라이브러리에 컴파일되고 몇 가지 실행 파일과 Dll로 연결 하는 클래스입니다.

모놀리식 디자인 방법 이점이 있습니다. 모놀리식 응용 프로그램을 디자인, 하기가 더 쉬운 경우가 및 이러한 호출은 프로세스 간 통신 (IPC)을 통해 경우가 많기 때문에 구성 요소 간의 호출이 더 빠릅니다. 또한 모든 사용자가 인적 자원 더욱 효율적으로 사용할 수 있는 단일 제품을 테스트 합니다. 단점은 계층화 된 레이어 간의 긴밀 한 결합 있으며 개별 구성 요소를 확장할 수 없습니다. 즉 수정 이나 업그레이드가 수행 해야 할 경우 다른 사용자가 테스트를 마칠 때까지 대기 해야 합니다. 민첩성 확보 하기가 어렵다는 합니다.

이러한 단점을 해결할 수 마이크로 서비스 및 밀접 하 게 앞의 비즈니스 요구 사항과 더 합니다. 하지만 이점과 부채를 모두 합니다. 마이크로 서비스의 장점은 일반적으로 각각이 더 간단한 비즈니스 기능을 캡슐화하며 독립적으로 확장/축소, 테스트, 배포 및 관리할 수 있다는 점입니다. 마이크로 서비스 접근 방식의 중요 한 이점 중 하나는 팀은 보다 비즈니스 시나리오에서 자세한 기술에 의해 좌우 됩니다. 소규모 팀 고객 시나리오를 기반으로 마이크로 서비스를 개발 및 사용 하고자 하는 모든 기술을 사용 합니다.

다시 말해 조직에서는 마이크로 서비스 애플리케이션을 유지하기 위해 기술을 표준화할 필요가 없습니다. 자체 서비스를 보유한 개별 팀은 팀의 전문 지식을 바탕으로 합리적이거나 문제 해결에 가장 적합한 것을 수행할 수 있습니다. 실제로 집합이 특정 NoSQL 저장소와 같은 기술을 권장 또는 웹 응용 프로그램 프레임 워크는 것이 좋습니다.

마이크로 서비스의 단점은 이상의 개별 엔터티를 관리 하 고 더 복잡 한 배포 및 버전 관리를 사용 하 여 처리 해야 한다는 것입니다. 해당 네트워크 대기 시간으로 마이크로 서비스 간의 네트워크 트래픽이 증가 합니다. 번잡 한 세분화 된 서비스의 많은 성능 문제일을 발생할 수 있습니다. 이러한 종속성을 볼 수 있도록 도구 없이도 전체 시스템을 참조 하기 어렵습니다.

표준 통신 하는 방법을 지정 하 고 서비스에서 필요한 것만을 허용 하 여 작동 하지 않고 고정 된 마이크로 서비스 접근 방식을 확인 계약입니다. 서비스는 서로 독립적으로 업데이트 하기 때문에 디자인에서 이러한 계약을 정의 하는 것이 반드시 합니다. 마이크로 서비스 접근 방식을 통한 설계와 연결된 또 다른 설명은 "세분화된 서비스 지향 아키텍처(SOA)"입니다.

***가장 간단한 마이크로 서비스 디자인 방법은 각각 독립적인 변경 및 통신에 대 한 합의 표준을 사용 하 여 서비스의 페더레이션을 분리 하는 방법에 대 한 합니다.***

더 많은 클라우드 응용 프로그램을 생성 하는 대로 사용자 전체 응용 프로그램을 독립적인 시나리오 중심적 서비스로이 분해가 더 장기적인 접근 방식 임을 검색 합니다.

## <a name="comparison-between-application-development-approaches"></a>애플리케이션 개발 접근 방식 비교

![서비스 패브릭 플랫폼 애플리케이션 개발][Image1]

1) 모놀리식 응용 프로그램 도메인 특정 기능을 포함 하며 일반적으로 웹, 비즈니스, 데이터 등의 기능 계층으로 나뉩니다.

2) 여러 서버/가상 머신에서 복제 하 여 모놀리식 응용 프로그램의 크기를 조정/컨테이너입니다.

3) 마이크로 서비스 애플리케이션은 기능을 더 작은 개별 서비스로 구분합니다.

4) 마이크로 서비스 접근 방식에서는 각 서비스를 독립적으로 배포하여 확장하며 서버/가상 머신/컨테이너 간에 이러한 서비스의 인스턴스를 만듭니다.

마이크로 서비스를 사용 하 여 디자인 접근 방식에는 모든 프로젝트에 적절 하지 않습니다. 하지만 앞에서 설명한 비즈니스 목표와 더욱 긴밀 하 게 정렬지 않습니다. 모놀리식 접근 방식부터 적합할 기회를 마이크로 서비스 디자인으로 코드를 나중에 재작업 해야 하는 것이 알고 있는 경우. 모놀리식 애플리케이션을 시작하고, 확장성 또는 민첩성이 더 필요한 기능 영역부터 천천히 단계별로 분할하는 것이 더 일반적입니다.

마이크로 서비스 접근 방식을 사용 하면 많은 소규모 서비스의 응용 프로그램 작성. 이러한 서비스는 컴퓨터의 클러스터에 걸쳐 배포 된 컨테이너에서 실행 합니다. 소규모 팀은 시나리오에 중점을 두는 서비스를 개발 및 독립적으로 테스트, 버전, 배포 및 전체 응용 프로그램이 진화 하도록 각 서비스를 확장 합니다.

## <a name="what-is-a-microservice"></a>마이크로 서비스란?

마이크로 서비스에 대한 정의는 여러 가지가 있습니다. 하지만 마이크로 서비스의 이러한 특성 중 가장 널리 사용 되는:

* 고객 또는 비즈니스 시나리오를 캡슐화합니다. 해결 하려는 문제
* 소규모 엔지니어링 팀에서 개발합니다.
* 모든 프레임 워크를 사용 하 여 모든 프로그래밍 언어로 작성 합니다.
* 코드, 구성 및 상태를 둘 다는 독립적으로 버전 관리, 배포 및 확장할 필요에 따라 합니다.
* 잘 정의된 인터페이스와 프로토콜을 통해 타 마이크로 서비스와 상호 작용합니다.
* 해당 위치를 확인 하는 데 사용 되는 고유한 이름 (Url).
* 일관되며 오류 시 사용 가능한 상태를 유지합니다.

요약 하는:

***마이크로 서비스 애플리케이션은 독립적으로 버전 관리되며 확장성 있는 소규모 고객 중심 서비스로 구성됩니다. 이 서비스들은 잘 정의된 인터페이스가 있는 표준 프로토콜을 통해 서로 통신합니다.***

### <a name="written-in-any-programming-language-using-any-framework"></a>모든 프레임 워크를 사용 하 여 모든 프로그래밍 언어로 작성 된

개발자로 서 자유롭게 언어 또는 프레임 워크, 우리는 자신의 기술 및 우리가 만들고 있는 서비스의 요구에 따라 선택할 수 하고자 합니다. 일부 서비스의 성능 이점 값 수 있습니다 C++ 위의 다른 것입니다. 다른 사람이 얻을 수 있는 관리 되는 개발의 용이성 C# 또는 Java 더 중요할 수 있습니다. 경우에 따라 서비스를 클라이언트에 노출 하기 위한 특정 파트너 라이브러리, 데이터 저장소 기술 또는 메서드를 사용 해야 합니다.

기술을 선택한 후 고려 운영 또는 수명 주기 관리 및 서비스의 크기를 조정 해야 합니다.

### <a name="allows-code-and-state-to-be-independently-versioned-deployed-and-scaled"></a>개별적으로 버전 관리, 배포 및 확장되는 코드와 상태 허용

어떻게 마이크로 서비스, 코드 및 필요에 따라 상태를 작성 하는 관계 없이 독립적으로 배포, 업그레이드 및 크기를 조정 합니다. 이 문제는 기술의 선택에 달려 있기 때문에 해결 하기가 어렵습니다. 확장을 이해 하는 데 파티션 (또는 분할) 하는 방법을 코드와 상태는 것은 어렵습니다. 코드 및 상태가 현재 공통 되는 다른 기술을 사용 하는 경우 마이크로 서비스의 배포 스크립트가 둘 다 확장할 수 되도록 해야 합니다. 이 분리 되므로 민첩성과 유연성을 제공 하는 방법에 대 한 모든 작업을 한 번에 업그레이드 하지 않고도 일부 마이크로 서비스를 업그레이드할 수 있습니다.

잠시 모놀리식을 마이크로 서비스 접근 방식의 비교를 다시 살펴보겠습니다. 이 다이어그램 상태를 저장 하는 방법의 차이 보여 줍니다.

#### <a name="state-storage-for-the-two-approaches"></a>두 가지 방법에 대 한 상태 저장

![서비스 패브릭 플랫폼 상태 스토리지][Image2]

***모놀리식 접근 방식에서는 왼쪽에 단일 데이터베이스와 특정 기술의 계층이 있습니다.***

***오른쪽의 마이크로 서비스 접근 방식을 마이크로 서비스로 보여지며 마이크로 서비스가 상태 범위는 일반적으로 다양 한 기술을 사용 그래프를 있습니다.***

모놀리식 접근 방식에서 애플리케이션은 일반적으로 단일 데이터베이스를 사용합니다. 하나의 데이터베이스를 사용 하는 이점은 쉽게 배포할 수 있도록 하는 곳에서에서 것입니다. 각 구성 요소에는 상태 저장을 위한 단일 테이블이 있습니다. 팀은 상태를 엄격히 구분해야 하지만, 이는 어려운 일입니다. 밖에 누군가가 되지 기존 고객 테이블에 열을 추가, 테이블 간의 조인을 수행 하 고 저장소 계층에서 종속성을 만들고자 하는 일을 하려고 합니다. 이러한 경우가 발생하면, 개별 구성 요소를 확장할 수 없습니다.

마이크로 서비스 접근 방식에서는 각 서비스가 자체 상태를 관리 및 저장합니다. 각 서비스는 서비스의 수요에 맞게 코드와 상태를 함께 확장해야 합니다. 뷰 또는 쿼리를 응용 프로그램의 데이터를 만들려고 할 때 할 경우 여러 상태 저장에 걸쳐 쿼리해야 하는 것을 단점은 있습니다. 이 문제는 일반적으로 마이크로 서비스의 컬렉션에서 뷰를 작성 하는 별도 마이크로 서비스에서 해결 됩니다. 데이터에 대해 여러 임시 쿼리를 실행 해야 할 경우 오프 라인 분석용 데이터 웨어하우징 서비스에 각 마이크로 서비스의 데이터를 작성 하는 것이 좋습니다.

마이크로 서비스 버전이 지정 됩니다. 나란히 실행 하는 마이크로 서비스의 서로 다른 버전에 대 한 것 같습니다. 마이크로 서비스의 최신 버전을 업그레이드 하는 동안 실패 하 고 이전 버전으로 롤백할 수 해야 수 없습니다. 버전 관리에도 도움이 됩니다 a / B 테스트, 여기서 다양 한 사용자 환경을 다른 버전의 서비스입니다. 예를 들어, 것이 일반적 자세히 널리 배포 하기 전에 새 기능을 테스트 하는 고객의 특정 집합에 대 한 마이크로 서비스를 업그레이드 합니다.

### <a name="interacts-with-other-microservices-over-well-defined-interfaces-and-protocols"></a>잘 정의된 인터페이스와 프로토콜을 통해 타 마이크로 서비스와 상호 작용

지난 10 년간 서비스 지향 아키텍처의 통신 패턴을 설명 하는 광범위 한 정보를 게시 된 했습니다. 일반적으로 서비스 통신은 직렬화 형식으로 HTTP 및 TCP 프로토콜과 XML 또는 JSON이 있는 REST 접근 방식을 사용합니다. 인터페이스 관점에서 보면 웹 설계 접근 방법을 사용 하는 방법에 대 한 것입니다. 하지만 아무 바이너리 프로토콜이 나 자체 데이터 형식을 사용 하 여 중지 해야 합니다. 사용자가이 프로토콜과 형식이 공개적으로 사용할 수 없는 경우에 마이크로 서비스를 사용 하 여 어렵다는 점에 미리 알고 있어야 합니다.

### <a name="has-a-unique-name-url-used-to-resolve-its-location"></a>자신의 위치를 확인하기 위해 사용하는 고유 이름(URL)이 있음

마이크로 서비스는 어디서 실행 주소 지정이 가능 해야 합니다. 어느 특정 마이크로 서비스를 실행 중인 컴퓨터에 대 한 생각을 하는 경우 발생할 수 있는 잘못 된 신속 하 게 합니다.

DNS가 특정 URL을 특정 머신으로 확인하는 것과 동일한 방법으로 마이크로 서비스는 현재 위치를 검색할 수 있는 고유의 이름이 필요합니다. 마이크로 서비스에서 실행 중인 인프라와 독립적인 주소 지정 가능 이름이 필요 합니다. 서비스 레지스트리가 있어야 하므로 서비스를 배포 하는 방법 및 검색 하는 방법 간의 상호 작용이 있다는 것을 의미 합니다. 컴퓨터가 실패 하는 경우 레지스트리 서비스는 서비스를 이동 되는 위치를 알려 해야 합니다.

### <a name="remains-consistent-and-available-in-the-presence-of-failures"></a>일관되며 오류 시 사용 가능한 상태 유지

예기치 않은 오류를 처리하는 것은 특히 분산된 시스템에서는 가장 까다로운 문제 중 하나입니다. 대부분의 개발자로 서 작성 하는 코드는 예외입니다. 테스트 중에 또한 지출 하는 시간을 가장 많이 예외 처리에. 프로세스는 오류를 처리 하는 코드를 작성 하는 보다 더 복잡 합니다. 마이크로 서비스를 실행 중인 컴퓨터에서 오류가 발생 하는 경우 어떻게 되나요? 자체적으로 어려운 문제는 오류를 감지 해야 합니다. 하지만 마이크로 서비스를 다시 시작 해야 합니다.

가용성을 위해 마이크로 서비스는 오류에 탄력적이 고 다른 컴퓨터에서 다시 시작 하는 일을 할 수 해야 합니다. 이러한 복원 력 요구 사항 외에도 데이터 손실 하지 않아야 하 고 데이터 일관성을 유지 해야 합니다.

애플리케이션 업그레이드 중에 오류가 발생하면 복원력을 얻기가 어렵습니다. 배포 시스템과 작업하는 마이크로 서비스는 복구할 필요가 없습니다. 최신 버전으로 이동 또는 일관 된 상태로 유지 하기 위해 이전 버전으로 롤백 계속할 수 있는지 여부를 결정 해야 합니다. 충분 한 컴퓨터를 계속 진행 하기를 사용할 수 있는지 마이크로 서비스의 이전 버전을 복구 하는 방법 등의 몇 가지 질문을 고려해 야 합니다. 이러한 결정을 해야 마이크로 서비스가 상태 정보를 내보내야 합니다.

### <a name="reports-health-and-diagnostics"></a>보고서 상태 및 진단

당연 하 게 보일 수 및 종종 간과 됩니다 있지만 마이크로 서비스가 자신의 상태와 진단을 보고 해야 합니다. 그렇지 않으면 작업 측면에서 해당 상태에 대 한 정보를 거의 해야 합니다. 일련의 독립적인 서비스를 통틀어 진단 이벤트 간의 상관 관계를 파악하고 이벤트 순서를 알기 위해 머신의 시간 차이를 이해하는 것은 어려운 작업입니다. 협의된 프로토콜과 데이터 형식을 통해 마이크로 서비스와 상호 작용하는 것과 같은 방식으로, 로그 상태와 진단 이벤트를 로깅하는 방법을 표준화해야 하며 이는 궁극적으로 쿼리 및 보기를 위한 이벤트 저장소로 귀결됩니다. 마이크로 서비스 접근 방식, 다른 팀 단일 로깅 형식에 동의 해야 합니다. 애플리케이션에서 진단 이벤트를 전체적으로 보는 데 일관된 접근 방식이 필요합니다.

상태는 진단과 다릅니다. 상태는 적절한 조치를 취하도록 마이크로 서비스가 현재 상태를 보고하는 것입니다. 좋은 예는 가용성 유지를 위한 업그레이드 및 배포 메커니즘과의 상호 작용입니다. 하지만 서비스 프로세스 크래시로 인해 현재 비정상 상태로 있을 수 나 컴퓨터 재부팅으로 서비스가 작동 될 수 있습니다. 마지막 해야 상황이 더 악화 되는 업그레이드를 시작 하 여 확인 하는 것입니다. 가장 좋은 방법은 먼저 조사를 하거나 마이크로 서비스가 복구할 시간을 허용 합니다. 마이크로 서비스의 상태 이벤트를 통해 정보에 입각한 의사 결정을 내리고 효과적인 자체 복구 서비스를 만들 수 있습니다.

## <a name="guidance-for-designing-microservices-on-azure"></a>Azure에서 마이크로 서비스 디자인에 대 한 지침 
지침에 대 한 Azure 아키텍처 센터를 방문 [설계 하 고 Azure에서 마이크로 서비스 구축](https://docs.microsoft.com/azure/architecture/microservices/)합니다.

## <a name="service-fabric-as-a-microservices-platform"></a>마이크로 서비스 플랫폼으로서의 서비스 패브릭

Azure Service Fabric에는 Microsoft 서비스를 제공 하는 일반적으로 모놀리식, boxed 제품 제공에서 전환 하는 경우 등장 했습니다. Azure SQL Database 및 Azure Cosmos DB와 같은 대규모 서비스를 구축 및 운영 경험을 Service Fabric 기반 만들었습니다. 플랫폼으로 더 많은 서비스를 채택 하 고 시간이 지남에 따라 발전 했습니다. Service Fabric이 Azure뿐 아니라 독립 실행형 Windows Server 배포에서 실행되어야 했다는 점입니다.

***Service Fabric의 목표 이므로 빌드 및 실행 하는 서비스의 어려운 문제를 해결 하는 데 효율적으로 인프라 리소스를 사용 하 여 팀을 마이크로 서비스 접근 방식을 사용 하 여 비즈니스 문제를 해결할 수 있습니다.***

Service Fabric은 마이크로 서비스 접근 방식을 사용하는 애플리케이션을 쉽게 빌드할 수 있도록 다음을 제공합니다.

* 실패한 서비스를 배포, 업그레이드, 검색 및 다시 시작하고 서비스를 검색하며 메시지를 라우팅하고 상태를 관리 및 모니터링하는 시스템 서비스를 제공하는 플랫폼입니다.
* 프로세스 또는 컨테이너에서 실행 하거나 응용 프로그램을 배포할 수 있습니다. Service Fabric은 컨테이너 및 프로세스 조정자입니다.
* 생산성 있는 프로그래밍 Api를 마이크로 서비스로 응용 프로그램을 빌드할 수 있도록 합니다. [ASP.NET Core, Reliable Actors 및 Reliable Services](service-fabric-choose-framework.md). 예를 들어 상태 및 진단 정보를 받거나 기본 제공되는 고가용성을 활용할 수 있습니다.

***Service Fabric 서비스를 구축 하는 방법에 대 한 알 수 없는 이며 모든 기술을 사용할 수 있습니다. 하지만 더 쉽게 마이크로 서비스를 개발할 수 있도록 하는 기본 제공 프로그래밍 Api를 제공 합니다.***

### <a name="migrating-existing-applications-to-service-fabric"></a>Service Fabric으로 기존 애플리케이션 마이그레이션

Service Fabric을 사용 하면 기존 코드를 다시 사용 하 고 새로운 마이크로 서비스를 사용 하 여 현대화 수 있습니다. 응용 프로그램을 업그레이드 하는 5 단계가 있습니다 및 시작 하 고 모든 단계에서 중지할 수 있습니다. 단계는 다음과 같습니다.

1) 기존의 모놀리식 애플리케이션을 시작합니다.  
2) 마이그레이션하십시오. 컨테이너 또는 게스트 실행 파일을 사용 하 여 Service Fabric에서 기존 코드를 호스트 합니다.  
3) 현대화 합니다. 컨테이너 화 된 기존 코드와 함께 새 마이크로 서비스를 추가 합니다.  
4) 혁신. 필요에 따라 마이크로 서비스에 모놀리식 응용 프로그램을 중단 합니다.  
5) 응용 프로그램을 마이크로 서비스로 변환 합니다. 모놀리식 기존 응용 프로그램을 변환 하거나 새 최적의 응용 프로그램을 작성 합니다.

![마이크로 서비스로 마이그레이션][Image3]

해야 할 수 있습니다 *위의 모든이 단계에서 시작 및 중지*합니다. 없다면 다음 단계로 진행 상황을 합니다. 

이러한 각 단계에 대 한 예제에 살펴보겠습니다.

**마이그레이션**  
두 가지 이유로 많은 회사 컨테이너로 모놀리식 기존 응용 프로그램을 마이그레이션하는:

* 비용된 절감을 기존 하드웨어의 통합 및 제거 또는 인해 높은 밀도로 응용 프로그램을 실행 합니다.
* 개발 및 운영 간의 일관된 배포 약속.

비용된을 줄이는 것은 간단 합니다. Microsoft에서 많은 기존 응용 프로그램 컨테이너를 수백만 달러 절감 효과에서 선행 합니다. 일관 된 배포 평가 하지만 동일 하 게 중요 한 경우 개발자에 맞게 하는 기술을 선택할 수 있지만 작업 배포 및 관리 응용 프로그램에는 단일 메서드만 수락할 의미 합니다. 이 특정 개체만 선택 하는 개발자를 시작 하지 않고 다양 한 기술 지원의 복잡성을 처리 하지 않아도 작업을 완화 합니다. 기본적으로 모든 응용 프로그램은 자체 포함된 배포 이미지에 컨테이너 화 된.

대부분의 조직에서는 여기까지만 수행합니다. 이미 컨테이너의 이점 및 Service Fabric은 배포, 업그레이드, 버전 관리, 롤백 및 상태 모니터링 등의 전체 관리 환경을 제공 합니다.

**Modernize**  
현대화는 컨테이너 화 된 기존 코드와 함께 새 서비스를 추가 합니다. 새 코드를 작성 하려는 경우 마이크로 서비스 경로의 아래로 작은 단계를 수행 하는 것이 적합 합니다. 이 새 REST API 끝점 또는 새 비즈니스 논리 추가 의미할 수 있습니다. 이러한 방식으로 새 마이크로 서비스 구축 및 방법은 개발 및 배포 프로세스를 시작 합니다.

**혁신**  
마이크로 서비스 접근 방식은 변화하는 비즈니스 요구 사항을 수용합니다. 이 단계에서는 서비스에 모놀리식 응용 프로그램을 분할 하거나 혁신을 시작할지 여부를 결정 해야 합니다. 여기는 클래식 예제 워크플로 큐로 사용 중인 데이터베이스 처리 병목 상태가 발생 하는 경우입니다. 워크플로 요청의 수가 증가하므로 작업은 크기에 따라 배포되야 합니다. 크기 조정이 아니라는, 또는 더 자주 업데이트할 마이크로 서비스를 분할 하 고 혁신 해야 하는 응용 프로그램의 해당 특정 부분을 수행 합니다.

**응용 프로그램을 마이크로 서비스로 변환**  
이 단계에서는 응용 프로그램은 완전히 구성 된 (또는으로 분할) 마이크로 서비스. 이 시점에 도달 하는 마이크로 서비스를 시작을 했습니다. 여기에서 시작할 수 있지만 않고도 마이크로 서비스 플랫폼을 활용할 수에 상당한 투자를 해야 합니다.

### <a name="are-microservices-right-for-my-application"></a>마이크로 서비스가 내 애플리케이션에 적합할까요?

아마도 그렇습니다. Microsoft에서 더 많은 팀 비즈니스를 위해 클라우드를 위한 구축을 시작 하는 대로 많은 실현 마이크로 서비스와 유사한 접근 방식의 장점을 합니다. Bing, 예를 들어 사용 마이크로 서비스 년입니다. 다른 팀의 경우 마이크로 서비스 접근 방식은 새로웠습니다. 팀은 핵심 역량이 아니면서 해결이 필요한 까다로운 문제를 찾았습니다. 이 때문에 Service Fabric 서비스 구축을 위한 기술 근거 합니다.

Service Fabric의 목적은 많은 비용이 많이 드는 다시 진행할 필요가 없습니다 있도록 마이크로 서비스 응용 프로그램 구축의 복잡성을 줄이는 것입니다. 처음에는 소규모로 시작해서 고객의 사용량에 따라 확장하고, 서비스를 중단하고, 새 서비스를 추가하고, 발전해 가는 것이 바로 이 접근 방식입니다. 대부분의 개발자들이 더 쉽게 마이크로 서비스에 접근할 수 있게 하기 위해서는 아직 많은 문제들을 해결해야 한다는 점도 알고 있습니다. 컨테이너와 행위자 프로그래밍 모델은 해당 방향으로 나아가기 예입니다. 마이크로 서비스 접근 방식을 쉽게 수행할 수 있도록 더 많은 혁신이 등장할 것 확실 합니다.


## <a name="next-steps"></a>다음 단계

* [마이크로 서비스: 클라우드가 지원하는 애플리케이션 혁명](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/)
* [Azure 아키텍처 센터: Azure에서 마이크로 서비스 구축](https://docs.microsoft.com/azure/architecture/microservices/)
* [Azure Service Fabric 응용 프로그램 및 클러스터에 대 한 모범 사례](service-fabric-best-practices-overview.md)
* [서비스 패브릭 용어 개요](service-fabric-technical-overview.md)

[Image1]: media/service-fabric-overview-microservices/monolithic-vs-micro.png
[Image2]: media/service-fabric-overview-microservices/statemonolithic-vs-micro.png
[Image3]: media/service-fabric-overview-microservices/microservices-migration.png
