
<properties
   pageTitle="상태 저장 서비스 구성 패턴 | Microsoft Azure "
   description="상태 저장 행위자를 사용하여 서비스 호출 간에 상태를 유지 관리하고 이전 서비스 결과를 캐시하는 서비스 패브릭 Reliable Actors 설계 패턴입니다."
   services="service-fabric"
   documentationCenter=".net"
   authors="vturecek"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/05/2015"
   ms.author="vturecek"/>

# Reliable Actors 설계 패턴: 상태 저장 서비스 컴퍼지션

개발자들은 엔터프라이즈 환경에서 N 계층 상태 비저장 서비스를 빌드하는 데 지난 10년 반을 보냈습니다. 데이터베이스를 기반으로 서비스를 작성했습니다. 다른 서비스 기반으로 더 높은 수준의 서비스를 빌드했습니다. 그런 다음 오케스트레이션 엔진 및 메시지 지향 미들웨어를 작성하여 이러한 서비스를 조정했습니다. 사용자 워크로드가 증가하면서 더 많은 상호 작용 또는 규모, 상태 비저장 서비스 지향 아키텍처(SOA)를 요구하는 작업에 약점이 보이기 시작했습니다.

## 이전 방식: SOA 서비스

SOA 서비스가 상태 비저장 특성으로 인해 수평으로 원활하게 확장되었지만 저장소 계층에서 동시성 및 처리량에 병목 현상이 발생했습니다. 이로 인해 저장소 액세스에 점점 더 많은 비용이 들었습니다. 대부분의 개발자는 일반적으로 저장소에 대한 요구를 줄이기 위해 해당 솔루션에 캐싱을 도입했습니다. 하지만 이 솔루션은 단점이 없지 않았습니다. 캐시, 의미 체계의 제한 사항과 변경 사항 및 일관성에 대한 동시 액세스를 관리하는 다른 계층이 필요합니다. [스마트 캐시 패턴에서](service-fabric-reliable-actors-pattern-smart-cache.md) 자세히 설명한 대로 가상 행위자 모델은 이런 문제에 대한 완벽한 솔루션을 제공합니다. 일부 개발자들은 저장소 계층을 복제하여 해당 SOA 문제를 해결하려 합니다. 그러나 이 방법은 확장성이 떨어지고 신속하게 일반적인 경고 프로토콜 경계에 도달합니다.

두 번째 과제는 요구 사항의 변화와 함께 진화되어 왔습니다. 최종 사용자와 기업은 모두 일반적인 몇 초가 아닌 몇 밀리초 내에 요청에 응답할 수 있는 대화형 서비스를 요구합니다. 이 요청을 충족하기 위해 개발자는 다른 서비스를 기반으로 한 façade(퍼사드) 서비스를 작성하기 시작했습니다. 경우에 따라 여러 façade(퍼사드) 서비스가 사용자 중심 서비스를 만들도록 작성되었습니다. 하지만 여러 다운스트림 서비스를 추가하면 대기 시간 문제로 이어집니다.

또한 개발자는 캐시 및 메모리 내 개체 저장소로 전환했습니다. 경우에 따라 성능 요구 사항을 충족하도록 서로 다른 구현을 사용했습니다. 이 접근 방법에서 개발자는 주기적으로 캐시를 작성하는 백 엔드 작업자 프로세스를 일반적으로 작성합니다. 비용이 많이 드는 주문형 캐시 채우기를 최소화됩니다. 그런 다음 해당 작업을 해체하여 비동기 작업을 동기 작업과 분리합니다. 상태 변화에 대응하는 대화형 작업을 위한 더 많은 공간을 얻게 되며 이는 SOA에서 특히 어렵습니다.

또한 종종 큐 및 작업자와 같은 더 많은 계층을 도입합니다. 해당 솔루션에 복잡성을 더 추가할 수 있습니다.

기본적으로 개발자는 "상태" 및 "서비스 동작"을 배치하여 사용자 중심 대화형 환경 문제를 해결하는 "상태 저장 서비스"를 빌드하기 위한 솔루션을 찾고 있습니다. 이러한 서비스에 대한 대체가 아닌 서비스 컴포지션 계층으로 Azure 서비스 패브릭 Reliable Actors가 도입되는 위치입니다.

아래 다이어그램에서는 이 시점이 나와 있습니다.

![Reliable Actors, 서비스 컴퍼지션 및 상태 지속성][1]

## 행위자로 더 나은 솔루션 구현

서비스를 구성하는 경우 행위자는 상태 비저장 또는 상태 저장 중 하나일 수 있습니다.

* 상태 비저장 행위자는 기본 서비스에 대한 프록시로 사용할 수 있습니다. 이러한 행위자는 서비스 패브릭 클러스터 전체에 걸쳐 동적으로 확장할 수 있으며 서비스와 관련된 특정 정보를 캐시할 수 있습니다. 발견되면 해당 끝점을 포함할 수 있습니다.
* 상태 저장 행위자는 캐시 이전 서비스 결과는 물론 서비스 호출 간의 상태도 유지할 수 있습니다. 상태는 지속적이거나 일시적일 수 있습니다.

이 패턴은 다양한 시나리오에 적용할 수 있습니다. 대부분의 경우에서 행위자는 특정 서비스에 작업을 호출하는 외부 호출을 해야 합니다. 전자 상거래 응용 프로그램에서 예제를 사용하여 살펴보겠습니다. 이러한 응용 프로그램은 사용자 프로필 관리, 추천, 장바구니 관리, 위시리스트 관리, 구매를 비롯한 다양한 기능을 제공하는 서비스를 기반으로 합니다.

대부분의 전자 상거래 개발자는 소셜 환경을 개발 하는 것과 비슷한 해당 아키텍처에 사용자 중심 접근을 사용하려고 합니다. 또한 전자 상거래 환경이 주로 사용자와 제품을 중심으로 이루어지기 때문입니다. 개발자 솔루션은 대개 성능상의 이유로 캐시에서 지원될 가능성이 있는 서비스의 façade(퍼사드)를 전달하여 이루어집니다.

행위자 기반 접근 방식을 사용하여 대조합니다. 사용자 행위자는 사용자의 동작(예: 카탈로그 탐색, 제품 선호도 표시, 장바구니에 상품 추가 또는 친구에게 제품 추천)을 나타낼 수 있습니다. 하지만 사용자의 프로필, 장바구니의 상품, 친구가 추천한 상품 목록, 사용자의 구입 내역 및 사용자의 현재 지역적 위치를 비롯한 사용자의 구성된 상태를 나타낼 수도 있습니다.

## 상태 저장 행위자를 사용하여 상태 채우기

우선 사용자 행위자가 여러 서비스에서 해당 상태를 채워야 하는 예를 살펴보겠습니다. [스마트 캐시 패턴에서](service-fabric-reliable-actors-pattern-smart-cache.md) 설명한 모든 내용이 여기에도 해당되므로 여기에 대한 코드 샘플은 제공하지 않습니다. 사용자 행위자는 로그인 시 활성화되고 백 엔드 서비스에서 충분한 데이터로 채워질 수 있습니다. 전체 및 부분 상태는 요청 시, 타이머에서 또는 둘 모두를 사용하여 채워질 수 있고 행위자에 캐시될 수 있습니다. 이 예의 경우, **프로필**과 **위시리스트** 서비스가 아래에 나와 있습니다.

![프로필 및 위시 리스트 서비스][2]

개발자는 자주 사용하는 사용자에 대한 상태를 미리 채우고 로그인 할 때 준비되도록 할 수 있습니다. 또한 개발자는 서비스를 매달 방문하는 사용자가 로그인할 시점의 상태를 채울 수 있습니다. 스마트 캐시 섹션에서 이러한 패턴을 살펴볼 수 있습니다.

(위의 그림에서 보여준 대로)사용자 23이 로그인할 때 사용자 행위자(23)가 이미 활성화되지 않은 경우 활성화됩니다. 그런 다음 사용자 행위자는 백 엔드 서비스에서 관련 사용자 프로필 정보와 위시 리스트를 가져옵니다. 또한 사용자 행위자가 후속 호출에 대해 정보를 캐시할 가능성이 높습니다. 예를 들어 항목이 위시 리스트에 추가되어야 하는 경우 앞에서 설명한 대로 작성하여 달성될 수 있습니다.

이제 사용자가 제품이 마음에 든다는 **좋아요** 단추를 클릭하는 예제를 살펴보겠습니다. 이 작업은 여러 서비스에 대한 여러 호출이 필요할 수 있습니다. 이러한 작업은 카탈로그 서비스에 "좋아요"의 전송, 다음 권장 사항 집합의 트리거 및 소셜 네트워크에 대한 업데이트의 게시를 포함할 수 있습니다.

이 내용은 아래에 나와 있습니다.

![제품과 위시 리스트, 프로필 및 카탈로그 서비스 선호도][3]

## 컴퍼지션 및 비동기 통신에 행위자 사용
서비스 패브릭 Reliable Actors 프로그래밍 모델은 개발자가 비동기 작업과 함께 요청/응답 스타일 작업을 작성하려고 할 때 진가를 발휘합니다. 예를 들어 상품이 마음에 들면 좋다고 한 상품을 사용자의 위시리스트에 즉시 넣는 반면, 소셜 네트워크에 게시하고 다음 추천 작업 집합을 트리거하는 작업은 버퍼 및 타이머를 사용하여 비동기적으로 수행될 수 있습니다.

서비스에 사용자 행위자를 사용하는 또 다른 주요 이점은 행위자가 캐시된 상태에 적합한 위치를 제공한다는 점입니다. 또한 가장 중요하게 행위자는 비동기적으로 상태의 변화에 반응합니다. 이 시나리오가 상태 비저장 서비스에서 특히 까다로운 시나리오입니다. 예를 들어 사용자가 "사용자 여행"의 일환으로 일련의 작업을 수행할 수 있고 이러한 이벤트는 행위자에서 실시간으로 캡처될 수 있습니다. 스트림은 이벤트 시간 또는 행위자의 동작을 변경하는 타이머에서 비동기적으로 쿼리될 수 있도록 조합될 수 있습니다.

이 시점에서 SOA 순수주의자는 끝점이 언어 독립적 프로토콜을 통해 노출되었으므로 행위자의 의미에서 보면 서비스가 아니라는 것을 알아차렸을 것입니다. 서비스 패브릭 Reliable Actors는 상호 운용 구성 요소도, 서비스 상호 운용을 위한 플랫폼도 아닙니다. 그러나 개발자가 행위자를 모델링할 때 또는 동일한 방법으로 문제의 분리를 모델링할 때 SOA 스타일 서비스의 세분성에 관하여 생각하지 못할 것은 없습니다. 이러한 서비스를 마이크로 서비스라고 합니다. 개발자가 REST 또는 SOAP 끝점을 서비스 패브릭 Reliable Actors 앞의 상호 운용 계층으로 배치하지 않도록 방지할 수 없습니다.

또한 상태 저장 서비스 컴퍼지션은 전자 상거래 등과 같은 트랜잭션 시나리오가 아닌 워크플로에 적용됩니다. 서비스 패브릭은 워크플로/오케스트레이션 엔진으로 설계되었습니다. 서비스 상호 작용을 포함하고 이러한 상호 작용의 상태를 유지하는 워크플로를 모델링하는 데 사용될 수 있습니다.

동적 환경을 제공하는 확장 가능한 서비스를 빌드하는 경우 "상태 비저장 서비스"의 단점을 볼 수 있습니다. 서비스 패브릭 Reliable Actors 프로그래밍 모델은 상태 및 동작을 함께 제공하여 개발자들이 기존 투자 환경을 기반으로 확장 가능한 대화형 환경을 빌드하는 데 도움이 됩니다.


## 다음 단계

[패턴: 스마트 캐시](service-fabric-reliable-actors-pattern-smart-cache.md)

[패턴: 분산 네트워크 및 그래프](service-fabric-reliable-actors-pattern-distributed-networks-and-graphs.md)

[패턴: 리소스 관리](service-fabric-reliable-actors-pattern-resource-governance.md)

[패턴: 사물 인터넷](service-fabric-reliable-actors-pattern-internet-of-things.md)

[패턴: 분산 계산](service-fabric-reliable-actors-pattern-distributed-computation.md)

[일부 안티패턴](service-fabric-reliable-actors-anti-patterns.md)

[서비스 패브릭 신뢰할 수 있는 행위자 소개](service-fabric-reliable-actors-introduction.md)


<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-1.png
[2]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-2.png
[3]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-3.png

<!---HONumber=AcomDC_0121_2016-->