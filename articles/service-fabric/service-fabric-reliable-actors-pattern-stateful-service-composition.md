
<properties
   pageTitle="Azure 서비스 패브릭 행위자 상태 저장 서비스 컴퍼지션 디자인 패턴"
   description="상태 저장 행위자를 사용하여 서비스 호출 간에 상태를 유지 관리하고 이전 서비스 결과를 캐시하는 서비스 패브릭 행위자 디자인 패턴입니다. 상태는 지속적이거나 일시적일 수 있습니다."
   services="service-fabric"
   documentationCenter=".net"
   authors="jessebenson"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="04/01/2015"
   ms.author="claudioc"/>

# 서비스 패브릭 행위자 디자인 패턴: 상태 저장 서비스 컴퍼지션
개발자들은 엔터프라이즈 환경에서 N 계층 상태 비저장 서비스를 빌드하는 데 지난 10년 반을 보냈습니다. 데이터베이스를 기반으로 서비스를 빌드하고, 다른 서비스를 기반으로 더 높은 수준의 서비스를 빌드하고, 이러한 서비스를 조정하는 오케스트레이션 엔진과 메시지 중심 미들웨어를 빌드했습니다. 사용자 작업량이 증가하면서 더 많은 상호 작용을 요구하든 또는 규모를 요구하든 상관 없이, 상태 비저장 서비스 중심 아키텍처에서 약점이 나타나기 시작했습니다.

## 이전 방식: SOA 서비스
SOA 서비스가 상태 비저장 특성으로 인해 수평으로 원활하게 확장되었지만 저장소 계층에서 동시성 및 처리량에 병목 현상이 발생했습니다. 저장소 액세스에 점점 더 비용이 많이 들게 되었습니다. 관행 대로 대부분의 개발자가 저장소에 대한 요구를 줄이기 위해 솔루션에 캐싱을 도입했지만 해당 솔루션에 단점이 없는 것이 아니었습니다. 관리해야 하는 또 다른 계층, 캐시에 대한 동시 액세스, 의미 체계의 제한 사항 및 변경, 그리고 마지막으로 일관성의 문제가 발생했습니다. 이전에 스마트 캐시 패턴에서 자세히 설명한 대로, 가상 행위자 모델은 여기에 대한 완벽한 솔루션을 제공합니다.

일부 개발자들은 저장소 계층을 복제하여 문제를 해결하려고 했습니다. 그러나 이 방법은 원활하게 확장하지 못하고 빠르게 CAP 경계에 도달했습니다. 두 번째 과제는 요구 사항의 변화와 함께 진화되어 왔습니다. 예를 들어, 최종 사용자와 기업들은 일반적인 몇 초가 아닌 몇 밀리초 내에 요청에 응답하는 대화형 서비스를 요구하고 있습니다. 이에 부응하여 개발자들은 사용자 중심 서비스를 만들기 위해 다른 서비스, 경우에 따라 수십 개의 서비스를 기반으로 한 외관 서비스를 빌드하기 시작했습니다. 그러나 여러 다운스트림 서비스를 구성하면서 대기 시간 문제가 빠르게 나타났습니다.

또 다시 개발자들은 캐시 및 메모리 내 개체 저장소로 전환했으며, 경우에 따라 성능 요구 사항에 맞게 이를 서로 다르게 구현했습니다. 또한 비용이 많이 드는 필요 시 캐시 채우기를 최소화하기 위해 주기적으로 캐시를 빌드하는 백엔드 작업자 프로세스를 빌드하기 시작했습니다. 마지막으로, SOA에서 특히 어려운, 상태 변화에 반응하는 대화형 작업을 위한 더 많은 여지를 두기 위해 비동기 작업을 동기 작업과 분리하여 작업을 해체하기 시작했습니다.

큐 및 작업자 등과 같이 해당 솔루션에 복잡성을 더 추가하는 계층을 도입했습니다. 기본적으로, 개발자는 "상태 저장 서비스"를 빌드하기 위한 솔루션 즉, "상태"와 "서비스 동작"을 배치하여 사용자 중심 대화형 환경 문제를 해결하는 솔루션을 찾기 시작했습니다. 그리고 이런 이유로 이러한 서비스를 대체하기 위한 것이 아닌 서비스 컴포지션 계층으로 Azure 서비스 패브릭 행위자가 도입되었습니다.

아래 다이어그램에 해당 사항이 나와 있습니다.

![][1]

## 행위자를 사용하는 더 나은 솔루션
서비스를 구성하는 경우, 행위자는 상태 비저장 또는 상태 저장 중 하나일 수 있습니다.

* 상태 비저장 행위자는 기본 서비스에 대한 프록시로 사용할 수 있습니다. 이러한 행위자는 Azure 서비스 패브릭 클러스터 전체에 걸쳐 동적으로 확장할 수 있으며 발견된 후에는 해당 끝점 등의 서비스와 관련된 특정 정보를 캐시할 수 있습니다.
* 상태 저장 행위자는 캐시 이전 서비스 결과는 물론 서비스 호출 간의 상태도 유지할 수 있습니다. 상태는 지속적이거나 일시적일 수 있습니다.

또한 이 패턴은 다양한 시나리오에 적용 가능하며, 대부분의 경우 행위자는 외부 호출을 수행하여 특정 서비스의 작업을 호출해야 합니다. 현대적인 전자 상거래 응용 프로그램을 사용하는 예제를 살펴보겠습니다. 이러한 응용 프로그램은 사용자 프로필 관리, 추천, 장바구니 관리, 위시리스트 관리, 구매 등 다양한 기능을 제공하는 서비스를 기반으로 합니다.

대부분의 개발자는 아키텍처에 대해 사용자 중심 접근 방식을 취하려고 하는데, 이는 전자 상거래 환경이 주로 사용자와 제품 중심으로 이루어지기 때문에 소셜 환경을 개발하는 개발자와 매우 유사합니다. 이는 대개 성능상의 이유로 캐시에서 지원될 가능성이 있는 서비스의 외관을 전달하여 이루어집니다.

이제 행위자 기반 접근 방식에 대해 살펴보겠습니다. 사용자 행위자는 사용자의 동작(예: 카탈로그 탐색, 제품 선호도 표시, 장바구니에 상품 추가, 친구에게 제품 추천)과 더불어 프로필, 장비구니의 상품, 친구가 추천한 상품 목록, 구입 내역, 현재의 지역적 위치 등과 같이 구성된 상태를 모두 나타낼 수 있습니다.

## 상태 저장 행위자 사용
우선 사용자 행위자가 여러 서비스에서 해당 상태를 채워야 하는 예를 살펴보겠습니다. 스마트 캐시 패턴에서 설명한 모든 내용이 여기에도 해당되므로 여기에 대한 코드 샘플은 제공하지 않습니다. 로그인 시 사용자 행위자를 활성화하여 백엔드 서비스의 충분한 데이터로 채울 수 있습니다. 물론, 이 문서의 앞쪽에서 많은 사례를 살펴본 대로 전체 및 부분 상태를 필요 시, 타이머에서 또는 양쪽 모두 조금씩 미리 채우고 행위자에 캐시할 수 있습니다. 이 예의 경우, 프로필과 위시리스트가 아래에 나와 있습니다.

![][2]

예를 들어, 자주 사용자의 상태를 미리 채워 서비스를 매달 방문하는 사용자를 위한 로그인 준비를 완료하거나 로그인 시 채울 수 있습니다. 스마트 캐시 섹션에서 이러한 패턴을 살펴보았습니다.

User 23이 로그인할 때 아직 활성화되어 있지 않으면 사용자 행위자(23)가 활성화되고 백엔드 서비스에서 관련 사용자 프로필 정보와 위시리스트 목록을 가져옵니다. 사용자 행위자가 후속 호출에 대해 정보를 캐시할 가능성이 높습니다. 또한 예를 들어, 위시리스트에 상품을 추가해야 하는 경우, 앞서 설명한 대로 write-behind 또는 write-through를 수행할 수 있습니다. 두 번째로 사용자가 "like" 단추를 클릭하여 제품이 좋다고 하는 예를 살펴보겠습니다. 이 작업에는 아래 그림과 같이 여러 서비스에 대한 복수의 호출이 필요할 수 있습니다. 카탈로그 서비스에 "like"를 보내고, 다음 추천 세트를 트리거하고, 소셜 네트워크에 업데이트를 게시합니다.

이 내용은 아래에 나와 있습니다.

![][3]

## 행위자 컴퍼지션 및 비동기 통신이 도움을 주는 방법
사실, Azure 서비스 패브릭 행위자는 비동기 작업과 함께 요청/응답 스타일 작업을 작성하려고 할 때 진가를 발휘합니다. 예를 들어 "Like Product"는 좋다고 한 상품을 사용자의 위시리스트에 즉시 넣는 반면, 소셜 네트워크에 게시하고 다음 추천 세트를 트리거하는 작업은 버퍼 및 타이머를 사용하는 비동기 작업일 수 있습니다.

서비스에서 사용자 행위자를 사용했을 때의 다른 주요 이점 중 하나가 행위자가 캐시된 상태에 대한 자연적인 위치를 제공하고, 가장 중요한 것은 비동기적인 상태 변화에 대한 대응을 제공한다는 것입니다. 이 시나리오가 상태 비저장 서비스에서 특히 까다로운 시나리오입니다. 예를 들어, 사용자는 일련의 동작, 아마도 "user journey"의 일부를 수행합니다. 이러한 이벤트는 행위자에서 실시간으로 캡처할 수 있으며 스트림을 어셈블할 수 있습니다. 따라서 이벤트 시간에 또는 행위자의 동작을 변경하는 타이머에서 비동기로 쿼리할 수 있습니다.

이 시점에서 SOA 순수주의자는 끝점이 언어 독립적 프로토콜을 통해 노출되었으므로 행위자의 의미에서 보면 서비스가 아니라는 것을 알아차렸을 것입니다. Azure 서비스 패브릭 행위자는 상호 운용 구성 요소도, 서비스 상호 운용을 위한 플랫폼도 아닙니다. 그럼에도 불구하고 행위자를 모델링할 때 또는 동일한 방법으로 문제의 분리를 모델링할 때 SOA 스타일 서비스의 세분성에 관하여 생각하지 못할 것은 없습니다. 이러한 서비스를 "마이크로 서비스"라고 합니다. 마찬가지로, REST 끝점 또는 SOAP 끝점을 Azure 서비스 패브릭 행위자 전면에 상호 운용 계층으로 배치하는 것을 막을 것은 아무 것도 없습니다.

또한 상태 저장 서비스 컴퍼지션은 워크플로에 적용되며 전자 상거래 등과 같은 트랜잭션 시나리오에만 적용되는 것은 아닙니다. Azure 서비스 패브릭은 워크플로/오케스트레이션 엔진으로 디자인되었으므로, 서비스 상호 작용을 포함하는 워크플로를 모델링하고 이러한 상호 작용의 상태를 유지 관리할 수 있습니다.

동적 환경을 제공하는 확장 가능한 서비스를 빌드할 때 "상태 비저장 서비스"의 단점을 볼 수 있습니다. Azure 서비스 패브릭 행위자는 기본적으로 상태 및 동작을 함께 제공하여 개발자들이 기존 투자 환경을 기반으로 확장 가능한 대화형 환경을 빌드하도록 지원합니다.


## 다음 단계
[패턴: 스마트 캐시](service-fabric-reliable-actors-pattern-smart-cache.md)

[패턴: 분산 네트워크 및 그래프](service-fabric-reliable-actors-pattern-distributed-networks-and-graphs.md)

[패턴: 리소스 관리](service-fabric-reliable-actors-pattern-resource-governance.md)

[패턴: 사물 인터넷](service-fabric-reliable-actors-pattern-internet-of-things.md)

[패턴: 분산 계산](service-fabric-reliable-actors-pattern-distributed-computation.md)

[일부 패턴 방지](service-fabric-reliable-actors-anti-patterns.md)

[서비스 패브릭 행위자 소개](service-fabric-reliable-actors-introduction.md)


<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-1.png
[2]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-2.png
[3]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-3.png
 

<!---HONumber=July15_HO2-->