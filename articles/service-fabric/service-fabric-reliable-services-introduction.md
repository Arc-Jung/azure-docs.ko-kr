---
title: "Service Fabric의 신뢰할 수 있는 서비스 프로그래밍 모델 개요 | Microsoft Docs"
description: "서비스 패브릭의 신뢰할 수 있는 서비스 프로그래밍 모델에 대해 알아보고 사용자 고유의 서비스 작성을 시작합니다."
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek; mani-ramaswamy
ms.assetid: 0c88a533-73f8-4ae1-a939-67d17456ac06
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 03/25/2016
ms.author: masnider;vturecek
translationtype: Human Translation
ms.sourcegitcommit: 219dcbfdca145bedb570eb9ef747ee00cc0342eb
ms.openlocfilehash: 843ad30a895a0cf6d427acfc99b17a4facb9e809


---
# <a name="reliable-services-overview"></a>신뢰할 수 있는 서비스 개요
Azure 서비스 패브릭은 상태 비저장 및 상태 저장 신뢰할 수 있는 서비스의 작성과 관리를 단순화합니다. 이 문서에 대해 이야기합니다.

* 상태 비저장 및 상태 저장 서비스를 위한 신뢰할 수 있는 서비스 프로그래밍 모델.
* 신뢰할 수 있는 서비스를 작성할 때 선택해야 하는 옵션.
* 신뢰할 수 있는 서비스를 사용할 때의 일부 시나리오 및 예와 신뢰할 수 있는 서비스를 작성하는 방법.

신뢰할 수 있는 서비스는 서비스 패브릭에서 사용할 수 있는 프로그래밍 모델 중 하나입니다. 신뢰할 수 있는 행위자 프로그래밍 모델에 대한 자세한 내용은 [서비스 패브릭 신뢰할 수 있는 행위자 소개](service-fabric-reliable-actors-introduction.md)를 참조하세요.

서비스 패브릭에서 서비스는 구성, 응용 프로그램 코드, 그리고 선택적 상태로 구성됩니다.

서비스 패브릭은 [서비스 패브릭 응용 프로그램 관리](service-fabric-deploy-remove-applications.md)를 통해 프로비저닝 및 배포에서 업그레이드 및 삭제까지 서비스의 수명을 관리합니다.

## <a name="what-are-reliable-services"></a>신뢰할 수 있는 서비스는 무엇입니까?
Reliable Services는 단순하고 강력한 최고 수준의 프로그래밍 모델을 제공하여 응용 프로그램에 중요한 내용을 나타낼 수 있도록 합니다. 신뢰할 수 있는 서비스 프로그래밍 모델은 다음을 제공합니다.

* 상태 저장 서비스의 경우 신뢰할 수 있는 서비스 프로그래밍 모델을 통해 신뢰할 수 있는 컬렉션을 사용하여 일관되고 안정적으로 서비스 내에 상태를 바로 저장할 수 있습니다. C# 컬렉션을 사용해본 적이 있는 사람에게 친숙한 고가용성 컬렉션 클래스의 간단한 집합입니다. 일반적으로 서비스는 신뢰할 수 있는 상태 관리를 위한 외부 시스템이 필요합니다. 신뢰할 수 있는 컬렉션을 사용하면 고가용성 외부 저장소에 기대하게 되는 것과 동일한 고가용성 및 안정성과 함께, 컴퓨터와 상태가 제공하는 공동 배치되는 추가 대기 시간 향상과 함께 대기 컴퓨터 옆에 상태를 저장할 수 있습니다.
* 기존에 사용하던 프로그래밍 모델과 비슷한 사용자 고유의 코드를 실행하기 위한 간단한 모델. 사용자의 코드에는 잘 정의된 진입점과 쉽게 관리되는 수명 주기가 있습니다.
* 플러그형 통신 모델. [Web API](service-fabric-reliable-services-communication-webapi.md), WebSockets, 사용자 지정 TCP 프로토콜 등과 함께 HTTP와 같은 원하는 전송 프로토콜을 사용합니다. 신뢰할 수 있는 서비스는 훌륭한 기본 옵션을 제공하거나 직접 만들 수 있게 지원합니다.

## <a name="what-makes-reliable-services-different"></a>신뢰할 수 있는 서비스가 다른 서비스와 다른 점은 무엇입니까?
서비스 패브릭의 신뢰할 수 있는 서비스는 이전에 작성하던 서비스와 다릅니다. 서비스 패브릭은 안정성, 가용성, 일관성 및 확장성을 제공합니다.  

* **안정성**--컴퓨터가 실패하거나 네트워크 문제가 발생한 안정적이지 않은 환경에서도 서비스가 제공됩니다.
* **가용성**--연결 가능하고 응답성이 뛰어난 서비스가 됩니다. (외부에서 찾을 수 없거나 연결할 수 없는 서비스를 가질 수 없음을 의미하지 않습니다.)
* **확장성**-–서비스가 특정 하드웨어에서 분리되고, 하드웨어 또는 가상 리소스의 추가 또는 제거를 통해 필요에 따라 확장 또는 축소될 수 있습니다. 서비스의 독립적인 부분이 독립적으로 크기 조정되고 오류에 반응할 수 있도록 손쉽게 분할됩니다(특히 상태 저장 상태에서). 마지막으로 서비스 패브릭은 전체 OS 인스턴스를 특정 워크로드의 단일 인스턴스로 요구 또는 지정하기보다는 단일 프로세스 내에 수천 개의 서비스가 프로비저닝될 수 있도록 하여 서비스가 가벼워지도록 합니다.
* **일관성**--이는 이 서비스에 저장된 모든 정보의 일관성을 보장할 수 있습니다(이 상태 저장 서비스에만 적용됨 - 자세한 내용은 나중에 설명).

## <a name="service-lifecycle"></a>서비스 수명 주기
서비스가 상태 저장 서비스이든, 상태 비저장 서비스이든, 신뢰할 수 있는 서비스는 신속하게 코드를 연결하고 시작할 수 있는 간단한 수명 주기를 제공합니다.  서비스를 시작 및 실행하기 위해 구현해야 하는 메서드가 실제로 한두 개뿐입니다.

* **CreateServiceReplicaListeners/CreateServiceInstanceListeners** - 서비스에서 사용할 통신 스택을 정의합니다. [Web API](service-fabric-reliable-services-communication-webapi.md)와 같은 통신 스택은 수신 끝점 또는 서비스(클라이언트가 도달하는 방법)에 대한 끝점을 정의합니다. 또한 메시지가 서비스 코드의 나머지 부분과 상호 작용하는 끝점을 표시하는 방법을 정의합니다.
* **RunAsync** - 서비스가 비즈니스 논리를 실행할 수 있는 위치입니다. 제공되는 취소 토큰은 해당 작업이 중지되어야 하는 경우에 대한 신호입니다. 예를 들어 지속적으로 ReliableQueue에서 메시지를 빼내 처리해야 하는 서비스가 있는 경우 여기에서 해당 작업이 수행되어야 합니다.

### <a name="service-startup"></a>서비스 시작
신뢰할 수 있는 서비스의 수명 주기에서 주요 이벤트는 다음과 같습니다.

1. 서비스 개체(상태 비저장 서비스 또는 상태 저장 서비스에서 파생되는 것)가 구성됩니다.
2. `CreateServiceReplicaListeners`/`CreateServiceInstanceListeners` 메서드가 호출되고, 서비스가 선택한 하나 이상의 통신 수신기를 반환할 수 있게 됩니다.
   
   * 선택적이지만 대부분의 서비스는 일부 끝점을 직접 노출합니다.
3. 통신 수신기가 생성되면 열립니다.
   
   * 통신 수신기는 이때 호출되고 서비스의 수신 대기 주소를 반환하는 `OpenAsync()`(이)라는 메서드가 있습니다. 신뢰할 수 있는 서비스가 ICommunicationListener에 내장된 것 중 하나를 사용할 경우 자동으로 처리됩니다.
4. 통신 수신기가 열리면 기본 서비스의 `RunAsync()` 메서드가 호출됩니다.
   
   * `RunAsync()` 은(는) 선택 사항입니다. 서비스가 모든 작업을 사용자 호출에 대한 응답으로만 직접 수행할 경우 `RunAsync()`을(를) 구현할 필요가 없습니다.

### <a name="service-shutdown"></a>서비스 종료
서비스가 종료되면(삭제되고, 업그레이드되거나 이동) 호출 순서는 미러링됩니다. 먼저 `RunAsync()`가 보유한 취소 토큰이 취소된 다음 통신 수신기에서 `CloseAsync()`이(가) 호출됩니다.

상태 저장 서비스의 종료에 대한 몇 가지 중요한 사항이 있습니다.

* Service Fabric은 `CloseAsync` 및 `RunAsync`가 반환될 때까지 서비스의 다른 복제본을 기본 상태로 승격하지 않습니다. 기본 제공 통신 수신기를 사용하는 경우 `CloseAsync` 메서드는 자동으로 처리됩니다.
* 이러한 메서드에서 반환에는 시간 제한이 없으며 신뢰할 수 있는 컬렉션에 작성할 수 있는 기능이 즉시 손실되고 모든 실제 작업을 완료할 수 없습니다. 취소 요청을 받는 즉시 최대한 신속하게 반환하는 것이 좋습니다.

## <a name="example-services"></a>예제 서비스
이 프로그래밍 모델을 알았으니 두 가지 서비스를 간단히 살펴보고 어떻게 연동되는지 알아보겠습니다.

### <a name="stateless-reliable-services"></a>상태 비저장 신뢰할 수 있는 서비스
상태 비저장 서비스는 말 그대로 서비스 내에 상태가 유지되지 않거나 존재하는 상태가 완전히 삭제 가능하고 동기화, 복제, 지속 또는 고가용성이 필요하지 않습니다.

예를 들어 메모리가 없고 모든 용어 및 수행할 작업을 한 번에 수신하는 계산기를 가정해 보겠습니다.

이 경우 서비스가 수행 야 하는 백그라운드 작업 처리가 없으므로 서비스의 RunAsync()가 비어 있을 수 있습니다. 계산기 서비스가 생성되면 일부 포트에서 수신 대기 끝점을 여는 CommunicationListener(예: [Web API](service-fabric-reliable-services-communication-webapi.md))를 반환합니다. 이 수신 대기 끝점은 계산기의 공용 API를 정의하는 다른 메서드(예: "Add(n1, n2)")에 연결됩니다.

클라이언트에서 호출이 수행되면 적절한 메서드가 호출되고 계산기 서비스가 제공된 데이터에 대한 작업을 수행하고 결과를 반환합니다. 상태를 저장하지 않습니다.

모든 내부 상태를 저장하지 않으므로 이 계산기 예제는 매우 간단해집니다. 하지만 대부분의 서비스는 상태 비저장이 아닙니다. 대신 다른 저장소에 상태를 외장화합니다. (예를 들어 백업 저장소 또는 캐시에 세션 상태 유지에 의존하는 모든 웹앱은 완전한 상태 비저장이 아닙니다.)

서비스 패브릭에서 상태 비저장 서비스가 사용되는 방법의 일반적인 예로 웹 응용 프로그램에 대한 공용 API를 노출하는 프런트 엔드가 있습니다. 프런트 엔드 서비스는 상태 저장 서비스에 사용자의 요청을 완료하라고 말합니다. 이 경우 상태 비저장 서비스가 수신 대기 중인 알려진 포트(예: 80)에 클라이언트의 호출이 전송됩니다. 이 상태 비저장 서비스는 호출을 받고 해당 호출이 신뢰할 수 있는 대상에서 왔는지, 그리고 어떤 서비스를 대상으로 하는지 확인합니다.  그런 다음 상태 비저장 서비스는 상태 저장 서비스의 올바른 파티션으로 호출을 전달하고 응답을 대기합니다. 상태 비저장 서비스가 응답을 받으면 원래 클라이언트에 다시 응답합니다.

### <a name="stateful-reliable-services"></a>상태 저장 신뢰할 수 있는 서비스
상태 저장 서비스는 상태의 일부분이 일관적으로 유지되고 순서대로 있어야 서비스가 작동할 수 있습니다. 수신하는 업데이트에 따라 일부 값의 이동 평균을 지속적으로 계산하는 서비스를 고려할 수 있습니다. 이 서비스를 수행하려면 처리해야 하는 수신 요청의 현재 집합과 현재 평균이 있어야 합니다. 정보를 검색, 처리하고 외부 저장소(예: Azure Blob 또는 현재 테이블 저장소)에 저장하는 모든 서비스는 상태 저장입니다. 외부 상태 저장소에 상태를 보관합니다.

오늘날 대부분의 서비스는 외부에 상태를 저장합니다. 외부 저장소는 해당 상태에 대한 안정성, 가용성, 확장성 및 일관성을 제공하기 때문입니다. 서비스 패브릭에서 상태 저장 서비스는 자신의 상태를 외부적으로 저장할 필요가 없습니다. 서비스 패브릭은 서비스 코드 및 서비스 상태에 대한 이러한 요구 사항을 모두 처리합니다.

이미지에서 수행되어야 하는 일련의 변환과 변환해야 하는 이미지에 대한 요청을 받은 서비스를 작성하려는 경우를 가정해 보겠습니다.  이 서비스의 경우 통신 포트를 열고 `ConvertImage(Image i, IList<Conversion> conversions)`와(과) 같은 API를 통해 제출을 허용하는 통신 수신기(Web API로 가정)를 반환합니다. 이 API에서 서비스는 정보를 받고 ReliableQueue에 요청을 저장한 후 요청을 추적할 수 있도록 클라이언트에 일부 토큰을 반환합니다(요청에 오랜 시간이 걸릴 수 있으므로).

이 서비스에서는 RunAsync가 더 복잡해질 수 있습니다. 이 서비스는 RunAsync 내부에 IReliableQueue에서 요청을 가져오고, 나열된 변환을 수행하고, 클라이언트가 다시 연결될 때 변환된 이미지를 얻을 수 있도록 IReliableDictionary에 결과를 저장하는 루프가 있습니다. 어떤 오류가 발생해도 이미지가 손실되지 않도록 하기 위해 이 신뢰할 수 있는 서비스는 큐에서 요청을 가져오고, 변환을 수행하고, 트랜잭션에 결과를 저장합니다. 이 경우 변환이 완료되면 메시지는 큐 및 결과 사전에 저장된 결과에서만 실제로 제거됩니다. 중간에 실패하면(이 코드의 인스턴스가 실행 중인 컴퓨터처럼) 요청이 큐에 남아서 다시 처리될 때까지 대기합니다.

이 서비스에 대해 알아두어야 할 한 가지는 일반 .NET 서비스처럼 보인다는 것입니다. 유일한 차이점은 사용 중인 데이터 구조(IReliableQueue 및 IReliableDictionary)를 서비스 패브릭에서 제공하므로 안정성, 가용성 및 일관성이 매우 높다는 점입니다.

## <a name="when-to-use-reliable-services-apis"></a>신뢰할 수 있는 서비스 API를 사용해야 하는 경우
응용 프로그램 서비스 요구 사항이 다음에 해당할 경우 신뢰할 수 있는 서비스 API를 고려해야 합니다.

* 여러 상태 단위(예: 주문 및 주문 품목)에 대한 응용 프로그램 동작을 제공해야 합니다.
* 응용 프로그램의 상태를 신뢰할 수 있는 사전 및 큐로 자연스럽게 모델링할 수 있습니다.
* 상태의 액세스 대기 시간이 짧고 가용성이 높아야 합니다.
* 응용 프로그램이 신뢰할 수 있는 하나 이상의 컬렉션에서 동시성 또는 트랜잭션 처리 작업의 세분성을 제어해야 합니다.
* 서비스에 대한 통신을 제어하고 분할 체계를 제어하고자 합니다.
* 코드에 자유 스레드된 런타임 환경이 필요합니다.
* 응용 프로그램이 런타임에 신뢰할 수 있는 사전 또는 큐를 동적으로 만들거나 삭제해야 합니다.
* 서비스 패브릭에서 서비스의 상태에 대해 제공하는 백업 및 복원 기능을 프로그래밍 방식으로 제어해야 합니다.*
* 응용 프로그램에서 상태 단위에 대한 변경 기록을 유지 관리해야 합니다.*
* 사용자 지정 상태 제공자를 직접 개발하거나 타사를 통해 개발하고자 합니다.*

> [!NOTE]
> *SDK 일반 가용성에서 사용 가능한 기능.
> 
> 

## <a name="next-steps"></a>다음 단계
* [Reliable Services 빠른 시작](service-fabric-reliable-services-quick-start.md)
* [신뢰할 수 있는 서비스 고급 사용법](service-fabric-reliable-services-advanced-usage.md)
* [신뢰할 수 있는 행위자 프로그래밍 모델](service-fabric-reliable-actors-introduction.md)




<!--HONumber=Nov16_HO3-->


