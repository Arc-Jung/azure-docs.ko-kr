<properties
   pageTitle="Azure 서비스 패브릭 행위자의 패턴 및 안티패턴 도입"
   description="서비스 패브릭 행위자에서 잘 작동되는 패턴 디자인"
   services="service-fabric"
   documentationCenter=".net"
   authors="jessebenson"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/11/2015"
   ms.author="claudioc"/>

# 신뢰할 수 있는 행위자 디자인 패턴 소개
서비스 패브릭의 신뢰할 수 있는 행위자 프로그래밍 모델은 클라우드 범위에서 실제 문제를 해결하는 행위자 모델을 기반으로 하여 구축된 플랫폼입니다. Azure 서비스 패브릭은 클라우드와 온-프레미스에서 개발하기 쉽고 관리하기 쉬우며 신뢰성이 뛰어나고 확장 가능한 응용 프로그램을 빌드하기 위한 플랫폼입니다. 이 문서는 실제적인 문제에 대한 실용적인 정보로 제공됩니다. 다양한 패턴을 잘 살펴보면 서비스 패브릭 행위자 모델을 사용하여 "엔터프라이즈" 또는 "클라우드" 솔루션을 빌드하는 방법을 알 수 있습니다.

## 패턴
이 섹션에서는 고객과의 작업 중에 활용했던 일련의 패턴 및 관련 시나리오를 제공합니다. 이러한 패턴은 고객이 Microsoft Azure에서 빌드 중인 광범위한 솔루션에 적용할 수 있는 문제의 클래스를 나타냅니다. 시나리오가 실제 사례를 기반으로 하지만 독자들이 패턴을 명확하게 알 수 있도록 대부분의 도메인 관련 문제를 제거했습니다. 따라서 많은 샘플 코드가 단순하거나 명확하다는 것을 알 수 있습니다. 완전성을 위해 해당 코드를 포함했으며 특별한 인상을 주기 위한 것은 아닙니다.

이 문서에 나온 패턴은 표준 또는 포괄적으로 사용할 수 있는 것은 아닙니다. 다른 개발자들은 같은 문제 또는 패턴을 여기에 나온 것과 다른 방식으로 해결할 수 있습니다.

[패턴: 스마트 캐시](service-fabric-reliable-actors-pattern-smart-cache.md)

[패턴: 분산 네트워크 및 그래프](service-fabric-reliable-actors-pattern-distributed-networks-and-graphs.md)

[패턴: 리소스 관리](service-fabric-reliable-actors-pattern-resource-governance.md)

[패턴: 상태 저장 서비스 컴퍼지션](service-fabric-reliable-actors-pattern-stateful-service-composition.md)

[패턴: 사물 인터넷](service-fabric-reliable-actors-pattern-internet-of-things.md)

[패턴: 분산 계산](service-fabric-reliable-actors-pattern-distributed-computation.md)

[일부 패턴 방지](service-fabric-reliable-actors-anti-patterns.md)

### 행위자 및 간단한 역사 알아보기
행위자 모델의 기원이 되는 Hewitt et al의 [논문](http://dl.acm.org/citation.cfm?id=1624804)은 1973년에 발표되었으며 행위자 모델이 분산 시스템에서 동시성과 복잡성을 처리하는 수단으로 관심을 끌게 된 것은 비교적 최근의 일입니다. 행위자 모델은 서로 격리되어 있는 미세하게 세분화된 개별 개체(행위자)를 지원합니다. 비동기 메시지 전달을 통해 통신하므로 행위자 간의 직접 통신이 가능합니다. 행위자는 단일 스레드 의미 체계를 사용하여 실행됩니다. 행위자 상태의 캡슐화 및 다른 행위자로부터의 격리 기능이 결합되어 행위자 코드에서의 동시성 문제를 제거하여 고도의 병렬 시스템을 간단하게 작성할 수 있습니다. 행위자는 사용 가능한 하드웨어 리소스 풀에서 동적으로 만들어집니다.

[Erlang](http://www.erlang.org/)은 행위자 모델에서 가장 인기 있는 구현입니다. 개발자는 해당 행위자 모델을 재발견하기 시작했으며, 이는 Erlang에 대한 새로운 관심과 더불어 [Scala](http://www.scala-lang.org/) 행위자, [Akka](http://akka.io), [Akka.net](http://getakka.net/), [DCell](http://research.microsoft.com/pubs/75988/dcell.pdf) 등과 같은 새로운 Erlang식 솔루션의 생성을 자극했습니다.

## Azure 서비스 패브릭에 대해 간단히 살펴보기
Azure 패브릭 행위자는 Erlang 및 분산 개체 시스템에서 일부 아이디어를 차용하고 행위자 간접 참조 계층을 추가하고 Azure 서비스 패브릭 플랫폼을 활용하는 통합된 프로그래밍 모델에 노출시켜 행위자 모델을 구현한 것입니다.

Azure 패브릭 행위자의 주요 이점은 1) **개발자의 생산성**(비전문 프로그래머인 경우도 해당), 2) 프로그래머가 특별히 시간을 투자하지 않아도 가능한 **기본적으로 투명한 확장성**입니다. Azure 패브릭 행위자는 Azure 패브릭과 복잡한 분산 응용 프로그램을 훨씬 쉽게 개발하고 디자인 시 결과 응용 프로그램을 확장 가능하게 만드는 도구에서 실행되는 .NET 라이브러리입니다. 이들 각 이점은 아래와 같이 확장됩니다. Azure 패브릭 행위자 프로그래밍 모델은 다음과 같은 주요 추상화, 보증 및 시스템 서비스를 제공하여 전문 및 비전문 프로그래머의 생산성을 증가시킵니다.

* *친숙한 개체 지향 프로그래밍(OOP) 패러다임*. 행위자는 비동기 메서드 및 속성을 사용하여 .NET 행위자 인터페이스 선언을 구현하는 .NET 클래스입니다. 따라서 행위자는 프로그래머에게 메서드/속성을 직접 호출할 수 있는 원격 개체로 표시됩니다. 따라서 메서드 호출을 메시지로 전환하고, 올바른 끝점으로 라우팅하고, 대상 행위자의 메서드를 호출하고, 완벽하게 투명한 방식으로 오류 및 비정상적인 사례를 처리하여 프로그래머에게 친숙한 OOP 패러다임을 제공합니다.

* *행위자의 단일 스레드 실행.* Azure 패브릭 런타임은 행위자가 한번에 둘 이상의 스레드를 실행하지 않는다는 것을 보장합니다. 다른 행위자와의 격리 기능이 결합되어 있기 때문에 프로그래머는 행위자 수준에서 절대 동시성에 직면하지 않으므로 공유 데이터에 대한 액세스를 제어하기 위해 잠금 또는 다른 동기화 메커니즘을 사용할 필요가 없습니다. 이 기능만으로도 비전문 프로그래머가 분산 응용 프로그램의 개발을 쉽게 할 수 있습니다.

* *투명한 활성화.* Azure 패브릭 런타임은 처리할 메시지가 있을 때만 필요에 따라 행위자를 활성화합니다. 이를 통해 응용 프로그램 코드에 대한 가시성을 제공하고 응용 프로그램 코드에서 제거되는, 행위자의 논리적 생성 표기법과 응용 프로그램에 투명한 메모리 내 행위자의 실제 활성화를 명확하게 구분합니다. Azure 패브릭 행위자는 행위자를 "페이지 아웃"(비활성화) 또는 “페이지 인"(활성화)하는 시기를 결정한다는 점에서 가상 메모리와 비슷합니다. 응용 프로그램에는 특정 시점에 실제 메모리에 있는지 여부와 상관 없이 논리적으로 만든 행위자의 전체 "메모리 공간"에 대해 중단 없이 액세스합니다. 투명한 활성화를 사용하면 전체 하드웨어 리소스 풀에서 행위자의 배치와 마이그레이션을 통해 동적인 적응형 부하 분산이 가능합니다.

* *위치 투명성.* 프로그래머가 행위자의 메서드를 호출하거나 다른 구성 요소에 전달하는 데 사용하는 행위자 참조(프록시 개체)는 행위자의 논리적 ID만 포함합니다. 행위자의 논리적 ID를 물리적 위치로 변환하는 작업과 해당 메시지 라우팅은 Azure 패브릭 런타임에서 투명하게 수행됩니다. 응용 프로그램 코드는 물리적 위치가 명확한 행위자와 통신하므로 오류 또는 리소스 관리로 인해 또는 호출 시 행위자가 비활성화되어 있기 때문에 시간이 지남에 변경될 수 있습니다.

* *영구 저장소와의 투명한 통합.* Azure 패브릭 행위자를 사용하면 행위자의 메모리 내 상태를 영구 저장소로 선언적으로 매핑할 수 있습니다. 업데이트를 동기화하므로 영구 상태가 성공적으로 업데이트된 후에만 호출자가 투명하게 결과를 받을 수 있습니다.

* *높은 가용성, 장애 조치 지원 및 응용 프로그램 수명 주기 관리.* Azure 패브릭 행위자의 상태는 플랫폼에서 관리하며 클러스터의 노드에서 오류가 발생한 경우 복원할 수 있도록 하는 방식으로 복제됩니다. 또한 Azure 서비스 패브릭은 응용 프로그램 수명 주기를 관리하고 중단 시간 없는 응용 프로그램 업그레이드를 가능하게 해줍니다. Azure 패브릭 행위자 프로그래밍 모델은 프로그래머가 응용 프로그램 또는 서비스를 몇 배 높은 규모로 성공적으로 확장할 수 있도록 안내하기 위해 마련되었습니다. 이 작업은 입증된 모범 사례와 패턴을 통합하고 더 낮은 수준의 시스템 기능을 효율적으로 구현하여 수행됩니다. Azure 패브릭 응용 프로그램의 확장성과 성능을 사용할 수 있게 해주는 일부 주요 요소는 다음과 같습니다.

* *응용 프로그램 상태의 암시적 미세 분할.* 행위자를 직접 주소 지정 가능한 엔터티로 사용하면 프로그래머는 암시적으로 응용 프로그램의 전반적인 상태를 세분화할 수 있습니다. Azure 패브릭 행위자 프로그래밍 모델에서는 행위자의 규모를 정하지 않지만 대부분의 경우 상대적으로 많은 수(수백만 개 이상)의 행위자를 갖게 되며, 각각은 사용자 계정, 구매 주문서 등과 같은 응용 프로그램의 적절한 엔터티를 나타냅니다. 개별적으로 주소 지정 가능한 행위자 및 런타임에 의해 추상화된 물리적 위치를 통해 Azure 패브릭 행위자는 부하 분산 및 응용 프로그램 개발자를 생각하지 않고 투명하고 일반적인 방법으로 핫 스폿을 처리하는 높은 유연성을 갖습니다.

* *적응형 리소스 관리.* 행위자가 위치 투명성 때문에 상호 작용하는 다른 행위자의 위치에 대한 어떠한 가정도 하지 않는 Azure 패브릭 런타임은 들어오는 요청에 대한 실패 없이 부하 및 통신 패턴에 반응하여 계산 클러스터 전체에 걸쳐 행위자의 배치/마이그레이션에 대한 세부적인 결정을 내려 매우 동적인 방식으로 사용 가능한 HW 리소스의 할당을 관리 및 조정할 수 있습니다. 특정 행위자의 여러 복제본을 만들면 런타임에서 응용 프로그램 코드를 변경하지 않고도 필요한 경우 행위자의 처리량을 증가시킬 수 있습니다.

* *멀티플렉스 통신.* Azure 패브릭의 행위자는 논리적 끝점을 가지고 있으며 그 사이의 메시징은 전체-전체 간 물리적 연결(TCP 소켓)의 고정 세트를 통해 멀티플렉스됩니다. 따라서 Azure 패브릭 행위자 런타임은 행위자별 OS 오버헤드 없이 주소 지정 가능한 수많은 엔터티(수백만 개)를 호스트할 수 있습니다. 또한 행위자의 활성화/비활성화는 TCP 포트 또는 HTTP URL과 같은 물리적 끝점의 등록/등록 취소 비용이 발생하지 않습니다.

* *효율적인 예약.* Azure 패브릭 런타임은 물리적 프로세서 코어별로 스레드를 사용하여 사용자 지정 스레드 풀에서 많은 수의 단일 스레드 행위자 실행을 예약합니다. 비차단 연속 기반 스타일(Azure 패브릭 행위자 프로그래밍 모델의 요구 사항)로 작성된 행위자 코드가 있는 응용 프로그램 코드는 매우 효율적이고 "협조적"인 다중 스레드 방식으로 경합 없이 실행됩니다. 따라서 높은 처리량에 도달하여 매우 높은 CPU 사용률(최대 90 + %)로 시스템을 실행할 수 있습니다. 시스템 및 부하에서 행위자의 수가 증가해도 추가 스레드 또는 다른 OS 기본 요소가 발생하지 않는다는 사실은 개별 노드 및 전체 시스템의 확장성에 큰 도움이 됩니다.

* *명시적 비동기.* Azure 패브릭 행위자 프로그래밍 모델은 분산 응용 프로그램의 비동기 특성을 명시적으로 만들고 비차단 비동기 코드를 작성할 수 있도록 프로그래머를 지원합니다. 따라서 명시적으로 다중 스레드를 사용하지 않고도 크게 분산 병렬 처리 및 전체 처리가 가능합니다.

<!---HONumber=August15_HO7-->