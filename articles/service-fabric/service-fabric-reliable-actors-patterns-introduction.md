<properties
   pageTitle="Reliable Actors 패턴 및 안티패턴 | Microsoft Azure"
   description="행위자 프로그래밍 모델의 개요, 서비스 패브릭 Reliable Actors에서 잘 작동되는 설계 패턴 및 피해야 할 몇 가지 안티패턴에 대해 간략히 설명합니다."
   services="service-fabric"
   documentationCenter=".net"
   authors="vturecek"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/11/2015"
   ms.author="vturecek"/>

# 신뢰할 수 있는 행위자 디자인 패턴 소개

Azure 서비스 패브릭에서 Reliable Actors 프로그래밍 모델은 클라우드 범위에서 실제 문제를 해결하는 행위자 모델을 기반으로 하여 구축된 플랫폼입니다. 서비스 패브릭은 클라우드와 온-프레미스에서 개발하기 쉽고 관리하기 쉬우며 신뢰성이 뛰어나고 확장 가능한 응용 프로그램을 빌드하기 위한 플랫폼입니다.

이 문서는 실제적인 문제에 대한 실용적인 논의를 제공하려 합니다. 다양한 패턴을 잘 살펴보면 Reliable Actors 모델을 사용하여 엔터프라이즈 및 클라우드 솔루션을 빌드하는 방법을 이해해야 합니다.

## 패턴

이 섹션에서는 고객과의 작업 중에 설정한 일련의 패턴 및 관련 시나리오를 나열합니다. 이러한 패턴은 고객이 Microsoft Azure에서 빌드 중인 광범위한 솔루션에 적용할 수 있는 문제의 클래스를 나타냅니다. 시나리오가 실제 사례를 기반으로 하지만 패턴을 명확하게 알 수 있도록 대부분의 도메인 관련 문제를 제거했습니다. 따라서 많은 샘플 코드가 단순하거나 명확하다는 것을 알 수 있습니다. 완전성을 위해 해당 코드를 포함했으며 특별히 현명하거나 인상을 남기기 위한 것은 아닙니다.

여기에 제시된 패턴은 포괄적이거나 Canonical일 수 없습니다. 일부 개발자는 제공하는 것과 다른 방식으로 동일한 문제 또는 패턴을 해결할 수 있습니다.

[패턴: 스마트 캐시](service-fabric-reliable-actors-pattern-smart-cache.md)

[패턴: 분산 네트워크 및 그래프](service-fabric-reliable-actors-pattern-distributed-networks-and-graphs.md)

[패턴: 리소스 관리](service-fabric-reliable-actors-pattern-resource-governance.md)

[패턴: 상태 저장 서비스 컴퍼지션](service-fabric-reliable-actors-pattern-stateful-service-composition.md)

[패턴: 사물 인터넷](service-fabric-reliable-actors-pattern-internet-of-things.md)

[패턴: 분산 계산](service-fabric-reliable-actors-pattern-distributed-computation.md)

[일부 안티패턴](service-fabric-reliable-actors-anti-patterns.md)

### 행위자, 간략한 역사

원래 행위자 모델이 1973에 게시된 Carl Hewitt가 작성한 [문서](http://dl.acm.org/citation.cfm?id=1624804) 및 공동 작성자입니다. 하지만 비교적 최근에 행위자 모델은 분산 시스템에서 동시성 및 복잡성을 처리하는 수단으로 주목을 받았습니다.

행위자 모델은 서로 격리되어 있는 미세하게 세분화된 개별 개체(행위자)를 지원합니다. 비동기 메시지 전달을 통해 통신하므로 행위자 간의 직접 통신이 가능합니다. 행위자는 단일 스레드 의미 체계를 사용하여 실행됩니다. 행위자 상태의 캡슐화 및 다른 행위자로부터의 격리 기능이 결합되어 이 방법은 고도의 병렬 시스템을 간단하게 작성할 수 있습니다. 행위자의 코드에서 동시성 문제를 제거하여 수행합니다. 행위자는 사용 가능한 하드웨어 리소스의 풀에서 동적으로 만들어집니다.

[Erlang](http://www.erlang.org/)은 행위자 모델에서 가장 인기 있는 구현입니다. 개발자는 해당 행위자 모델을 재발견하기 시작했으며, 이는 Erlang에 대한 새로운 관심과 더불어 [Scala](http://www.scala-lang.org/) 행위자, [Akka](http://akka.io), [Akka.NET](http://getakka.net/), [DCell](http://research.microsoft.com/pubs/75988/dcell.pdf) 등과 같은 새로운 Erlang식 솔루션의 생성을 자극했습니다.

## 서비스 패브릭 Reliable Actors의 이점

Reliable Actors 프로그래밍 모델은 Erlang 및 분산 개체 시스템에서 일부 아이디어를 차용하는 행위자 모델의 구현입니다. 행위자 간접의 계층을 추가하고 행위자를 서비스 패브릭 플랫폼을 활용하는 통합된 프로그래밍 모델에 노출합니다.

Reliable Actors의 주요 이점은 **개발자의 생산성**(비전문 프로그래머인 경우도 해당) 및 프로그래머가 특별히 시간을 투자하지 않아도 가능한 **기본적으로 투명한 확장성**입니다. Reliable Actors 프로그래밍 모델은 서비스 패브릭에서 실행되는 .NET 라이브러리를 사용합니다. 복잡한 분산 응용 프로그램의 개발을 더 쉽게 만들 도구를 제공합니다. 또한 이러한 도구는 설계로 응용 프로그램을 확장할 수 있도록 합니다. 이들 각 이점은 아래와 같이 확장됩니다. 이 프로그래밍 모델은 다음과 같은 주요 추상화, 보증 및 시스템 서비스를 제공하여 전문 및 비전문 프로그래머의 생산성을 증가시킵니다.

* *친숙한 개체 지향 프로그래밍(OOP) 패러다임*. 행위자는 비동기 메서드 및 속성을 사용하여 .NET 행위자 인터페이스 선언을 구현하는 .NET 클래스입니다. 따라서 행위자는 프로그래머에게 메서드 및 속성을 직접 호출할 수 있는 원격 개체로 표시됩니다. 따라서 메서드 호출을 메시지로 전환하고, 올바른 끝점으로 라우팅하고, 대상 행위자의 메서드를 호출하고, 완벽하게 투명한 방식으로 오류 및 비정상적인 사례를 처리하여 프로그래머에게 친숙한 OOP 패러다임을 제공합니다.

* *행위자의 단일 스레드 실행.* Reliable Actor 런타임은 행위자가 한번에 둘 이상의 스레드를 실행하지 않는다는 것을 보장합니다. 이와 함께 다른 행위자로부터 각 행위자의 격리 때문에 프로그래머는 행위자 수준에서 동시성에 직면하지 않습니다. 프로그래머는 잠금 또는 기타 동기화 메커니즘을 사용하여 공유 데이터에 대한 액세스를 제어할 필요가 없습니다. 이 기능만으로도 비전문 프로그래머가 분산 응용 프로그램의 개발을 쉽게 할 수 있습니다.

* *투명한 활성화*. 이 런타임은 처리할 메시지가 있을 때만 필요에 따라 행위자를 활성화합니다. 이를 통해 응용 프로그램 코드에 대한 가시성을 제공하고 응용 프로그램 코드에서 제어되는 행위자의 논리적 생성의 개념을 응용 프로그램에 대해 투명한 메모리 내 행위자의 실제 활성화에서 명확하게 구분합니다. Reliable Actors 방식은 "페이지 아웃"(비활성화) 또는 "페이지 인"(활성화)하는 시기를 결정한다는 점에서 가상 메모리와 비슷합니다. 지정된 시간에 실제 메모리에 위치하는지 여부와 상관 없이 응용 프로그램에는 논리적으로 만든 행위자의 전체 "메모리 공간"에 대한 중단 없는 액세스 권한이 있습니다. 투명한 활성화를 사용하면 전체 하드웨어 리소스 풀에서 행위자의 배치와 마이그레이션을 통해 동적인 적응형 부하 분산이 가능합니다.

* *위치 투명성*. 프로그래머가 행위자의 메서드를 호출하거나 다른 구성 요소에 전달하는 데 사용하는 행위자 참조(프록시 개체)는 행위자의 논리적 ID만 포함합니다. 행위자의 논리적 ID를 물리적 위치로 변환하는 작업과 해당 메시지 라우팅은 Reliable Actor 런타임에서 투명하게 수행됩니다. 응용 프로그램 코드는 물리적 위치가 명확한 행위자와 통신하므로 오류 또는 리소스 관리로 인해 시간이 지남에 변경될 수 있습니다. 호출될 당시에 행위자가 비활성화되기 때문에 행위자의 위치는 변경될 수도 있습니다.

* *영구 저장소와의 투명한 통합*. Reliable Actors 프로그래밍 모델을 사용하면 행위자의 메모리 내 상태를 영구 저장소로 선언적으로 매핑할 수 있습니다. 업데이트를 동기화하므로 영구 상태가 성공적으로 업데이트된 후에만 호출자가 투명하게 결과를 받을 수 있습니다.

* *높은 가용성, 장애 조치 지원 및 응용 프로그램 수명 주기 관리*. 행위자의 상태는 플랫폼에서 관리하며 클러스터의 노드에서 오류가 발생한 경우 복원할 수 있도록 복제됩니다. 또한 서비스 패브릭은 응용 프로그램 수명 주기를 관리하고 가동 중지 시간 없이 응용 프로그램 업그레이드를 가능하게 해줍니다. Reliable Actors 프로그래밍 모델은 프로그래머가 해당 응용 프로그램 및 서비스를 몇 배 많은 규모로 성공적으로 확장할 수 있도록 안내하기 위해 마련되었습니다. 입증된 모범 사례와 패턴을 통합하고 더 낮은 수준의 시스템 기능을 효율적으로 구현하도록 제공하여 달성됩니다. 서비스 패브릭 응용 프로그램의 확장성과 성능을 사용할 수 있게 해주는 일부 주요 요소는 다음과 같습니다.

  * *응용 프로그램 상태의 세분화된 암시적 분할*. 행위자를 직접 주소 지정 가능한 엔터티로 사용하면 프로그래머는 암시적으로 응용 프로그램의 전반적인 상태를 세분화할 수 있습니다. Reliable Actors 프로그래밍 모델에서는 행위자의 규모를 정하지 않지만 대부분의 경우 상대적으로 많은 수(수백만 개 이상)의 행위자를 갖게 됩니다. 이러한 수백만의 행위자는 각각 사용자 계정 또는 구매 주문과 같은 응용 프로그램의 적절한 엔터티를 나타냅니다. 행위자가 개별적으로 주소를 지정할 수 있고 실제 위치가 런타임에서 추상화된 경우 부하 분산 및 핫스폿을 처리하는 데 뛰어난 유연성을 갖습니다. 응용 프로그램 개발자의 입장에서 생각하지 않고 투명하고 일반적인 방식으로 수행됩니다.

  * *적응형 리소스 관리*. 행위자는 상호 작용하는 다른 행위자의 위치를 미리 가정하지 않습니다. 위치 투명성 때문에 런타임은 매우 동적인 방식으로 사용 가능한 하드웨어 리소스 할당을 관리하고 조정할 수 있습니다. 들어오는 요청을 실패하지 않고 로드 및 통신 패턴에 대한 응답으로 계산 클러스터 전체에 걸친 행위자의 배치 및 마이그레이션에 세분화된 결정을 내려서 수행합니다. 특정 행위자의 여러 복제본을 만들면 런타임에서 응용 프로그램 코드를 변경하지 않고도 행위자의 처리량을 증가시킬 수 있습니다.

  * *멀티플렉스 통신*. 서비스 패브릭의 행위자는 논리적 끝점을 가지고 있으며 그 사이의 메시징은 전체-전체 간 물리적 연결(TCP 소켓)의 고정 세트를 통해 멀티플렉스됩니다. 따라서 런타임은 행위자별 OS 오버헤드 없이 주소 지정 가능한 수많은 엔터티(수백만 개)를 호스트할 수 있습니다. 또한 행위자의 활성화 또는 비활성화는 TCP 포트 또는 HTTP URL과 같은 물리적 끝점의 등록 또는 등록 취소 비용이 발생하지 않습니다.

  * *효율적인 예약*. Reliable Actors 런타임은 물리적 프로세서 코어별로 스레드를 사용하여 사용자 지정 스레드 풀에서 많은 수의 단일 스레드 행위자 실행을 예약합니다. 행위자 코드가 비차단 연속 기반 스타일(프로그래밍 모델의 요구 사항)로 작성되므로 응용 프로그램 코드는 매우 효율적이고 "협조적"인 다중 스레드 방식으로 경합 없이 실행됩니다. 따라서 높은 처리량에 도달하여 매우 높은 CPU 사용률(최대 90% 이상)로 시스템을 실행할 수 있습니다. 시스템 및 부하에서 행위자의 수가 증가해도 추가 스레드 또는 다른 OS 기본 요소가 발생하지 않으며 이는 개별 노드 및 전체 시스템의 확장성에 도움이 됩니다.

  * *명시적 비동기*. Reliable Actors 프로그래밍 모델은 분산 응용 프로그램의 비동기 특성을 명시적으로 만들고 비차단 비동기 코드를 작성할 수 있도록 프로그래머를 지원합니다. 따라서 명시적으로 다중 스레드를 사용하지 않고도 크게 분산 병렬 처리 및 전체 처리가 가능합니다.

<!---HONumber=AcomDC_0128_2016-->