---
title: "Service Fabric 서비스의 확장성 | Microsoft Docs"
description: "서비스 패브릭 서비스의 규모를 조정하는 방법을 설명합니다."
services: service-fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: 
ms.assetid: ed324f23-242f-47b7-af1a-e55c839e7d5d
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 12/30/2016
ms.author: masnider
translationtype: Human Translation
ms.sourcegitcommit: dafaf29b6827a6f1c043af3d6bfe62d480d31ad5
ms.openlocfilehash: 52dcf341a34478bf4e800d8f1b9d44867b5feaf6
ms.lasthandoff: 01/07/2017


---
# <a name="scaling-service-fabric-applications"></a>서비스 패브릭 응용 프로그램 크기 조정
Azure Service Fabric을 사용하면 클러스터의 모든 노드에서 서비스, 파티션 및 복제본을 관리하여 확장 가능한 응용 프로그램을 쉽게 빌드할 수 있습니다. 최대 리소스 사용률을 가능하게 합니다.

서비스 패브릭 응용 프로그램의 높은 규모는 다음 두 가지 방법으로 얻을 수 있습니다.

1. 서비스 파티션 수준에서 크기 조정
2. 명명된 서비스 인스턴스 수준에서 크기 조정

## <a name="scaling-at-the-partition-level"></a>파티션 수준에서 크기 조정
Service Fabric은 파티션을 지원합니다. 파티션을 사용하면 각 개별 서비스를 서비스의 전반적인 상태 중 일부를 포함한 독립적인 여러 파티션으로 나눌 수 있습니다. [분할 개요](service-fabric-concepts-partitioning.md) 는 지원되는 분할 체계의 유형에 대한 정보를 제공합니다. 각 파티션의 복제본은 클러스터의 노드 간에 분산됩니다. 서비스가 0개의 하위 키, 99개의 상위 키 및 4개의 파티션 개수를 가진 범위 지정 파티션 구성표를 사용한다고 가정합니다. 3노드 클러스터에서 서비스는 다음과 같이 각 노드에서 리소스를 공유하는&4;개의 복제본으로 배치될 수 있습니다.

<center>
![3개의 노드가 있는 파티션 레이아웃](./media/service-fabric-concepts-scalability/layout-three-nodes.png)
</center>

노드 수를 늘리면 Service Fabric이 거기에 일부 기존 복제본을 이동시켜서 새 노드의 리소스를 활용할 수 있습니다. 노드 수를&4;개로 증가시키면 서비스가 서로 다른 파티션에 속한 각 노드에서 실행되는&3;개의 복제본을 갖게 되어 리소스 사용률 및 성능이 더 좋아집니다.

<center>
![4개의 노드가 있는 파티션 레이아웃](./media/service-fabric-concepts-scalability/layout-four-nodes.png)
</center>

## <a name="scaling-at-the-service-name-level"></a>서비스 이름 수준에서 크기 조정
서비스 인스턴스는 응용 프로그램 이름 및 서비스 형식 이름의 특정 인스턴스입니다( [서비스 패브릭 응용 프로그램 수명 주기](service-fabric-application-lifecycle.md)참조). 서비스를 만드는 동안 사용할 파티션 구성표를 지정합니다( [서비스 패브릭 서비스 분할](service-fabric-concepts-partitioning.md)참조).

크기 조정의 첫 번째 수준은 서비스 이름에 의해 조정됩니다. 기존 서비스 인스턴스가 바빠지면 필요에 따라 분할의 다른 수준으로 서비스의 인스턴스를 만들 수 있습니다. 그러면 새 서비스 소비자가 더 바쁜 서비스 인스턴스 대신 덜 바쁜 서비스 인스턴스를 사용할 수 있습니다.

용량을 늘리는 옵션은 새 파티션 구성표로 새 서비스 인스턴스를 만드는 것입니다. 그러나 이렇게 하면 복잡성이 증가합니다. 사용 중인 모든 클라이언트가 언제 어떻게 다르게 이름 지정된 서비스를 사용하는지 알아야 합니다. 다른 방법으로 관리 또는 중간 서비스가 각 요청을 처리해야 하는 서비스 및 파티션을 결정해야 합니다.

### <a name="example-scenario-embedded-dates"></a>예제 시나리오: 포함된 날짜
한 가지 가능한 시나리오는 서비스 이름의 일부로 날짜 정보를 사용하는 것입니다. 예를 들어 2013년에 합류한 모든 고객에 대해 특정한 이름의 서비스 인스턴스를 사용하고 2014년에 합류한 고객에 대해서는 다른 이름의 서비스 인스턴스를 사용할 수 있습니다. 이 이름 지정 체계로 날짜에 따라 이름이 증가하는 프로그래밍 방식을 사용할 수 있습니다(2014 접근 방식으로 2014년에 대한 서비스 인스턴스를 필요에 따라 만들 수 있습니다).

그러나 이 접근 방식은 서비스 패브릭 지식 범위 밖의 특정 이름 지정 정보 응용 프로그램을 사용하는 클라이언트에 기반합니다.

* *이름 지정 규칙 사용*: 2013년에 사용할 응용 프로그램이 있는 경우 fabric:/app/service2013라는 이름의 서비스를 만듭니다. 2013년 2/4분기를 향해 fabric:/app/service2014라는 이름의 다른 서비스를 만듭니다. 이 두 서비스는 동일한 서비스 유형입니다. 이 접근 방법에서는 클라이언트가 연도를 기준으로 적절한 서비스 이름을 생성하는 논리가 있어야 합니다.
* *조회 서비스 사용*: 다른 패턴은 원하는 키에 대한 서비스의 이름을 제공할 수 있는 보조 “조회 서비스”를 사용하는 것입니다. 그러면 조회 서비스에 의해새 서비스 인스턴스가 만들어집니다. 조회 서비스 자체는 생성한 서비스 이름에 대한 데이터 외에는 어떤 응용 프로그램 데이터도 유지하지 않습니다. 따라서 같은 해에 기반한 위 예제의 경우, 클라이언트는 먼저 조회 서비스에 연결하여 주어진 해에 대한 서비스 처리 데이터의 이름을 확인합니다. 그런 다음 클라이언트가 해당 서비스 이름을 사용하여 실제 작업을 수행합니다. 첫 번째 조회 결과는 캐시될 수 있습니다.

## <a name="putting-it-all-together"></a>모든 항목 요약
여기에서 설명한 모든 아이디어를 살펴보고 다른 시나리오를 살펴보겠습니다.

다음 예제를 고려합니다. 이름 및 연락처 정보를 가지고 주소록의 역할을 하는 서비스를 구축하려고 합니다. 얼마나 많은 사용자가 있을 예정인가요? 각 사용자가 연락처를 얼마나 많이 저장하나요? 처음으로 서비스를 사용하는 경우 이 작업을 모두 알기는 어렵습니다. 잘못된 파티션 개수를 선택한 결과로 나중에 확장 문제가 발생할 수 있습니다. 그러나 모든 사용자에 대해 단일 파티션 구성표를 선택하려는 이유는 무엇인가요?

대신 이러한 유형의 상황에서는 다음 패턴을 고려해 보세요.
1. 모든 사용자에 대한 파티션 구성표를 선택하지 않고 "관리자 서비스"를 빌드합니다.
2. 관리자 서비스의 작업은 서비스에 등록할 때 고객 정보를 확인하는 것입니다. _해당 고객에 대해서만_ _실제_ 연락처 저장소 서비스의 인스턴스를 만드는 데 해당 정보에 따릅니다. 이러한 유형의 동적 서비스 생성 패턴은 다음과 같은 이점이 있습니다.

    * 모든 사용자에 대한 올바른 파티션 개수를 추측하려고 하지 않습니다.
    * 각 고객이 서비스의 고유한 복사본을 갖고 있기 때문에 데이터 구분이 가능합니다.
    * 각 고객 서비스는 예상된 규모에 기반하여 필요에 따라 더 많거나 적은 파티션 또는 복제본으로 다르게 구성될 수 있습니다.
      * 예를 들어, 고객이 "Gold" 계층으로 지불했다면 복제본 또는 파티션 개수를 늘릴 수 있습니다.
      * 또는 필요한 계약 수가 "소량"임을 나타내는 정보를 제공받은 경우 몇 개의 파티션만 가져오게 됩니다.
    * 고객이 나타나기를 기다리는 동안 다양한 서비스 인스턴스 또는 복제본을 실행하지 않습니다.
    * 고객이 떠난 경우 사용자 서비스에서 해당 정보를 제거하는 작업은 관리자가 생성한 해당 서비스를 삭제하는 것만큼 간단합니다.

## <a name="next-steps"></a>다음 단계
Service Fabric 개념에 대한 자세한 내용은 다음 문서를 참조하세요.

* [서비스 패브릭 서비스의 가용성](service-fabric-availability-services.md)
* [서비스 패브릭 서비스 분할](service-fabric-concepts-partitioning.md)
* [상태 정의 및 관리](service-fabric-concepts-state.md)

