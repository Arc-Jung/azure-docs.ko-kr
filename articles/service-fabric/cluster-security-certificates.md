---
title: Service Fabric 클러스터의 x.509 인증서 기반 인증
description: Service Fabric 클러스터의 인증서 기반 인증에 대해 알아보고 인증서 관련 문제를 검색, 완화 및 수정 하는 방법에 대해 알아봅니다.
ms.topic: conceptual
ms.date: 03/16/2020
ms.openlocfilehash: 2d94e5cc78afbabde38eb38e0c4f89381bd67167
ms.sourcegitcommit: 910a1a38711966cb171050db245fc3b22abc8c5f
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/20/2021
ms.locfileid: "101729694"
---
# <a name="x509-certificate-based-authentication-in-service-fabric-clusters"></a>Service Fabric 클러스터의 x.509 인증서 기반 인증

이 문서에서는 [클러스터 보안 Service Fabric](service-fabric-cluster-security.md)소개를 보완 하 고 Service Fabric 클러스터의 인증서 기반 인증에 대해 자세히 설명 합니다. 독자가 기본적인 보안 개념과 클러스터의 보안을 제어 하기 위해 Service Fabric 노출 하는 컨트롤에 대해 잘 알고 있다고 가정 합니다.  

이 제목에서 다루는 항목은 다음과 같습니다.

* 인증서 기반 인증 기본 사항
* Id 및 해당 역할
* 인증서 구성 규칙
* 문제 해결 및 질문과 대답

## <a name="certificate-based-authentication-basics"></a>인증서 기반 인증 기본 사항
간단한 리프레셔 인 보안에서 인증서는 엔터티 (주체)와 관련 된 정보를 비대칭 암호화 키 쌍의 소유에 바인딩하는 것으로, 공용 키 암호화의 핵심 구문을 구성 하는 방법입니다. 인증서로 표시 되는 키를 사용 하 여 데이터를 보호 하거나 키 소유자의 id를 증명할 수 있습니다. PKI (공개 키 인프라) 시스템과 함께 사용 하는 경우 인증서는 인터넷 도메인의 소유권과 인증서 발급자 (인증 기관 또는 CA)가 부여한 특정 권한 등 주체의 추가 특성을 나타낼 수 있습니다. 인증서의 일반적인 응용 프로그램은 TLS (전송 계층 보안) 암호화 프로토콜을 지원 하 여 컴퓨터 네트워크를 통한 보안 통신을 허용 합니다. 특히 클라이언트와 서버는 인증서를 사용 하 여 통신의 개인 정보 및 무결성을 보장 하 고 상호 인증도 수행 합니다.

Service Fabric에서 클러스터 (페더레이션)의 기본 계층은 TLS (다른 프로토콜 중)를 기반으로 하 여 참여 하는 신뢰할 수 있는 보안 네트워크를 구현 합니다. Service Fabric 클라이언트 Api를 통해 클러스터에 연결 하면 TLS를 사용 하 여 트래픽을 보호 하 고 파티 id를 설정할 수도 있습니다. 특히 Service Fabric의 인증에 사용 되는 경우 인증서를 사용 하 여 인증서의 개인 키를 소유 하 고 있습니다. a) 인증서 자격 증명의 프레 젠 터는 인증서의 개인 키를 소유 합니다. b) 인증서의 SHA-1 해시 (' 지문 ')가 클러스터 정의에 포함 된 선언과 일치 하거나 c) 인증서의 고유 주체 일반 이름이 클러스터 정의에 포함 된 선언과 일치 합니다. 및 인증서의 발급자를 알고 있거나 신뢰할 수 있습니다.

위의 목록에서 ' b '는 것 구어체 ' 지문 고정 ' 이라고 합니다. 이 경우 선언은 특정 인증서를 참조 하 고, 인증 체계의 강도는 다른 모든 측면에서 유효한 올바른 형식의 유효한 개체 이지만, 다른 모든 측면에서 동일한 해시 값을 생성 하는 인증서를 작업 하는 것이 온-프레미스에 있습니다. ' C ' 항목은 인증서를 선언 하는 대체 형태를 나타냅니다. 여기서 체계의 강도는 인증서와 발급 기관의 조합에 적용 됩니다. 이 경우 선언은 인증서의 클래스를 참조 합니다. 동일한 특성을 가진 두 인증서는 완전히 동등한 것으로 간주 됩니다. 

다음 섹션에서는 Service Fabric 런타임이 클러스터 보안을 위해 인증서를 사용 하 고 유효성을 검사 하는 방법에 대해 자세히 설명 합니다.

## <a name="identities-and-their-respective-roles"></a>Id 및 해당 역할
인증에 대 한 세부 정보 또는 통신 채널 보안을 확인 하기 전에 참여 하는 행위자와 클러스터에서 해당 하는 해당 역할을 나열 하는 것이 중요 합니다.
- ' system ' 이라고 하는 Service Fabric 런타임: 클러스터를 나타내는 추상화 및 기능을 제공 하는 서비스 집합입니다. 시스템 인스턴스 간의 클러스터 내 통신을 참조할 때 ' 클러스터 id ' 라는 용어를 사용 합니다. 클러스터 외부의 트래픽을 받는 사람/대상으로 클러스터를 참조 하는 경우 ' 서버 id ' 라는 용어를 사용 합니다.
- 호스트 된 응용 프로그램 (' 응용 프로그램 ' 이라고 함): 클러스터의 소유자가 제공 하는 코드 (클러스터에서 오케스트레이션 및 실행 됨)
- 클라이언트: 클러스터 구성에 따라 클러스터에 연결 하 고 기능을 실행할 수 있는 엔터티입니다. 두 수준의 권한 (' user ' 및 ' admin ')을 각각 구분 합니다. ' 사용자 ' 클라이언트는 주로 읽기 전용 작업 (일부는 읽기 전용 기능이 아님)으로 제한 되지만 ' 관리자 클라이언트는 클러스터의 기능에 무제한으로 액세스할 수 있습니다. 자세한 내용은 [Service Fabric 클러스터의 보안 역할](service-fabric-cluster-security-roles.md)을 참조 하세요.
- (Azure에만 해당) Service Fabric 클러스터의 작업 및 관리를 위한 컨트롤을 오케스트레이션 하 고 노출 하는 Service Fabric 서비스로, 간단히 ' 서비스 ' 라고 합니다. 환경에 따라 ' 서비스 '는 Azure Service Fabric 리소스 공급자 또는 Service Fabric 팀에서 소유 하 고 운영 하는 다른 리소스 공급자를 참조할 수 있습니다.

보안 클러스터에서 이러한 각 역할은 미리 정의 된 역할 이름과 해당 자격 증명의 쌍으로 선언 된 고유한 고유 id를 사용 하 여 구성할 수 있습니다. Service Fabric는 자격 증명을 인증서 또는 도메인 기반 서비스 주체로 선언 하도록 지원 합니다. Windows-/Kerberos-based id도 지원 되지만이 문서에서는 다루지 않습니다. [Service Fabric 클러스터의 Windows 기반 보안](service-fabric-windows-cluster-windows-security.md)을 참조 하세요.) Azure 클러스터에서는 클라이언트 역할을 [Azure Active Directory 기반 id](service-fabric-cluster-creation-setup-aad.md)로 선언할 수도 있습니다.

위의 alluded Service Fabric 런타임은 ' admin ' 및 ' user ' 클러스터에 두 가지 수준의 권한을 정의 합니다. 관리자 클라이언트와 ' 시스템 ' 구성 요소는 모두 ' 관리자 권한으로 작동 하므로 서로를 구분할 수 없습니다. 클러스터에 대 한 연결을 설정 하면 인증 된 호출자가 후속 권한 부여를 위한 기준으로 두 역할 중 하나를 Service Fabric 런타임에서 부여 합니다. 다음 섹션에서 인증을 자세히 살펴볼 것입니다.

## <a name="certificate-configuration-rules"></a>인증서 구성 규칙
### <a name="validation-rules"></a>유효성 검사 규칙
Service Fabric 클러스터의 보안 설정은 다음과 같은 측면에 대해 설명 합니다.
- 인증 유형입니다. 이는 클러스터에 대 한 변경 불가능 한 생성 시간 특성입니다. 이러한 설정의 예로는 ' ClusterCredentialType ', ' ServerCredentialType ', 그리고 허용 되는 값은 ' none ', ' x509 ' 또는 ' w i n d '입니다. 이 문서에서는 x509 유형 인증에 대해 집중적으로 설명 합니다.
- (인증) 유효성 검사 규칙 이러한 설정은 클러스터 소유자에 의해 설정 되며 지정 된 역할에 대해 허용 되어야 하는 자격 증명을 설명 합니다. 예제는 아래에서 자세히 검사 됩니다.
- 인증 결과를 조정 하거나 약간 변경 하는 데 사용 되는 설정입니다. 여기에는 인증서 해지 목록의 적용을 제한 하는 플래그 (de-de)가 포함 됩니다.

> [!NOTE]
> 아래에 제공 된 클러스터 구성 예제는이 문서에서 설명 하는 Service Fabric 기능을 직접 지 원하는 가장 유형임 형식인 XML 형식의 클러스터 매니페스트에서 발췌 한 것입니다. 동일한 설정은 독립 실행형 json 클러스터 매니페스트 또는 Azure 리소스 Management 템플릿이 든 상관 없이 클러스터 정의의 JSON 표현에서 직접 표현할 수 있습니다.

인증서 유효성 검사 규칙은 다음 요소로 구성 됩니다.
- 해당 역할: 클라이언트, 관리 클라이언트 (권한 있는 역할)
- 역할에 대해 허용 된 자격 증명 (지문 또는 주체 일반 이름으로 선언 됨)

#### <a name="thumbprint-based-certificate-validation-declarations"></a>지문 기반 인증서 유효성 검사 선언
지문 기반 유효성 검사 규칙의 경우 클러스터에 대 한 연결을 요청 하는 호출자가 제공한 자격 증명은 다음과 같이 유효성이 검사 됩니다.
  - 자격 증명은 올바른 형식의 올바른 인증서입니다. 체인을 작성 하 고 서명을 일치 시킬 수 있습니다.
  - 인증서의 시간이 유효 합니다 (NotBefore <= now < NotAfter).
  - 인증서의 SHA-1 해시는 선언과 일치 합니다 .이는 모든 공백을 제외 하 고 대/소문자를 구분 하지 않는 문자열 비교입니다.

체인을 작성 하는 동안 발생 한 모든 신뢰 오류는 만료 된 인증서를 제외 하 고 지문 기반 선언에 대해 표시 되지 않습니다. 단,이 경우에도 프로 비전이 존재 합니다. 특히, 해지 상태를 알 수 없거나 오프 라인 상태 이거나, 신뢰할 수 없는 루트 이거나, 잘못 된 키 사용 인 경우 부분 체인은 심각 하지 않은 오류로 간주 됩니다. 이 경우 온-프레미스는 인증서가 키 쌍에 대 한 봉투 (envelope) 인 것입니다 .이는 클러스터 소유자가 개인 키를 보호 하기 위해 위치 측정값에 설정 한다는 사실입니다.

클러스터 매니페스트에서 발췌 한 다음 예시는 이러한 지문 기반 유효성 검사 규칙 집합을 포함 합니다.

```xml
<Section Name="Security">
  <Parameter Name="ClusterCredentialType" Value="X509" />
  <Parameter Name="ServerAuthCredentialType" Value="X509" />
  <Parameter Name="AdminClientCertThumbprints" Value="d5ec...4264" />
  <Parameter Name="ClientCertThumbprints" Value="7c8f...01b0" />
  <Parameter Name="ClusterCertThumbprints" Value="abcd...1234,ef01...5678" />
  <Parameter Name="ServerCertThumbprints" Value="ef01...5678" />
</Section>
```

위의 각 항목은 앞에서 설명한 대로 특정 id를 참조 합니다. 또한 각 항목은 쉼표로 구분 된 문자열 목록으로 여러 값을 지정할 수 있습니다. 이 예제에서 들어오는 자격 증명의 유효성을 성공적으로 검사 하면 SHA-1 지문이 있는 인증서의 프레 젠 터가 5ec ... 4264 '에 ' admin role;이 부여 됩니다. 반대로, ' 7c8f ' 인증서를 사용 하 여 호출자를 인증 합니다. 01b0 '에는 기본적으로 읽기 전용 작업으로 제한 되는 ' 사용자 ' 역할이 부여 됩니다. 지문이 ' abcd ... ' 인 인증서를 표시 하는 인바운드 호출자입니다. 1234 ' 또는 ' ef01 ... 5678 '은 (는) 클러스터에서 피어 노드로 수락 됩니다. 마지막으로 클러스터의 관리 끝점에 연결 하는 클라이언트는 서버 인증서의 지문을 ' ef01 ... 5678 '입니다. 

앞서 설명한 것 처럼 Service Fabric는 만료 된 인증서를 수락 하기 위한 프로 비전을 수행 합니다. 그 이유는 인증서가 수명이 제한 되어 있고, 지문 (특정 인증서 인스턴스를 나타냄)에 의해 선언 될 때 인증서가 만료 될 수 있게 되 면 클러스터에 연결 하는 데 실패 하거나 클러스터를 완전히 축소 하는 것입니다. 지문 고정 인증서의 회전을 분실 하거나 무시 하기가 너무 쉽지만 이러한 상황에서 복구 하는 것은 어렵습니다.

이를 위해 클러스터 소유자는 다음과 같이 지 문으로 선언 된 자체 서명 된 인증서가 유효한 것으로 간주 되도록 명시적으로 지정할 수 있습니다.

```xml
  <Section Name="Security">
    <Parameter Name="AcceptExpiredPinnedClusterCertificate" Value="true" />
  </Section>
```
이 동작은 CA에서 발급 한 인증서로 확장 되지 않습니다. 이 경우 해지 되 고 손상 될 수 있는 만료 된 인증서가 CA의 인증서 해지 목록에 더 이상 표시 되지 않아 보안 위험을 초래 하는 즉시 ' 유효한 ' 상태가 될 수 있습니다. 자체 서명 된 인증서를 사용 하는 경우 클러스터 소유자는 인증서의 개인 키를 보호 하는 유일한 파티 (CA에서 발급 한 인증서의 경우는 아님)로 간주 됩니다. 클러스터 소유자는 인증서가 손상 된 방법 또는 시기를 인식 하지 못할 수 있습니다.

#### <a name="common-name-based-certificate-validation-declarations"></a>일반 이름 기반 인증서 유효성 검사 선언
일반 이름 기반 선언은 다음 형식 중 하나를 사용 합니다.
- 주체 일반 이름 (전용)
- 발급자 고정의 주체 일반 이름

먼저 두 선언 스타일을 exemplifying 클러스터 매니페스트에서 발췌 한 부분을 살펴보겠습니다.
```xml
    <Section Name="Security/ServerX509Names">
      <Parameter Name="server.demo.system.servicefabric.azure-int" Value="" />
    </Section>
    <Section Name="Security/ClusterX509Names">
      <Parameter Name="cluster.demo.system.servicefabric.azure-int" Value="1b45...844d,d7fe...26c8,3ac7...6960,96ea...fb5e" />
    </Section>
```
선언은 각각 서버 및 클러스터 id를 참조 합니다. CN 기반 선언에는 표준 ' 보안 '과는 별개의 클러스터 매니페스트에 고유한 섹션이 있습니다. 두 선언에서 ' 이름 '은 인증서의 고유 주체 일반 이름을 나타내며 ' Value ' 필드는 다음과 같이 필요한 발급자를 나타냅니다.

- 첫 번째 경우에 선언에서는 서버 인증서의 고유 주체에 대 한 일반 name 요소가 "server.demo.system. servicefabric" 문자열과 일치 해야 합니다. 빈 ' 값 ' 필드는 서버 인증서의 유효성을 검사 하는 노드/컴퓨터에서 인증서 체인의 루트를 신뢰할 수 있다고 가정 합니다. Windows에서는 인증서가 ' 신뢰할 수 있는 루트 CA ' 저장소에 설치 된 모든 인증서에 연결 될 수 있음을 의미 합니다.
- 두 번째 경우에는 인증서의 일반 이름이 "cluster.demo.system. servicefabric" 문자열과 일치 하 *고* 인증서의 직접 발급자 지문이 ' Value ' 필드의 쉼표로 구분 된 항목 중 하 나와 일치 하는 경우 인증서의 프레 젠 트를 클러스터의 피어 노드로 수락 한다는 상태를 선언 합니다. 이 규칙 유형은 것 구어체를 ' 발급자 고정을 사용 하는 일반 이름 ' 이라고 합니다.

두 경우 모두 인증서 체인이 빌드되고 오류가 없는 것으로 예상 됩니다. 즉, 해지 오류, 부분 체인이 나 시간이 잘못 된 신뢰 오류는 치명적인 것으로 간주 되 고 인증서 유효성 검사가 실패 합니다. 발급자를 고정 하면 ' 신뢰할 수 없는 루트 ' 상태를 심각 하지 않은 오류로 간주 합니다. 모양에도 불구 하 고,이는 클러스터 소유자가 권한 있는/수락 발급자 집합을 자신의 PKI로 제한할 수 있기 때문에 보다 엄격한 유효성 검사입니다.

인증서 체인을 빌드한 후에는 선언 된 주체를 원격 이름으로 사용 하 여 표준 TLS/SSL 정책에 대해 유효성을 검사 합니다. 인증서의 주체 일반 이름 또는 주체 대체 이름이 클러스터 매니페스트의 CN 선언과 일치 하면 인증서가 일치 하는 것으로 간주 됩니다. 이 경우 와일드 카드가 지원 되며 문자열 일치는 대/소문자를 구분 하지 않습니다.

(위에 설명 된 시퀀스는 인증서로 선언 된 각 키 사용 형식에 대해 실행 될 수 있습니다. 인증서가 클라이언트 인증 키 사용을 지정 하는 경우 체인은 클라이언트 역할에 대해 먼저 빌드되고 평가 됩니다. 성공 하는 경우 평가가 완료 되 고 유효성 검사가 성공적으로 수행 됩니다. 인증서에 클라이언트 인증 사용이 없거나 유효성 검사에 실패 한 경우 Service Fabric 런타임은 서버 인증에 대 한 체인을 빌드하고 평가 합니다.)

예제를 완료 하기 위해 다음 발췌에서는 일반 이름으로 클라이언트 인증서를 선언 하는 방법을 보여 줍니다.
```xml
    <Section Name="Security/AdminClientX509Names">
      <Parameter Name="admin.demo.client.servicefabric.azure-int" Value="1b45...844d,d7fe...26c8,3ac7...6960,96ea...fb5e" />
    </Section>
    <Section Name="Security/ClientX509Names">
      <Parameter Name="user.demo.client.servicefabric.azure-int" Value="1b45...844d,d7fe...26c8,3ac7...6960,96ea...fb5e" />
    </Section>
```

위의 선언은 각각 admin 및 사용자 id에 해당 합니다. 이러한 방식으로 선언 된 인증서의 유효성 검사는 이전 예제와 클러스터 및 서버 인증서의 유효성을 검사 하는 것과 같습니다.

> [!NOTE]
> 일반적인 이름 기반 선언은 회전, 일반적으로 클러스터 인증서 관리를 단순화 하기 위한 것입니다. 그러나 클러스터의 지속적인 가용성과 보안을 유지 하려면 다음 권장 사항을 준수 하는 것이 좋습니다.
  * 발급자 고정을 사용 하 여 신뢰할 수 있는 루트에 의존
  * 다른 Pki의 발급자를 혼합 하지 마세요.
  * 필요한 모든 발급자가 인증서 선언에 나열 되는지 확인 합니다. 일치 하지 않는 발급자로 인해 유효성 검사가 실패 함
  * PKI의 인증서 정책 끝점을 검색 가능 하 고, 사용 가능 하며, 액세스할 수 있는지 확인 합니다. 즉, AIA, CRL 또는 OCSP 끝점이 리프 인증서에 선언 되 고 인증서 체인 작성이 완료 될 수 있도록 액세스할 수 있습니다.

X.509 인증서를 사용 하 여 보호 되는 클러스터의 연결에 대 한 요청을 수신 하면 Service Fabric 런타임은 클러스터의 보안 설정을 사용 하 여 위에서 설명한 대로 원격 파티의 자격 증명에 대 한 유효성을 검사 합니다. 성공 하면 호출자/원격 파티가 인증 된 것으로 간주 됩니다. 자격 증명이 여러 유효성 검사 규칙과 일치 하는 경우 런타임은 일치 하는 모든 규칙의 가장 높은 권한 역할을 호출자에 게 부여 합니다. 

### <a name="presentation-rules"></a>프레젠테이션 규칙
이전 섹션에서는 인증서 보안 클러스터에서 인증이 작동 하는 방식을 설명 합니다. 이 섹션에서는 Service Fabric 런타임 자체에서 클러스터 간 통신에 사용 하는 인증서를 검색 하 고 로드 하는 방법을 설명 합니다. 이러한 "프레젠테이션" 규칙을 호출 합니다.

유효성 검사 규칙과 마찬가지로 프레젠테이션 규칙은 지문 또는 일반 이름으로 표현 되는 역할 및 연결 된 자격 증명 선언을 지정 합니다. 유효성 검사 규칙과 달리 일반 이름 기반 선언은 발급자 고정에 대 한 프로 비전을 포함 하지 않습니다. 이렇게 하면 유연성이 향상 되 고 성능이 향상 됩니다. 프레젠테이션 규칙은 각 고유 노드 형식에 대 한 클러스터 매니페스트의 ' NodeType ' 섹션에서 선언 됩니다. 설정은 클러스터의 보안 섹션에서 분할 되므로 각 노드 형식이 단일 섹션에서 전체 구성을 가질 수 있습니다. Azure Service Fabric 클러스터에서 노드 형식 인증서 선언은 기본적으로 클러스터 정의의 보안 섹션에서 해당 하는 설정으로 설정 됩니다.

#### <a name="thumbprint-based-certificate-presentation-declarations"></a>지문 기반 인증서 프레젠테이션 선언
앞에서 설명한 것 처럼 Service Fabric 런타임은 해당 역할을 클러스터의 다른 노드 피어와 클러스터 관리 작업을 위한 서버로 구분 합니다. 원칙적으로 이러한 설정은 개별적으로 구성할 수 있지만 실제로는 정렬 하는 경향이 있습니다. 이 문서의 나머지 부분에서는 간소화를 위해 설정이 일치 하는 것으로 가정 합니다.

클러스터 매니페스트에서 다음 발췌를 살펴보겠습니다.
```xml
  <NodeTypes>
    <NodeType Name="nt1vm">
      <Certificates>
        <ClusterCertificate X509FindType="FindByThumbprint" X509FindValue="cc71...1984" X509FindValueSecondary="49e2...19d6" X509StoreName="my" Name="ClusterCertificate" />
        <ServerCertificate X509FindValue="cc71...1984" Name="ServerCertificate" />
        <ClientCertificate X509FindValue="cc71...1984" Name="ClientCertificate" />
      </Certificates>
    </NodeType>
  </NodeTypes>
```
' ClusterCertificate ' 요소는 선택적 매개 변수 (' X509FindValueSecondary ') 또는 적절 한 기본값 (' X509StoreName ')을 포함 하는 전체 스키마를 보여 줍니다. 다른 선언은 축약 된 형식을 보여 줍니다. 위의 클러스터 인증서 선언에는 ' nt1vm ' 유형의 노드 보안 설정이 ' cc71 ' 인증서로 초기화 되어 있음을 명시 합니다. 1984 '를 기본으로, ' 49e2.. 19d6 ' 인증서를 보조 데이터베이스로 두 인증서 모두 LocalMachine \' My ' 인증서 저장소 (또는 Linux와 동등한 경로, *var/lib/sfcerts*)에 있어야 합니다.

#### <a name="common-name-based-certificate-presentation-declarations"></a>일반 이름 기반 인증서 프레젠테이션 선언
아래 예시 같이 주체 일반 이름으로 노드 형식 인증서를 선언할 수도 있습니다.

```xml
  <NodeTypes>
    <NodeType Name="nt1vm">
      <Certificates>
        <ClusterCertificate X509FindType="FindBySubjectName" X509FindValue="demo.cluster.azuredocpr.system.servicefabric.azure-int" Name="ClusterCertificate" />
      </Certificates>
    </NodeType>
  </NodeTypes>
```

두 유형의 선언 모두 Service Fabric 노드는 시작 시 구성을 읽고, 지정 된 인증서를 찾아서 로드 하 고, NotBefore 특성의 내림차순으로 정렬 합니다. 만료 된 인증서는 무시 되 고 목록의 첫 번째 요소는이 노드에서 시도 하는 모든 Service Fabric 연결에 대 한 클라이언트 자격 증명으로 선택 됩니다. 실제로는 가장 최근에 발급 된 인증서를 우선 Service Fabric 합니다.

> [!NOTE]
> 버전 7.2.445 (7.2 CU4) 이전에는 곧 만료 되는 인증서 (가장 먼 ' NotAfter ' 속성이 있는 인증서)를 선택 Service Fabric.

일반 이름 기반 프레젠테이션 선언의 경우 인증서는 해당 주체 일반 이름이 대/소문자를 구분 하는 정확한 문자열 비교 인 선언의 X509FindValue (또는 X509FindValueSecondary) 필드와 동일한 경우 일치 항목으로 간주 됩니다. 이는 와일드 카드 일치 및 대/소문자를 구분 하지 않는 문자열 비교를 지 원하는 유효성 검사 규칙과 대조 됩니다.  

### <a name="miscellaneous-certificate-configuration-settings"></a>기타 인증서 구성 설정
앞서 언급 했 듯이, Service Fabric 클러스터의 보안 설정 에서도 인증 코드의 동작을 약간 변경 하는 것을 허용 했습니다. [Service Fabric 클러스터 설정](service-fabric-cluster-fabric-settings.md) 의 문서는 포괄적인 최신 설정 목록을 나타내므로 여기에서 보안 설정 중 일부를 선택 하 여 인증서 기반 인증에 대 한 전체 공개를 완료할 수 있습니다. 각 설정에 대해 의도, 기본 값/동작, 인증에 영향을 주는 방법 및 허용 되는 값을 설명 합니다.

앞서 언급 했 듯이 인증서 유효성 검사는 항상 인증서 체인의 작성 및 평가를 의미 합니다. CA에서 발급 한 인증서의 경우이 처럼 단순한 OS API 호출에는 일반적으로 발급 하는 PKI의 다양 한 끝점에 대 한 몇 가지 아웃 바운드 호출, 응답 캐싱 등이 있습니다. Service Fabric 클러스터에서 인증서 유효성 검사 호출의 전파를 고려할 때 PKI 끝점의 모든 문제는 클러스터의 가용성을 줄이거나 완전히 분석 될 수 있습니다. 아웃 바운드 호출을 억제할 수 없는 경우 (자세한 내용은 FAQ 섹션의 아래 참조) 다음 설정을 사용 하 여 CRL 호출에 실패 한 유효성 검사 오류를 마스킹할 수 있습니다.

  * CrlCheckingFlag-"Security" 섹션에서 문자열이 UINT로 변환 됩니다. 이 설정의 값은 체인 작성의 동작을 변경 하 여 인증서 체인 상태 오류를 마스킹 하는 Service Fabric에서 사용 됩니다. 이 클래스는 ' dwFlags ' 매개 변수로 Win32 CryptoAPI [목록은 certgetcertificatechain](/windows/win32/api/wincrypt/nf-wincrypt-certgetcertificatechain) 호출에 전달 되며 함수에서 허용 하는 모든 유효한 플래그 조합으로 설정할 수 있습니다. 값 0은 Service Fabric 런타임이 신뢰 상태 오류를 강제로 무시 하도록 합니다 .이는 사용 하는 것이 중요 한 보안 노출을 구성 하므로 권장 되지 않습니다. 기본값은 0x40000000 (CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT)입니다.

  사용 시기: 자체 서명 된 인증서 또는 자체 서명 된 인증서를 사용 하 여 인증서를 지 원하는 적절 한 공개 키 인프라가 없는 개발자 인증서를 사용 하는 경우입니다. 는 Pki 간을 전환 하는 동안 gapped 환경에서 완화가 사용 될 수도 있습니다.

  사용 방법: 강제로 해지 검사를 수행 하 여 캐시 된 Url에만 액세스 하는 예를 살펴보겠습니다. 이더넷으로
  ```C++
  #define CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY         0x80000000
  ```
  그러면 클러스터 매니페스트의 선언이 다음과 같이 됩니다.
  ```xml
    <Section Name="Security">
      <Parameter Name="CrlCheckingFlag" Value="0x80000000" />
    </Section>
  ```

  * IgnoreCrlOfflineError-"보안" 섹션 아래에서 기본값은 ' f a l s e ' 인 부울 값입니다. ' 해지 오프 라인 ' 체인 빌드 오류 상태 (또는 후속 체인 정책 유효성 검사 오류 상태)를 표시 하지 않는 바로 가기를 나타냅니다.

  사용 시기: 로컬 테스트 또는 적절 한 PKI에서 지원 되지 않는 개발자 인증서. Gapped 환경에서를 완화 하거나 PKI에 액세스할 수 없는 것으로 알려져 있는 경우를 사용 합니다.

  사용 방법:
  ```xml
    <Section Name="Security">
      <Parameter Name="IgnoreCrlOfflineError" Value="true" />
    </Section>
  ```

  기타 주목할 만한 설정 ("보안" 섹션 아래 모두):
  * AcceptExpiredPinnedClusterCertificate-지문 기반 인증서 유효성 검사 전용 섹션에서 설명 합니다. 만료 된 자체 서명 된 클러스터 인증서를 허용할 수 있습니다. 
  * CertificateExpirySafetyMargin-인증서의 NotAfter 타임 스탬프 이전에 분 단위로 표시 되 고, 인증서가 만료 위험으로 간주 됩니다. Service Fabric는 클러스터 인증서를 모니터링 하 고 나머지 가용성에 대 한 상태 보고서를 주기적으로 내보냅니다. ' 보안 ' 간격 내에서 이러한 상태 보고서는 ' 경고 ' 상태로 상승 됩니다. 기본값은 30 일입니다.
  * CertificateHealthReportingInterval-클러스터 인증서의 남은 시간 유효성에 관한 상태 보고서의 빈도를 제어 합니다. 이 간격 마다 한 번만 보고서를 내보냅니다. 값은 초 단위로 표시 되며 기본값은 8 시간입니다.
  * EnforcePrevalidationOnSecurityChanges-보안 설정의 변경 내용을 검색할 때 클러스터 업그레이드의 동작을 제어 합니다. 'true'로 설정하면 클러스터 업그레이드는 프레젠테이션 규칙과 일치하는 인증서 중 하나 이상이 해당 유효성 검사 규칙을 통과할 수 있도록 합니다. 새 설정이 임의의 노드에 적용되기 전에 사전 유효성 검사가 실행되지만 업그레이드를 시작할 때 Cluster Manager 서비스의 기본 복제본을 호스트하는 노드에서만 실행됩니다. 이 문서를 작성할 당시에는 설정의 기본값은 ' f a l s e '이 고, 7.1부터 시작 하는 런타임 버전을 가진 새 Azure Service Fabric 클러스터의 경우 ' t r u e '로 설정 됩니다.
 
### <a name="end-to-end-scenario-examples"></a>종단 간 시나리오 (예제)
프레젠테이션 규칙, 유효성 검사 규칙 및 트윅 플래그를 살펴보았습니다 .이 작업은 어떻게 함께 작동 하나요? 이 섹션에서는 보안 설정을 사용 하 여 안전한 클러스터를 업그레이드할 수 있는 방법을 보여 주는 두 가지 종단 간 예제를 살펴봅니다. 이는 Service Fabric의 적절 한 인증서 관리에 대 한 포괄적인 정보를 제공 하기 위한 것이 아닙니다. 해당 항목에 대 한 도우미 문서를 찾으십시오.

프레젠테이션 및 유효성 검사 규칙을 분리 하는 경우에는 서로 분기할 수 있는지 여부와 그에 따른 결과를 알 수 있습니다. 실제로는 노드의 인증 인증서 선택이 다른 노드의 유효성 검사 규칙을 통과 하지 못할 수 있습니다. 실제로 이러한 불일치는 인증 관련 인시던트의 주요 원인입니다. 동시에 이러한 규칙을 분리 하면 클러스터의 보안 설정을 변경 하는 업그레이드 하는 동안 클러스터가 계속 작동할 수 있습니다. 첫 번째 단계로 먼저 유효성 검사 규칙을 확대 하 여 현재 자격 증명을 사용 하는 동안 모든 클러스터의 노드를 새 설정에서 수렴 한다고 가정 합니다. 

Service Fabric 클러스터에서 업그레이드는 (최대 5 개) ' 업그레이드 도메인 ' 또는 Ud으로 진행 됩니다. 지정 된 시간에 현재 UD의 노드만 업그레이드/변경 되며, 클러스터의 가용성에서 허용 하는 경우에만 업그레이드가 다음 UD로 진행 됩니다. 자세한 내용은 동일한 항목의 [클러스터 업그레이드](service-fabric-cluster-upgrade.md) 및 기타 문서를 Service Fabric 참조 하세요.) 인증서/보안 변경 내용은 클러스터에서 노드를 분리 하거나 쿼럼 손실의 가장자리에 클러스터를 그대로 둘 수 있으므로 특히 위험 합니다.

다음 표기법을 사용 하 여 노드의 보안 설정을 설명 합니다.

빈: {P:{TP = A}, V:{TP = A}}, 여기서:
  - ' 빈 '는 업그레이드 도메인 *k* 의 노드를 나타냅니다.
  - ' P '는 노드의 현재 표시 규칙을 나타냅니다 (클러스터 인증서만 참조 하 고 있다고 가정). 
  - ' V '는 노드의 현재 유효성 검사 규칙을 나타냅니다 (클러스터 인증서에만 해당).
  - ' TP = A '는 인증서 지문이 되는 ' A '가 있는 지문 기반 선언 (TP)을 나타냅니다.
  - ' CN = B '는 인증서의 주체 일반 이름이 ' B ' 인 일반 CN (이름 기반 선언)을 나타냅니다. 

#### <a name="rotating-a-cluster-certificate-declared-by-thumbprint"></a>지 문으로 선언 된 클러스터 인증서 순환
다음 시퀀스에서는 2 단계 업그레이드를 사용 하 여 지 문으로 선언 된 보조 클러스터 인증서를 안전 하 게 도입할 수 있는 방법에 대해 설명 합니다. 첫 번째 단계에서는 유효성 검사 규칙의 새 인증서 선언을 소개 하 고, 두 번째 단계는 프레젠테이션 규칙에서이를 소개 합니다.
  - 초기 상태: N0 = {P:{TP = A}, V:{TP = A}}, ... 빈 = {P:{TP = A}, V:{TP = A}}-클러스터는 미사용 이며 모든 노드는 공통 구성을 공유 합니다.
  - 업그레이드 도메인 0: N0 = {P:{TP = A}, V:{TP = A, TP = B}}, ... 빈 = {P:{TP = A}, V:{TP = A}}-UD0의 노드는 인증서 A를 제공 하 고 인증서 A 또는 B를 수락 합니다. 다른 모든 노드는 인증서 A만 제공 하 고 허용 합니다.
  - 마지막 업그레이드 도메인을 완료 한 후: N0 = {P:{TP = A}, V:{TP = A, TP = B}}, ... 빈 = {P:{TP = A}, V:{TP = A, TP = B}}-모든 노드가 인증서 A를 제공 하 고, 모든 노드에 인증서 A 또는 B를 사용할 수 있습니다.
      
이 시점에서 클러스터는 다시 평형 상태가 되며, 업그레이드/변경 보안 설정의 두 번째 단계를 시작할 수 있습니다.
  - 업그레이드 도메인 0: N0 = {P:{TP = A, TP = B}, V:{TP = A, TP = B}}, ... 빈 = {P:{TP = A}, V:{TP = A, TP = B}}-UD0의 노드는 클러스터의 다른 노드에서 허용 하는 B를 제공 하기 시작 합니다.
  - 마지막 업그레이드 도메인을 완료 한 후: N0 = {P:{TP = A, TP = B}, V:{TP = A, TP = B}}, ... 빈 = {P:{TP = A, TP = B}, V:{TP = A, TP = B}}-모든 노드가 인증서 B를 표시 하도록 전환 되었습니다. 이제 인증서 A는 이후 업그레이드 집합을 사용 하 여 클러스터 정의에서 사용 중지/제거할 수 있습니다.

#### <a name="converting-a-cluster-from-thumbprint--to-common-name-based-certificate-declarations"></a>클러스터를 손도장 (thumbprint)에서 일반 이름 기반 인증서 선언으로 변환
마찬가지로 인증서 선언 유형 (지문에서 일반 이름으로 변경)은 위와 동일한 패턴을 따릅니다. 유효성 검사 규칙을 사용 하면 동일한 클러스터 정의에서 지정 된 역할의 인증서를 지문과 일반 이름으로 선언할 수 있습니다. 반면, 프레젠테이션 규칙은 하나의 선언 형식만 허용 합니다. 참고로, 클러스터 인증서를 지문에서 일반 이름으로 변환 하는 안전한 방법은 먼저 손 도장 (thumbprint)에서 대상 인증서를 도입 하 고 해당 선언을 일반 이름 기반으로 변경 하는 것입니다. 다음 예제에서는 지문 ' A ' 및 주체 일반 이름 ' B '가 동일한 인증서를 참조 하는 것으로 가정 합니다. 

  - 초기 상태: N0 = {P:{TP = A}, V:{TP = A}}, ... 빈 = {P:{TP = A}, V:{TP = A}}-클러스터가 미사용 상태 이며, 모든 노드가 기본 인증서 지문이 되는 공통 구성을 공유 합니다.
  - 업그레이드 도메인 0: N0 = {P:{TP = A}, V:{TP = A, CN = B}}, ... 빈 = {P:{TP = A}, V:{TP = A}}-UD0의 노드는 인증서 A를 제공 하 고 지문 A 또는 일반 이름 B로 인증서를 수락 합니다. 다른 모든 노드는 인증서 A만 제공 하 고 허용 합니다.
  - 마지막 업그레이드 도메인을 완료 한 후: N0 = {P:{TP = A}, V:{TP = A, CN = B}}, ... 빈 = {P:{TP = A}, V:{TP = A, CN = B}}-모든 노드가 인증서 A를 제공 하 고, 모든 노드에 인증서 A (TP) 또는 B (CN)를 허용 합니다.

이 시점에서 후속 업그레이드를 사용 하 여 프레젠테이션 규칙을 계속 변경할 수 있습니다.
  - 업그레이드 도메인 0: N0 = {P:{CN = B}, V:{TP = A, CN = B}}, ... 빈 = {P:{TP = A}, V:{TP = A, CN = B}}-UD0의 노드는 CN으로 찾은 인증서 B를 제공 하 고 지문 A 또는 일반 이름 B로 인증서를 허용 합니다. 다른 모든 노드는 인증서 A만 허용 하 고 지문을 통해 선택 됩니다.
  - 마지막 업그레이드 도메인을 완료 한 후: N0 = {P:{CN = B}, V:{TP = A, CN = B}}, ... 빈 = {P:{CN = B}, V:{TP = A, CN = B}}-모든 노드가 CN에서 찾은 인증서 B를 제공 합니다. 모든 노드는 인증서 A (TP) 또는 B (CN)를 허용 합니다.
    
2 단계를 완료 하면 클러스터의 변환이 일반 이름 기반 인증서로 표시 됩니다. 이후 클러스터 업그레이드 시 지문 기반 유효성 검사 선언이 제거 될 수 있습니다.

> [!NOTE]
> Azure Service Fabric 클러스터에서 위에 제공 된 워크플로는 Service Fabric 리소스 공급자에 의해 오케스트레이션 됩니다. 클러스터 소유자는 표시 된 규칙 (프레젠테이션 또는 유효성 검사)에 따라 클러스터로 인증서를 프로 비전 하는 작업을 수행 하 고, 여러 단계에서 변경을 수행 하는 것이 좋습니다.

별도의 문서에서 Service Fabric 클러스터로 인증서를 관리 하 고 프로 비전 하는 항목을 설명 합니다.

## <a name="troubleshooting-and-frequently-asked-questions"></a>문제 해결 및 질문과 대답
Service Fabric 클러스터의 인증 관련 문제를 디버그 하는 것은 쉽지 않지만 다음 힌트와 팁이 도움이 될 수 hopeful. 조사를 시작 하는 가장 쉬운 방법은 클러스터의 노드에서 Service Fabric 이벤트 로그를 검사 하는 것입니다. 즉, 증상을 표시 하는 것은 아니지만 해당 환경 중 하나에 연결할 수는 없는 노드도 있습니다. Windows에서 중요 한 이벤트는 일반적으로 ' 응용 프로그램 및 서비스 Logs\Microsoft-ServiceFabric\Admin ' 또는 ' 작동 ' 채널 아래에 기록 됩니다. [CAPI2 로깅을 사용 하도록 설정](/archive/blogs/benjaminperkins/enable-capi2-event-logging-to-troubleshoot-pki-and-ssl-certificate-issues)하 여 인증서 유효성 검사, CRL/CTL 검색 등에 대 한 자세한 정보를 수집 하는 것이 유용할 수 있습니다. 재현을 완료 한 후에는 사용 하지 않도록 설정 해야 합니다. 자세한 정보를 확인할 수 있습니다.

클러스터에서 인증 문제를 발생 시킨 일반적인 증상은 다음과 같습니다. 
  - 노드가 다운/순환 되 고 있습니다. 
  - 연결 시도가 거부 되었습니다.
  - 연결 시도 시간이 초과 되었습니다.

각 증상은 다른 문제로 인해 발생할 수 있으며, 동일한 근본 원인으로 인해 다른 징후 표시 될 수 있습니다. 따라서 문제 해결에 대 한 권장 사항과 함께 일반적인 문제의 작은 샘플을 나열 합니다. 

* 노드는 메시지를 교환할 수 있지만 연결할 수는 없습니다. 연결 시도가 종료 될 수 있는 원인은 ' 인증서가 일치 하지 않습니다. ' 오류입니다. Service Fabric Service Fabric 연결의 파티 중 하나에서 받는 사람의 유효성 검사 규칙이 실패 한 인증서를 제공 하는 것입니다. 다음 오류 중 하나를 함께 사용할 수 있습니다. 
  ```C++
  0x80071c44    -2147017660 FABRIC_E_SERVER_AUTHENTICATION_FAILED
  ```
  진단/조사 추가: 연결을 시도 하는 각 노드에서 표시 되는 인증서를 확인 합니다. 인증서를 검사 하 여 유효성 검사 규칙을 시도 하 고 에뮬레이션 합니다 (지문 또는 공통 이름 같음 확인, 지정 된 경우 발급자 지문 확인).

  또 다른 일반적인 오류 코드는 다음과 같습니다.
  ```C++
  0x800b0109    -2146762487 CERT_E_UNTRUSTEDROOT
  ```
  이 경우 인증서는 일반 이름으로 선언 되며 다음 중 하나에 해당 합니다.
    - 발급자가 고정 되어 있지 않으며 루트 인증서를 신뢰할 수 없습니다. 또는
    - 발급자는 고정 되지만 선언에는이 인증서의 직접 발급자 지문이 포함 되지 않습니다.

* 노드가 up 이지만 다른 노드에 연결할 수 없습니다. 다른 노드는 오류가 발생 한 노드에서 인바운드 트래픽을 수신 하지 않습니다. 이 경우 로컬 노드에서 인증서를 로드 하지 못할 수 있습니다. 다음 오류를 확인 하십시오.
  - 인증서를 찾을 수 없음-LocalMachine\My (지정 된) 인증서 저장소의 내용으로 프레젠테이션 규칙에 선언 된 인증서를 확인할 수 있는지 확인 합니다. 
    오류가 발생할 수 있는 원인은 다음과 같습니다. 
      - 지문 선언에 잘못 된 문자가 있습니다.
      - 인증서가 설치 되어 있지 않습니다.
      - 인증서가 만료 되었습니다.
      - 일반 이름 선언에는 ' CN = ' 접두사가 포함 되어 있습니다.
      - 선언에서 와일드 카드를 지정 하 고 인증서 저장소에 정확히 일치 하는 항목이 없습니다 (선언: CN = * .ch.com, actual certificate: CN = server. mydomain).

  - 알 수 없는 자격 증명-인증서에 해당 하는 누락 된 개인 키를 나타냅니다. 일반적으로 오류 코드와 함께 
    ```C++ 
    0x8009030d  -2146893043 SEC_E_UNKNOWN_CREDENTIALS
    0x8009030e  -2146893042 SEC_E_NO_CREDENTIALS
    ```
    이를 해결 하려면 개인 키가 있는지 확인 합니다. SFAdmins에 개인 키에 대 한 ' 읽기 | 실행 ' 액세스 권한이 부여 되었는지 확인 합니다.

  - 잘못 된 공급자 유형-CNG (Crypto New Generation) 인증서 ("Microsoft 소프트웨어 키 저장소 공급자")를 나타냅니다. 현재 Service Fabric는 CAPI1 인증서만 지원 합니다. 일반적으로 오류 코드와 함께
    ```C++
    0x80090014  -2146893804 NTE_BAD_PROV_TYPE
    ```
    이를 해결 하려면 CAPI1 (예: "Microsoft 고급 RSA 및 AES 암호화 공급자") 공급자를 사용 하 여 클러스터 인증서를 다시 만듭니다. 암호화 공급자에 대 한 자세한 내용은 [암호화 공급자 이해](/windows/win32/seccertenroll/understanding-cryptographic-providers) 를 참조 하세요.
