---
title: 서비스 패브릭 클러스터의 X.509 인증서 기반 인증
description: Service Fabric 클러스터의 인증서 기반 인증및 인증서 관련 문제를 검색, 완화 및 해결하는 방법에 대해 알아봅니다.
ms.topic: conceptual
ms.date: 03/16/2020
ms.custom: sfrev
ms.openlocfilehash: 699015e322c599dea996b3a8b9dbc0a4589440ab
ms.sourcegitcommit: b80aafd2c71d7366838811e92bd234ddbab507b6
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/16/2020
ms.locfileid: "81429669"
---
# <a name="x509-certificate-based-authentication-in-service-fabric-clusters"></a>서비스 패브릭 클러스터의 X.509 인증서 기반 인증

이 문서에서는 서비스 [패브릭 클러스터 보안에](service-fabric-cluster-security.md)대한 소개를 보완하고 서비스 패브릭 클러스터에서 인증서 기반 인증에 대한 세부 정보를 설명합니다. 독자는 기본 보안 개념과 Service Fabric이 클러스터의 보안을 제어하기 위해 노출하는 컨트롤에 익숙하다고 가정합니다.  

이 제목에서 다루는 주제:

* 인증서 기반 인증 기본 사항
* ID 및 해당 역할
* 인증서 구성 규칙
* 문제 해결 및 자주 묻는 질문

## <a name="certificate-based-authentication-basics"></a>인증서 기반 인증 기본 사항
간단한 재교육으로, 보안에서 인증서는 한 엔터티(주체)에 관한 정보를 한 쌍의 비대칭 암호화 키 소유에 바인딩하기 위한 도구이므로 공개 키 암호화의 핵심 구성을 구성합니다. 인증서로 표시되는 키는 데이터를 보호하거나 키 소유자의 ID를 증명하는 데 사용할 수 있습니다. PKI(공개 키 인프라) 시스템과 함께 사용할 경우 인증서는 인터넷 도메인의 소유권 또는 인증서 발급자가 부여한 특정 권한(인증 기관 또는 CA)과 같은 주체의 추가 특성을 나타낼 수 있습니다. 인증서의 일반적인 응용 프로그램은 컴퓨터 네트워크를 통해 보안 통신을 허용하는 전송 계층 보안(TLS) 암호화 프로토콜을 지원하는 것입니다. 특히 클라이언트와 서버는 인증서를 사용하여 통신의 개인 정보 보호 및 무결성을 보장하고 상호 인증을 수행합니다.

Service Fabric에서 클러스터(페더레이션)의 기본 계층은 TLS(다른 프로토콜 중)를 기반으로 하여 참여 노드의 안정적이고 안전한 네트워크를 달성합니다. Service Fabric 클라이언트 API를 통해 클러스터에 연결하면 TLS를 사용하여 트래픽을 보호하고 당사자의 ID를 설정합니다. 특히 서비스 패브릭에서 인증에 사용되는 경우 인증서를 사용하여 인증서를 증명하는 데 사용할 수 있습니다: a) 인증서 자격 증명의 발표자가 인증서의 개인 키 b를 소유하고 있음) 인증서의 SHA-1 해시('지문')가 클러스터 정의에 포함된 선언과 일치하거나 c) 인증서의 고유 주체 공통 이름이 클러스터 정의에 포함된 선언과 일치합니다. 및 인증서 발급자가 알려져 있거나 신뢰할 수 있습니다.

위의 목록에서 'b'는 구어체로 '지문 고정'이라고 합니다. 이 경우 선언은 특정 인증서를 말하며 인증 체계의 강도는 다른 인증서와 동일한 해시 값을 생성하는 인증서를 위조하는 것이 계산적으로 불가능하다는 전제하에 있지만 다른 모든 면에서 유효하고 잘 형성된 개체입니다. 항목 'c'는 인증서를 선언하는 대체 형식을 나타내며, 여기서 구성표의 강도는 인증서의 주체와 발급 기관의 조합에 달려 있습니다. 이 경우 선언은 인증서 클래스를 참조합니다 . 

다음 섹션에서는 Service Fabric 런타임이 클러스터 보안을 보장하기 위해 인증서를 사용하고 유효성을 검사하는 방법을 자세히 설명합니다.

## <a name="identities-and-their-respective-roles"></a>ID 및 해당 역할
인증 또는 통신 채널 보안에 대한 세부 정보를 살펴보기 전에 참여 행위자와 클러스터에서 수행되는 해당 역할을 나열하는 것이 중요합니다.
- '시스템'이라고 하는 서비스 패브릭 런타임: 클러스터를 나타내는 추상화 및 기능을 제공하는 서비스 집합입니다. 시스템 인스턴스 간의 클러스터 내 통신을 참조할 때 '클러스터 ID'라는 용어를 사용합니다. 클러스터를 클러스터 외부의 트래픽수신자/대상이라고 할 때 '서버 ID'라는 용어를 사용합니다.
- '응용 프로그램'이라고 하는 호스팅 응용 프로그램: 클러스터 소유자가 제공한 코드(클러스터에서 오케스트레이션및 실행됨)
- 클라이언트: 클러스터 구성에 따라 클러스터의 기능을 연결하고 실행할 수 있는 엔터티입니다. '사용자'와 '관리자'의 두 가지 권한 수준을 각각 구분합니다. '사용자' 클라이언트는 주로 읽기 전용 작업(모든 읽기 전용 기능)으로 제한되지만 '관리자' 클라이언트는 클러스터의 기능에 제한 없이 액세스할 수 있습니다. 자세한 내용은 [서비스 패브릭 클러스터의 보안 역할을](service-fabric-cluster-security-roles.md)참조하십시오.
- (Azure 전용) 단순히 '서비스'라고 하는 서비스 패브릭 클러스터의 운영 및 관리를 위한 제어를 오케스트레이션하고 노출하는 서비스 패브릭 서비스입니다. 환경에 따라 '서비스'는 Azure 서비스 패브릭 리소스 공급자 또는 서비스 패브릭 팀이 소유하고 운영하는 다른 리소스 공급자를 참조할 수 있습니다.

보안 클러스터에서 이러한 각 역할은 미리 정의된 역할 이름과 해당 자격 증명의 페어링으로 선언된 고유한 ID로 구성할 수 있습니다. Service Fabric은 인증서 또는 도메인 기반 서비스 주체로 선언하는 자격 증명을 지원합니다. (Windows-/Kerberos 기반 ID도 지원되지만 이 문서의 범위를 벗어납니다. [서비스 패브릭 클러스터의 Windows 기반 보안을](service-fabric-windows-cluster-windows-security.md)참조하십시오.) Azure 클러스터에서 클라이언트 역할은 [Azure Active Directory 기반 ID로](service-fabric-cluster-creation-setup-aad.md)선언될 수도 있습니다.

위에서 언급했듯이 서비스 패브릭 런타임은 클러스터의 두 가지 권한 수준인 'admin'과 'user'를 정의합니다. 관리자 클라이언트와 '시스템' 구성 요소는 모두 'admin' 권한으로 작동하므로 서로 구별할 수 없습니다. 클러스터에 대한 연결을 설정하면 서비스 패브릭 런타임에서 후속 권한 부여의 기본으로 두 역할 중 하나에 의해 인증된 호출자에게 부여됩니다. 다음 섹션에서 인증을 자세히 살펴보겠습니다.

## <a name="certificate-configuration-rules"></a>인증서 구성 규칙
### <a name="validation-rules"></a>유효성 검사 규칙
서비스 패브릭 클러스터의 보안 설정은 원칙적으로 다음과 같은 측면을 설명합니다.
- 인증 유형; 이것은 클러스터의 생성 시간, 불변의 특성입니다. 이러한 설정의 예로는 'ClusterCredentialType', 'ServerCredentialType', 허용된 값은 '없음', 'x509' 또는 '창'입니다. 이 문서에서는 x509 형식 인증에 중점을 둡니다.
- (인증) 유효성 검사 규칙; 이러한 설정은 클러스터 소유자가 설정하고 지정된 역할에 대해 수락할 자격 증명을 설명합니다. 예제는 바로 아래에서 심층으로 검토됩니다.
- 인증 결과를 조정하거나 미묘하게 변경하는 데 사용되는 설정; 여기에 는 인증서 해지 목록 등의 적용을 제한하는 플래그(de-)가 있습니다.

> [!NOTE]
> 아래에 제공된 클러스터 구성 예제는 이 문서에서 설명하는 서비스 패브릭 기능을 직접 지원하는 가장 많이 소화되는 형식으로 XML 형식으로 클러스터 매니페스트에서 발췌한 것입니다. 독립 실행형 json 클러스터 매니페스트또는 Azure 리소스 관리자 템플릿 여부에 관계없이 클러스터 정의의 JSON 표현에서 동일한 설정을 직접 표현할 수 있습니다.

인증서 유효성 검사 규칙은 다음 요소로 구성됩니다.
- 해당 역할: 클라이언트, 관리자 클라이언트(권한 있는 역할)
- 지각 또는 제목 공통 이름으로 선언된 역할에 대해 수락된 자격 증명

#### <a name="thumbprint-based-certificate-validation-declarations"></a>지문 기반 인증서 유효성 검사 선언
지문 기반 유효성 검사 규칙의 경우 클러스터에 대한 연결을 요청하는 호출인이 제공하는 자격 증명은 다음과 같이 유효성을 검사합니다.
  - 자격 증명은 유효하고 잘 형성된 인증서입니다: 체인을 빌드할 수 있고 서명이 일치합니다.
  - 인증서가 유효한 시간입니다 (NotBefore <= 이제 < NotAfter)
  - 인증서의 SHA-1 해시는 모든 공백을 제외한 대/소문자를 구분하지 않는 문자열 비교로 선언과 일치합니다.

체인 빌드 또는 유효성 검사 중에 발생하는 모든 신뢰 오류는 만료된 인증서를 제외한 지문 기반 선언에 대해 억제되지만 해당 사례에 대한 규정도 존재합니다. 특히, 관련 오류: 해지 상태를 알 수 없거나 오프라인, 신뢰할 수 없는 루트, 잘못된 키 사용, 부분 체인은 치명적이지 않은 오류로 간주됩니다. 이 경우 전제는 인증서가 키 쌍의 봉투일 뿐이라는 것입니다 .

클러스터 매니페스트에서 발췌한 다음 내용은 이러한 지문 기반 유효성 검사 규칙 집합을 보여 주었습니다.

```xml
<Section Name="Security">
  <Parameter Name="ClusterCredentialType" Value="X509" />
  <Parameter Name="ServerAuthCredentialType" Value="X509" />
  <Parameter Name="AdminClientCertThumbprints" Value="d5ec...4264" />
  <Parameter Name="ClientCertThumbprints" Value="7c8f...01b0" />
  <Parameter Name="ClusterCertThumbprints" Value="abcd...1234,ef01...5678" />
  <Parameter Name="ServerCertThumbprints" Value="ef01...5678" />
</Section>
```

위의 각 항목은 앞에서 설명한 대로 특정 ID를 참조합니다. 각 항목은 쉼표로 구분된 문자열 목록으로 여러 값을 지정할 수도 있습니다. 이 예제에서는 들어오는 자격 증명의 유효성을 검사하는 경우 SHA-1 지문 'd5ec를 가진 인증서의 발표자... 4264'에는 '관리자' 역할이 부여됩니다. 반대로, 인증서 '7c8f로 인증 발신자 ... 01b0'에는 주로 읽기 전용 작업으로 제한되는 '사용자' 역할이 부여됩니다. 지문이 'abcd...'인 인증서를 제공하는 인바운드 호출자 1234' 또는 'ef01... 5678'은 클러스터의 피어 노드로 허용됩니다. 마지막으로 클러스터의 관리 끝점에 연결하는 클라이언트는 서버 인증서의 지문이 'ef01...'이 될 것으로 예상합니다. 5678'. 

앞에서 설명한 것처럼 Service Fabric은 만료된 인증서를 수락하기 위한 조항을 만듭니다. 그 이유는 인증서의 수명이 제한되어 있고 지문(특정 인증서 인스턴스참조)으로 선언할 때 인증서가 만료되도록 허용하면 클러스터에 연결하지 못하거나 클러스터가 완전히 축소되기 때문입니다. 지문 고정 인증서를 회전하는 것을 잊거나 무시하는 것은 너무 쉽기 때문에 불행히도 이러한 상황에서 복구하는 것은 어렵습니다.

이를 위해 클러스터 소유자는 지문으로 선언된 자체 서명된 인증서가 다음과 같이 유효한 것으로 간주된다는 명시를 할 수 있습니다.

```xml
  <Section Name="Security">
    <Parameter Name="AcceptExpiredPinnedClusterCertificate" Value="true" />
  </Section>
```
이 동작은 CA에서 발급한 인증서로 확장되지 않습니다. 이 경우 해지되고 손상될 것으로 알려진 만료된 인증서는 CA의 인증서 해지 목록에 더 이상 나타나지 않는 즉시 '유효'하여 보안 위험이 발생할 수 있습니다. 자체 서명된 인증서를 사용하면 클러스터 소유자가 CA 발급 인증서의 경우는 아닌 인증서의 개인 키를 보호할 책임이 있는 유일한 당사자로 간주됩니다.

#### <a name="common-name-based-certificate-validation-declarations"></a>일반적인 이름 기반 인증서 유효성 검사 선언
일반적인 이름 기반 선언은 다음 양식 중 하나를 수행합니다.
- 제목 공통 이름(전용)
- 발급자 고정을 통해 공통 이름 제목

먼저 두 선언 스타일을 예시하는 클러스터 매니페스트에서 발췌한 것을 살펴보겠습니다.
```xml
    <Section Name="Security/ServerX509Names">
      <Parameter Name="server.demo.system.servicefabric.azure-int" Value="" />
    </Section>
    <Section Name="Security/ClusterX509Names">
      <Parameter Name="cluster.demo.system.servicefabric.azure-int" Value="1b45...844d,d7fe...26c8,3ac7...6960,96ea...fb5e" />
    </Section>
```
선언은 각각 서버와 클러스터 ID를 참조합니다. CN 기반 선언에는 표준 '보안'과 는 별도로 클러스터 매니페스트에 고유한 섹션이 있습니다. 두 선언에서 'Name'은 인증서의 고유 주체 공통 이름을 나타내고 'Value' 필드는 다음과 같이 예상발급자를 나타냅니다.

- 첫 번째 경우, 선언은 서버 인증서의 고유 한 주제의 공통 이름 요소가 문자열 "server.demo.system.servicefabric.azure-int"와 일치할 것으로 예상된다고 명시합니다. 빈 'Value' 필드는 서버 인증서의 유효성이 검사되는 노드/컴퓨터에서 인증서 체인의 루트가 신뢰할 수 있다는 기대를 나타냅니다. Windows에서 인증서는 '신뢰할 수 있는 루트 CA' 저장소에 설치된 인증서에 연결할 수 있습니다.
- 두 번째 경우, 선언은 인증서의 일반적인 이름이 "cluster.demo.system.servicefabric.azure-int" 문자열과 일치하는 경우 인증서발표자가 클러스터의 피어 노드로 *수락되고* 인증서의 직접 발급자의 지문이 'Value' 필드의 쉼표로 구분된 항목 중 하나와 일치한다고 명시합니다. (이 규칙 형식은 구어체로 '발급자 고정이 있는 공통 이름'이라고 합니다.)

두 경우 모두 인증서 체인이 빌드되며 오류가 없어야 합니다. 즉, 해지 오류, 부분 체인 또는 시간 유효하지 않은 트러스트 오류는 치명적인 것으로 간주되며 인증서 유효성 검사가 실패합니다. 발급자를 고정하면 '신뢰할 수 없는 루트' 상태를 치명적이지 않은 오류로 간주합니다. 외관에도 불구하고 클러스터 소유자가 승인/수락된 발급자 집합을 자체 PKI로 제한할 수 있으므로 보다 엄격한 형식의 유효성 검사입니다.

인증서 체인이 빌드된 후 표준 TLS/SSL 정책에 대해 원격 이름으로 선언된 제목에 대해 유효성을 검사합니다. 인증서의 주체 공통 이름 또는 해당 주체 대체 이름이 클러스터 매니페스트의 CN 선언과 일치하는 경우 인증서가 일치하는 것으로 간주됩니다. 이 경우 와일드카드가 지원되며 문자열 일치는 대/소문자를 구분하지 않습니다.

앞에서 설명한 순서는 인증서에 의해 선언된 각 키 사용 유형에 대해 실행될 수 있음을 명확히 해야 합니다. 인증서가 클라이언트 인증 키 사용을 지정하면 체인이 클라이언트 역할에 대해 먼저 빌드되고 평가됩니다. 성공하면 평가가 완료되고 유효성 검사가 성공합니다. 인증서에 클라이언트 인증 사용이 없거나 유효성 검사가 실패한 경우 Service Fabric 런타임은 서버 인증에 대한 체인을 빌드하고 평가합니다.

예제를 완료하기 위해 다음 발췌는 일반적인 이름으로 클라이언트 인증서를 선언하는 방법을 보여 줍니다.
```xml
    <Section Name="Security/AdminClientX509Names">
      <Parameter Name="admin.demo.client.servicefabric.azure-int" Value="1b45...844d,d7fe...26c8,3ac7...6960,96ea...fb5e" />
    </Section>
    <Section Name="Security/ClientX509Names">
      <Parameter Name="user.demo.client.servicefabric.azure-int" Value="1b45...844d,d7fe...26c8,3ac7...6960,96ea...fb5e" />
    </Section>
```

위의 선언은 각각 관리자 및 사용자 ID에 해당합니다. 이러한 방식으로 선언된 인증서의 유효성 검사는 클러스터 및 서버 인증서의 이전 예제에 대해 설명된 것과 정확히 동일합니다.

> [!NOTE]
> 일반적인 이름 기반 선언은 일반적으로 클러스터 인증서의 회전을 단순화하고 관리를 단순화하기 위한 것입니다. 그러나 클러스터의 지속적인 가용성 및 보안을 보장하기 위해 다음 권장 사항을 준수하는 것이 좋습니다.
  * 신뢰할 수 있는 루트에 의존하는 발급자 고정선호
  * 다른 PK에서 발행자를 혼합하지 마십시오.
  * 예상되는 모든 발급자가 인증서 선언에 나열되어 있는지 확인합니다. 불일치 발급자가 유효성 검사에 실패하게 됩니다.
  * PKI의 인증서 정책 끝점을 검색 가능하고 사용 가능하며 액세스할 수 있는지 확인합니다.

X.509 인증서로 보호된 클러스터에서 연결 요청을 받으면 서비스 패브릭 런타임은 클러스터의 보안 설정을 사용하여 위에서 설명한 대로 원격 당사자의 자격 증명을 검증합니다. 성공하면 발신자/원격 파티가 인증된 것으로 간주됩니다. 자격 증명이 여러 유효성 검사 규칙과 일치하는 경우 런타임은 호출자에게 일치하는 규칙 중 가장 높은 권한의 역할을 부여합니다. 

### <a name="presentation-rules"></a>프레젠테이션 규칙
이전 섹션에서는 인증서 보안 클러스터에서 인증이 작동하는 방식을 설명합니다. 이 섹션에서는 Service Fabric 런타임 자체가 클러스터 내 통신에 사용하는 인증서를 검색하고 로드하는 방법을 설명합니다. 이를 "프레젠테이션" 규칙이라고 합니다.

유효성 검사 규칙과 마찬가지로 프레젠테이션 규칙은 지문이나 공통 이름으로 표현되는 역할 및 관련 자격 증명 선언을 지정합니다. 유효성 검사 규칙과 달리 일반적인 이름 기반 선언에는 발급자 고정에 대한 규정이 없습니다. 이를 통해 유연성이 향상될 뿐만 아니라 성능이 향상됩니다. 프리젠 테이션 규칙은 각 별개의 노드 유형에 대해 클러스터 매니페스트의 'NodeType' 섹션에 선언됩니다. 설정은 클러스터의 보안 섹션에서 분할되어 각 노드 유형이 단일 섹션에서 전체 구성을 가질 수 있도록 합니다. Azure Service Fabric 클러스터에서 노드 유형 인증서 선언은 클러스터 정의의 보안 섹션에서 해당 설정으로 기본설정됩니다.

#### <a name="thumbprint-based-certificate-presentation-declarations"></a>지문 기반 인증서 프레젠테이션 선언
앞에서 설명한 것처럼 Service Fabric 런타임은 클러스터의 다른 노드의 피어로서의 역할과 클러스터 관리 작업을 위한 서버역할을 구분합니다. 원칙적으로 이러한 설정은 뚜렷하게 구성할 수 있지만 실제로는 정렬되는 경향이 있습니다. 이 문서의 나머지 부분에서는 간편한 설정을 일치한다고 가정합니다.

클러스터 매니페스트에서 발췌한 다음 을 살펴보겠습니다.
```xml
  <NodeTypes>
    <NodeType Name="nt1vm">
      <Certificates>
        <ClusterCertificate X509FindType="FindByThumbprint" X509FindValue="cc71...1984" X509FindValueSecondary="49e2...19d6" X509StoreName="my" Name="ClusterCertificate" />
        <ServerCertificate X509FindValue="cc71...1984" Name="ServerCertificate" />
        <ClientCertificate X509FindValue="cc71...1984" Name="ClientCertificate" />
      </Certificates>
    </NodeType>
  </NodeTypes>
```
'ClusterCertificate' 요소는 선택적 매개 변수('X509FindValueSecondary') 또는 적절한 기본값('X509StoreName')을 포함한 전체 스키마를 보여 줍니다. 다른 선언은 축약된 형태를 보여 준다. 위의 클러스터 인증서 선언에 따르면 'nt1vm' 형식의 노드의 보안 설정은 인증서 'cc71.로 초기화됩니다. 1984'를 기본으로 하고 ' 49e2.. 보조로 19d6' 인증서; 두 인증서는 LocalMachine\'My 인증서 저장소(또는 Linux 동등한 경로, *var/lib/sfcerts)에서*찾을 수 있습니다.

#### <a name="common-name-based-certificate-presentation-declarations"></a>일반적인 이름 기반 인증서 프레젠테이션 선언
노드 유형 인증서는 아래 예시된 대로 주체 공통 이름으로 선언할 수도 있습니다.

```xml
  <NodeTypes>
    <NodeType Name="nt1vm">
      <Certificates>
        <ClusterCertificate X509FindType="FindBySubjectName" X509FindValue="demo.cluster.azuredocpr.system.servicefabric.azure-int" Name="ClusterCertificate" />
      </Certificates>
    </NodeType>
  </NodeTypes>
```

두 유형의 선언에 대해 Service Fabric 노드는 시작 시 구성을 읽고 지정된 인증서를 찾아 로드한 다음 NotAfter 특성의 내림차순으로 정렬합니다. 만료된 인증서는 무시되고 목록의 첫 번째 요소는 이 노드에서 시도한 모든 Service Fabric 연결에 대한 클라이언트 자격 증명으로 선택됩니다. (실제로 서비스 패브릭은 가장 먼 만료 인증서를 선호합니다.)

일반적인 이름 기반 프레젠테이션 선언의 경우 해당 주체 공통 이름이 대/소문자를 구분하는 정확한 문자열 비교로 선언의 X509FindValue(또는 X509FindValueSecondary) 필드와 같으면 인증서가 일치하는 것으로 간주됩니다. 이는 와일드카드 일치를 지원하는 유효성 검사 규칙과 대/소문자를 구분하지 않는 문자열 비교와 는 대조적입니다.  

### <a name="miscellaneous-certificate-configuration-settings"></a>기타 인증서 구성 설정
이전에 는 서비스 패브릭 클러스터의 보안 설정을 통해 인증 코드의 동작을 미묘하게 변경할 수 있다고 언급했습니다. Service Fabric [클러스터 설정에](service-fabric-cluster-fabric-settings.md) 대한 문서는 포괄적이고 최신 설정 목록을 나타내지만 여기에서 일부 보안 설정의 의미를 확장하여 인증서 기반 인증에 대한 전체 노출을 완료합니다. 각 설정에 대해 의도, 기본값/동작, 인증에 미치는 영향 및 허용 가능한 값에 대해 설명합니다.

앞서 언급했듯이 인증서 유효성 검사는 항상 인증서 체인을 구축하고 평가하는 것을 의미합니다. CA 발급 인증서의 경우 이 간단한 OS API 호출은 일반적으로 발급 PKI의 다양한 끝점에 대한 여러 아웃바운드 호출, 응답 캐싱 등을 수반합니다. 서비스 패브릭 클러스터에서 인증서 유효성 검사 호출이 보급되면 PKI 의 엔드포인트에 있는 모든 문제로 인해 클러스터의 가용성이 감소되거나 완전히 고장이 발생할 수 있습니다. 아웃바운드 호출을 억제할 수는 없지만(FAQ 섹션아래 참조)은 CRL 호출 실패로 인한 유효성 검사 오류를 마스킹하는 데 사용할 수 있습니다.

  * CrlCheckingFlag - '보안' 섹션 아래 문자열이 UINT로 변환됩니다. 이 설정의 값은 Service Fabric에서 체인 빌드의 동작을 변경하여 인증서 체인 상태 오류를 마스킹하는 데 사용됩니다. Win32 CryptoAPI [CertGetCertificateChain](https://docs.microsoft.com/windows/win32/api/wincrypt/nf-wincrypt-certgetcertificatechain) 호출에 'dwFlags' 매개 변수로 전달 되며 함수에서 허용 하는 플래그의 유효한 조합으로 설정할 수 있습니다. 값이 0이면 Service Fabric 런타임이 트러스트 상태 오류를 무시하도록 강제합니다. 기본값은 0x40000000(CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT)입니다.

  사용 시기: 로컬 테스트의 경우 자체 서명된 인증서 또는 인증서가 완전히 형성되지 않았거나 인증서를 지원하는 적절한 공개 키 인프라가 없는 개발자 인증서가 있습니다. PKY 간 전환 중에 공기 가핑 환경에서 완화로 사용할 수도 있습니다.

  사용 방법: 해지 검사를 강제로 캐시된 URL에만 액세스하도록 하는 예제를 살펴보겠습니다. 가정:
  ```C++
  #define CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY         0x80000000
  ```
  그런 다음 클러스터 매니페스트의 선언은 다음과 됩니다.
  ```xml
    <Section Name="Security">
      <Parameter Name="CrlCheckingFlag" Value="0x80000000" />
    </Section>
  ```

  * IgnoreCrlOfflineError - '보안' 섹션 아래에 'false'의 기본값을 가진 부울. '해지 오프라인' 체인 건물 오류 상태(또는 후속 체인 정책 유효성 검사 오류 상태)를 표시하기 위한 바로 가기를 나타냅니다.

  사용 시기: 로컬 테스트 또는 적절한 PKI가 백업하지 않는 개발자 인증서를 사용합니다. 공기 가입은 환경에서 또는 PKI에 액세스할 수 없는 것으로 알려진 경우 완화용으로 사용합니다.

  사용 방법:
  ```xml
    <Section Name="Security">
      <Parameter Name="IgnoreCrlOfflineError" Value="true" />
    </Section>
  ```

  기타 주목할 만한 설정(모두 '보안' 섹션 아래):
  * AcceptExpiredPinndCluster인증서 - 지문 기반 인증서 유효성 검사 전용 섹션에서 설명합니다. 만료된 자체 서명된 클러스터 인증서를 수락할 수 있습니다. 
  * 인증서ExpirySafetyMargin - 인터벌은 인증서의 NotAfter 타임스탬프 이전에 몇 분 동안 표현되며, 이 기간 동안 인증서는 만료 될 위험이 있는 것으로 간주됩니다. Service Fabric은 클러스터 인증서를 모니터링하고 남은 가용성에 대한 상태 보고서를 주기적으로 내보전합니다. '안전' 간격 내에서 이러한 건강 보고서는 '경고' 상태로 상승합니다. 기본값은 30일입니다.
  * 인증서HealthReportingInterval - 클러스터 인증서의 남은 시간 유효성에 관한 상태 보고서의 빈도를 제어합니다. 보고서는 이 간격당 한 번만 내보내집니다. 값은 초 단위로 표현되며 기본값은 8시간입니다.
  * EnforcePrevalidationOn보안변경 - 부울은 보안 설정의 변경 내용을 검색할 때 클러스터 업그레이드 동작을 제어합니다. 'true'로 설정된 경우 클러스터 업그레이드는 프레젠테이션 규칙과 일치하는 인증서 중 하나 이상이 해당 유효성 검사 규칙을 전달할 수 있도록 합니다. 사전 유효성 검사는 새 설정이 모든 노드에 적용되기 전에 실행되지만 업그레이드를 시작하기 시 클러스터 관리자 서비스의 기본 복제본을 호스팅하는 노드에서만 실행됩니다. 이 글을 쓰는 시점에서 설정은 기본값인 'false'를 가지며 7.1부터 런타임 버전이 있는 새 Azure Service Fabric 클러스터에 대해 'true'로 설정됩니다.
 
### <a name="end-to-end-scenario-examples"></a>종단 간 시나리오(예)
프레젠테이션 규칙, 유효성 검사 규칙 및 플래그 조정을 살펴보았지만 이 모든 것이 어떻게 함께 작동합니까? 이 섹션에서는 안전한 클러스터 업그레이드를 위해 보안 설정을 활용하는 방법을 보여 주는 두 가지 종단 간 예제를 살펴보겠습니다. 이는 서비스 패브릭의 적절한 인증서 관리에 대한 포괄적인 논문이 아니며 해당 항목에 대한 컴패니언 문서를 찾습니다.

프리젠 테이션 및 유효성 검사 규칙의 분리는 그들이 발산 할 수 있는지 여부의 명백한 질문 (또는 우려) 제기하고, 어떤 결과가 될 것입니다. 실제로 노드의 인증 인증서 선택은 다른 노드의 유효성 검사 규칙을 통과하지 못할 수 있습니다. 실제로 이러한 불일치는 인증 관련 인시던트의 주요 원인입니다. 동시에 이러한 규칙을 분리하면 클러스터의 보안 설정을 변경하는 업그레이드 중에 클러스터가 계속 작동할 수 있습니다. 유효성 검사 규칙을 첫 번째 단계로 보강하면 현재 자격 증명을 사용하는 동안 클러스터의 모든 노드가 새 설정에 수렴됩니다. 

서비스 패브릭 클러스터에서 업그레이드는 최대 5개의 '업그레이드 도메인' 또는 UD를 통해 진행됩니다. 현재 UD의 노드만 지정된 시간에 업그레이드/변경되고 있으며 클러스터의 가용성에 따라 허용하는 경우에만 업그레이드가 다음 UD로 진행됩니다. 자세한 내용은 동일한 항목의 [서비스 패브릭 클러스터 업그레이드](service-fabric-cluster-upgrade.md) 및 기타 문서를 참조하십시오. 인증서/보안 변경은 노드를 클러스터에서 격리하거나 클러스터를 쿼럼 손실의 가장자리에 둘 수 있으므로 특히 위험합니다.

노드의 보안 설정을 설명하기 위해 다음 표기어를 사용합니다.

Nk: {P:{TP=A}, V:{TP=A}}, 위치:
  - 'Nk'는 업그레이드 도메인 *k의* 노드를 나타냅니다.
  - 'P'는 노드의 현재 프레젠테이션 규칙을 나타냅니다(클러스터 인증서만 참조한다고 가정). 
  - 'V'는 노드의 현재 유효성 검사 규칙을 나타냅니다(클러스터 인증서만)
  - 'TP=A'는 지문 기반 선언(TP)을 나타내며, 'A'는 인증서 지문입니다.
  - 'CN=B'는 일반적인 이름 기반 선언(CN)을 나타내며, 'B'는 인증서의 주체 공통 이름입니다. 

#### <a name="rotating-a-cluster-certificate-declared-by-thumbprint"></a>지문으로 선언된 클러스터 인증서 회전
다음 순서는 지문으로 선언된 보조 클러스터 인증서를 안전하게 도입하기 위해 2단계 업그레이드를 사용하는 방법을 설명합니다. 첫 번째 단계는 유효성 검사 규칙에 새 인증서 선언을 도입하고 두 번째 단계에서는 프레젠테이션 규칙에 새 인증서 선언을 도입합니다.
  - 초기 상태: N0 = {P:{TP=A}, V:{TP=A}}, ... Nk = {P:{TP=A}, V:{TP=A}} - 클러스터가 미정이며 모든 노드가 공통 구성을 공유합니다.
  - 업그레이드 도메인 0을 완료하면 N0 = {P:{TP=A}, V:{TP=A, TP=B}}} Nk = {P:{TP=A}, V:{TP=A}} - UD0의 노드는 인증서 A를 표시하고 인증서 A 또는 B를 수락합니다. 다른 모든 노드는 인증서 A만 존재하고 수락합니다.
  - 마지막 업그레이드 도메인을 완료한 후: N0 = {P:{TP=A}, V:{TP=A, TP=B}}, ... Nk = {P:{TP=A}, V:{TP=A, TP=B}} - 모든 노드가 인증서 A를 제시하고 모든 노드는 인증서 A 또는 B를 수락합니다.
      
이 시점에서 클러스터는 다시 평형 상태이며 업그레이드/변경 보안 설정의 두 번째 단계가 시작될 수 있습니다.
  - 업그레이드 도메인 0을 완료하면 N0 = {P:{TP=A, TP=B}, V:{TP=A, TP=B}}, ... Nk = {P:{TP=A}, V:{TP=A, TP=B}} - UD0의 노드는 클러스터의 다른 노드에서 허용되는 B를 제시하기 시작합니다.
  - 마지막 업그레이드 도메인을 완료한 후: N0 = {P:{TP=A, TP=B}, V:{TP=A, TP=B}}, Nk = {P:{TP=A, TP=B}, V:{TP=A, TP=B}} - 모든 노드가 인증서 B로 전환되었습니다.

#### <a name="converting-a-cluster-from-thumbprint--to-common-name-based-certificate-declarations"></a>클러스터를 지문에서 일반적인 이름 기반 인증서 선언으로 변환
마찬가지로 인증서 선언 유형(지문에서 일반 이름으로)을 변경하면 위와 같은 패턴이 따릅니다. 유효성 검사 규칙은 동일한 클러스터 정의에서 지문과 공통 이름으로 지정된 역할의 인증서를 선언할 수 있습니다. 반대로 프레젠테이션 규칙은 한 가지 형태의 선언만 허용합니다. 또한 클러스터 인증서를 지문에서 일반 이름으로 변환하는 안전한 방법은 먼저 지문으로 의도한 대상 인증서를 도입한 다음 해당 선언을 공통 이름 기반 인증서로 변경하는 것입니다. 다음 예제에서는 지문 'A'와 제목 공통 이름 'B'가 동일한 인증서를 참조한다고 가정합니다. 

  - 초기 상태: N0 = {P:{TP=A}, V:{TP=A}}, ... Nk = {P:{TP=A}, V:{TP=A}} - 클러스터가 미사용 이며 모든 노드가 공통 구성을 공유하고 A는 기본 인증서 지문입니다.
  - 업그레이드 도메인 0을 완료하면 N0 = {P:{TP=A}, V:{TP=A, CN=B}}, ... Nk = {P:{TP=A}, V:{TP=A}} - UD0의 노드는 인증서 A를 표시하고 지문 A 또는 공통 이름 B가 있는 인증서를 수락합니다. 다른 모든 노드는 인증서 A만 존재하고 수락합니다.
  - 마지막 업그레이드 도메인을 완료한 후: N0 = {P:{TP=A}, V:{TP=A, CN=B}}} Nk = {P:{TP=A}, V:{TP=A, CN=B}} - 모든 노드가 인증서 A를 제시하고 모든 노드는 인증서 A(TP) 또는 B(CN)를 수락합니다.

이 시점에서 우리는 후속 업그레이드와 프리젠 테이션 규칙을 변경 진행할 수 있습니다 :
  - 업그레이드 도메인 0을 완료하면 N0 = {P:{CN=B}, V:{TP=A, CN=B}}, ... Nk = {P:{TP=A}, V:{TP=A, CN=B}} - UD0의 노드는 CN에서 찾은 인증서 B를 제시하고 지문 A 또는 공통 이름 B가 있는 인증서를 수락합니다. 다른 모든 노드가 존재하고 지문으로 선택한 인증서 A만 수락합니다.
  - 마지막 업그레이드 도메인을 완료한 후: N0 = {P:{CN=B}, V:{TP=A, CN=B}}, ... Nk = {P:{CN=B}, V:{TP=A, CN=B}} - 모든 노드는 CN에서 찾은 인증서 B를 제시하며, 모든 노드는 인증서 A(TP) 또는 B(CN)를 수락합니다.
    
2단계를 완료한 것은 클러스터를 일반적인 이름 기반 인증서로 변환하는 것을 표시합니다. 이후 클러스터 업그레이드에서 지문 기반 유효성 검사 선언을 제거할 수 있습니다.

> [!NOTE]
> Azure Service Fabric 클러스터에서 위에 제시된 워크플로는 서비스 패브릭 리소스 공급자에 의해 오케스트레이션됩니다. 클러스터 소유자는 표시된 규칙(프레젠테이션 또는 유효성 검사)에 따라 인증서를 클러스터에 프로비전할 책임이 있으며 여러 단계에서 변경 사항을 수행하는 것이 좋습니다.

별도의 문서에서는 서비스 패브릭 클러스터로 인증서 관리 및 프로비전문제를 다룹니다.

## <a name="troubleshooting-and-frequently-asked-questions"></a>문제 해결 및 자주 묻는 질문
Service Fabric 클러스터에서 인증 관련 문제를 디버깅하는 것은 쉽지 않지만 다음과 같은 힌트와 팁이 도움이 될 수 있기를 희망합니다. 조사를 시작하는 가장 쉬운 방법은 클러스터의 노드에서 Service Fabric 이벤트 로그를 검사하는 것입니다. Windows에서 중요한 이벤트는 일반적으로 각각 '응용 프로그램 및 서비스 로그\Microsoft-ServiceFabric\Admin' 또는 '운영' 채널아래에 기록됩니다. 때로는 [CAPI2 로깅을 활성화하여](https://docs.microsoft.com/archive/blogs/benjaminperkins/enable-capi2-event-logging-to-troubleshoot-pki-and-ssl-certificate-issues)인증서 유효성 검사, CRL / CTL 검색 등에 대한 자세한 내용을 캡처하는 것이 유용 할 수 있습니다 (재현을 완료 한 후 사용하지 않도록 설정하는 것을 기억하십시오. 매우 상세할 수 있습니다.)

인증 문제가 발생하는 클러스터에서 나타나는 일반적인 증상은 다음과 같습니다. 
  - 노드가 다운/순환 
  - 연결 시도가 거부됨
  - 연결 시도는 타이밍 이 내외입니다.

각 증상은 다른 문제로 인해 발생할 수 있으며 동일한 근본 원인은 다른 증상을 보일 수 있습니다. 따라서 일반적인 문제의 작은 샘플을 나열하고 수정하기 위한 권장 사항을 나열합니다. 

* 노드는 메시지를 교환할 수 있지만 연결할 수는 없습니다. 연결 시도가 종료될 수 있는 원인은 '일치하지 않는 인증서' 오류입니다. 다음 중 하나를 동반할 수 있습니다. 
  ```C++
  0x80071c44    -2147017660 FABRIC_E_SERVER_AUTHENTICATION_FAILED
  ```
  추가 진단/조사: 연결을 시도하는 각 노드에서 제시되는 인증서를 결정합니다. 인증서를 검사하고 유효성 검사 규칙을 복사하여 에뮬레이트합니다(지문 또는 일반적인 이름 같음 확인, 지정된 경우 발급자 지문 확인).

  또 다른 일반적인 오류 코드는 다음과 같은 것일 수 있습니다.
  ```C++
  0x800b0109    -2146762487 CERT_E_UNTRUSTEDROOT
  ```
  이 경우 인증서는 공통 이름으로 선언되며 다음 중 하나가 적용됩니다.
    - 발급자가 고정되지 않고 루트 인증서가 신뢰할 수 없거나
    - 발급자가 고정되어 있지만 선언에는 이 인증서의 직접 발급자의 지문이 포함되지 않습니다.

* 노드가 위로 있지만 다른 노드에 연결할 수 없습니다. 다른 노드는 실패한 노드에서 인바운드 트래픽을 받지 않습니다. 이 경우 로컬 노드에서 인증서 로드가 실패할 수 있습니다. 다음과 같은 오류를 찾습니다.
  - 인증서를 찾을 수 없습니다 - 프레젠테이션 규칙에 선언된 인증서가 LocalMachine\My(또는 지정된) 인증서 저장소의 내용에 의해 확인할 수 있는지 확인합니다. 
    실패의 가능한 원인은 다음과 같습니다. 
      - 지문 선언에서 잘못된 문자
      - 인증서가 설치되지 않았습니다.
      - 인증서가 만료되었습니다.
      - 일반적인 이름 선언에는 접두사 'CN='
      - 선언은 와일드카드를 지정하고 인증서 저장소에 정확한 일치가 없음(선언: CN=*mydomain.com, 실제 인증서: CN=server.mydomain.com)

  - 알 수 없는 자격 증명 - 인증서에 해당하는 누락된 개인 키가 일반적으로 오류 코드와 함께 있음을 나타냅니다. 
    ```C++ 
    0x8009030d  -2146893043 SEC_E_UNKNOWN_CREDENTIALS
    0x8009030e  -2146893042 SEC_E_NO_CREDENTIALS
    ```
    해결하려면 개인 키의 존재를 확인하십시오. SFAdmins가 개인 키에 대한 'read|execute' 액세스 권한을 부여했는지 확인합니다.

  - 잘못된 공급자 유형 - 암호화 새 세대(CNG) 인증서("Microsoft 소프트웨어 키 저장소 공급자")를 나타냅니다. 현재 서비스 패브릭은 CAPI1 인증서만 지원합니다. 일반적으로 오류 코드가 함께 제공됩니다.
    ```C++
    0x80090014  -2146893804 NTE_BAD_PROV_TYPE
    ```
    해결하려면 CAPI1(예: "Microsoft 향상된 RSA 및 AES 암호화 공급자") 공급자를 사용하여 클러스터 인증서를 다시 만듭니다. 암호화 공급자에 대한 자세한 내용은 [암호화 공급자 이해를](https://docs.microsoft.com/windows/win32/seccertenroll/understanding-cryptographic-providers) 참조하십시오.

