---
title: Azure SQL Database 구매 모델 | Microsoft Docs
description: Azure SQL Database에 대한 구매 모델을 알아봅니다.
services: sql-database
author: CarlRabeler
ms.service: sql-database
ms.custom: DBs & servers
ms.topic: conceptual
ms.date: 07/16/2018
manager: craigg
ms.author: carlrab
ms.openlocfilehash: f40fe3da6874d8656c9c0a0ddce9fed602cb25f9
ms.sourcegitcommit: e32ea47d9d8158747eaf8fee6ebdd238d3ba01f7
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/17/2018
ms.locfileid: "39091918"
---
# <a name="azure-sql-database-purchasing-models-and-resources"></a>Azure SQL Database 구매 모델 및 리소스 

[Azure SQL Database](sql-database-technical-overview.md)의 논리 서버는 계산, 저장소 및 IO 리소스에 대한 두 가지 구매 모델, 즉 DTU 기반 구매 모델과 vCore 기반 구매 모델을 제공합니다. 

> [!NOTE]
> Azure SQL Database의 [관리되는 인스턴스](sql-database-managed-instance.md)는 vCore 기반 구매 모델만 제공합니다.

다음 표와 차트에서는 이 두 가지 구매 모델을 비교하고 대조합니다.

> [!IMPORTANT]
> vCore 기반 구매 모델의 경우, [vCore 기반 구매 모델](sql-database-service-tiers-vcore.md)을 참조하세요.

|**구매 모델**|**설명**|**적합한 대상**|
|---|---|---|
|DTU 기반 모델|계산, 저장소 및 IO 리소스를 번들로 묶은 측정값을 기반으로 합니다. 성능 수준은 단일 데이터베이스에 대해서는 DTU(데이터베이스 트랜잭션 단위), 탄력적 풀에 대해서는 eDTU(탄력적 데이터베이스 트랜잭션 단위)로 표현됩니다. DTU 및 eDTU에 대한 자세한 내용은 [DTU 및 eDTU란?](sql-database-service-tiers.md#what-are-database-transaction-units-dtus)을 참조하세요.|간단하고 미리 구성된 리소스 옵션을 원하는 고객에게 가장 적합합니다.| 
|vCore 기반 모델|이 모델을 사용하면 계산 및 저장소 리소스를 독립적으로 크기 조정할 수 있습니다. SQL Server에 대한 Azure 하이브리드 혜택을 사용하여 비용을 절약할 수 있습니다.|유연성, 제어 및 투명성을 중요시하는 고객에게 가장 적합합니다.|
||||  

![가격 책정 모델](./media/sql-database-service-tiers/pricing-model.png)

## <a name="vcore-based-purchasing-model"></a>vCore 기반 구매 모델 

가상 코어는 하드웨어 세대 중에서 선택할 수 있는 옵션과 함께 제공되는 논리 CPU를 나타냅니다. vCore 기반 구매 모델은 개별 리소스 사용에 대한 유연성, 제어, 투명성 및 온-프레미스 워크로드 요구 사항을 클라우드로 전환하는 직관적인 방법을 제공합니다. 이 모델을 통해 워크로드 요구 사항에 따라 계산, 메모리 및 저장소의 크기를 조정할 수 있습니다. vCore 기반 구매 모델에서 고객은 [단일 데이터베이스](sql-database-single-database-scale.md) 및 [탄력적 풀](sql-database-elastic-pool.md) 모두에 대해 범용 및 중요 비즈니스 서비스 계층 중에서 선택할 수 있습니다. 

vCore 기반 구매 모델을 사용하면 계산 및 저장소 리소스의 크기를 독립적으로 조정하고, 온-프레미스 성능에 맞추고, 가격을 최적화할 수 있습니다. 데이터베이스 또는 탄력적 풀에서 300을 초과하는 DTU를 vCore로 변환하면 비용을 절약할 수 있습니다. 선택한 API를 사용하거나 Azure Portal을 사용하여 가동 중지 시간 없이 변환할 수 있습니다. 그러나 변환이 필요하지 않습니다. DTU 구매 모델이 성능 및 비즈니스 요구 사항을 충족하는 경우 이 모델을 계속 사용해야 합니다. DTU 모델을 vCore 모델로 변환하려는 경우 경험 규칙을 사용하여 성능 수준을 선택해야 합니다. 이 경우 표준 계층의 각 100DTU에는 범용 계층에서 하나 이상의 vCore가 필요합니다. 프리미엄 계층의 각 125DTU에는 중요 비즈니스용 계층에서 하나 이상의 vCore가 필요합니다.

vCore 기반 구매 모델에서 고객이 지불하는 비용은 다음과 같습니다.
- 계산(서비스 계층 + vCore 수 + 하드웨어 세대)*
- 데이터 저장소 및 로그 저장소의 유형 및 크기 
- IO 수**
- 백업 저장소(RA-GRS)** 

\* 최초 공개 미리 보기에서 4세대 논리 CPU는 Intel E5-2673 v3(Haswell) 2.4GHz 프로세서를 기반으로 합니다.

\*\* 미리 보기 동안 백업 및 IO는 7일간 무료입니다.

> [!IMPORTANT]
> 계산, IO, 데이터 저장소 및 로그 저장소는 데이터베이스 또는 탄력적 풀당 요금이 부과됩니다. 백업 저장소는 각 데이터베이스당 요금이 부과됩니다. 관리되는 인스턴스 요금에 대한 자세한 내용은 [Azure SQL Database 관리되는 인스턴스](sql-database-managed-instance.md)를 참조하세요.
> **지역 제한:** vCore 기반 구매 모델은 유럽 서부, 프랑스 중부, 영국 남부, 영국 서부 및 오스트레일리아 남동부 등의 지역에서는 아직 사용할 수 없습니다.

## <a name="dtu-based-purchasing-model"></a>DTU 기반 구매 모델

DTU(데이터베이스 처리량 단위)는 CPU, 메모리, 읽기 및 쓰기의 혼합 측정값을 나타냅니다. DTU 기반 구매 모델은 다양한 수준의 응용 프로그램 성능을 구동하기 위해 계산 리소스 및 포함된 저장소를 미리 구성된 번들로 묶은 집합을 제공합니다. 매월 미리 구성된 번들과 고정된 지불 금액의 단순성을 선호하는 고객은 DTU 기반 모델이 자신의 요구 사항에 더 적합하다는 것을 알 수 있습니다. DTU 기반 구매 모델에서 고객은 [단일 데이터베이스](sql-database-single-database-scale.md) 및 [탄력적 풀](sql-database-elastic-pool.md) 모두에 대해 **기본**, **표준** 및 **프리미엄** 서비스 계층 중에서 선택할 수 있습니다. 

### <a name="what-are-database-transaction-units-dtus"></a>DTU(데이터베이스 트랜잭션 단위)란?
[서비스 계층](sql-database-single-database-scale.md) 내 특정 성능 수준의 단일 Azure SQL Database에 대해 Microsoft는 해당 데이터베이스(Azure 클라우드의 다른 데이터베이스와는 무관)에 대해 특정 수준의 리소스를 보장하며 예측 가능한 성능 수준을 제공합니다. 리소스 양은 DTU(데이터베이스 트랜잭션 단위) 수로 계산되며 계산, 저장소 및 IO 리소스를 번들로 묶은 측정값입니다. 원래 이러한 리소스 간의 비율은 일반적인 실제 OLTP 워크로드에 맞게 디자인된 [OLTP 벤치마크 워크로드](sql-database-benchmark-overview.md)에 따라 결정되었습니다. 워크로드가 이러한 리소스의 양을 초과하면 처리량이 제한되어 성능이 느려지고 시간이 초과됩니다. 워크로드에서 사용되는 리소스는 Azure 클라우드의 다른 SQL 데이터베이스에 사용할 수 있는 리소스에 영향을 주지 않고, 다른 워크로드에서 사용되는 리소스는 사용자의 SQL 데이터베이스에 사용할 수 있는 리소스에 영향을 주지 않습니다.

![경계 상자](./media/sql-database-what-is-a-dtu/bounding-box.png)

DTU는 다른 성능 수준 및 서비스 계층에서 Azure SQL Database 간의 리소스의 상대 크기를 이해하는 데 가장 유용합니다. 예를 들어, 데이터베이스의 성능 수준을 증가하여 DTU를 두 배로 높일 경우 해당 데이터베이스에 사용할 수 있는 리소스 집합이 동일하게 두 배로 높아집니다. 예를 들어 1750 DTU를 사용하는 프리미엄 P11 데이터베이스는 5개의 DTU를 사용하는 기본 데이터베이스보다 350배 더 많은 DTU 계산 기능을 제공합니다.  

워크로드의 리소스(DTU) 소비에 대해 더 자세히 이해하려면 [Azure SQL Database Query Performance Insight](sql-database-query-performance.md)를 사용하여 다음을 수행합니다.

- 향상된 성능을 위해 잠재적으로 조정될 수 있는 CPU/기간/실행 횟수별 최상위 쿼리를 식별합니다. 예를 들어 IO를 많이 사용하는 쿼리는 [메모리 내 최적화 기술](sql-database-in-memory.md)을 사용하여 특정 서비스 계층 및 성능 수준에서 사용 가능한 메모리를 보다 효율적으로 사용할 수 있는 이점이 있습니다.
- 쿼리에 대한 세부 정보로 드릴다운하고, 해당 텍스트 및 리소스 사용률에 대한 기록을 확인합니다.
- [SQL Database Advisor](sql-database-advisor.md)에서 수행한 작업을 표시하는 성능 조정 권장 사항에 액세스합니다.

응용 프로그램 가동 중지 시간을 최소로 하여 언제든지 [DTU 서비스 계층](sql-database-service-tiers-dtu.md)을 변경할 수 있습니다(일반적으로 평균 4초 미만). 많은 업무와 앱에서, 특히 사용 패턴이 비교적 예측 가능한 경우 데이터베이스를 만들고 성능을 확장하거나 축소할 수 있으면 충분합니다. 하지만 사용 패턴을 예측할 수 없는 경우 비용과 비즈니스 모델을 관리하기 어려워질 수 있습니다. 이 시나리오에서는 풀의 여러 데이터베이스 간에 공유되는 특정 개수의 eDTU가 포함된 탄력적 풀을 사용합니다.

![SQL Database 소개: 계층 및 수준별 단일 데이터베이스 DTU](./media/sql-database-what-is-a-dtu/single_db_dtus.png)

### <a name="what-are-elastic-database-transaction-units-edtus"></a>eDTU(탄력적 데이터베이스 트랜잭션 단위)란?
SQL Database에 항상 필요하지 않을 수도 있는데 항상 사용할 수 있는 전용 리소스 집합(DTU)을 SQL Database에 제공하는 대신, 해당 데이터베이스 간에 리소스 풀을 공유하는 SQL Database 서버의 [탄력적 풀](sql-database-elastic-pool.md)에 데이터베이스를 배치할 수 있습니다. 탄력적 풀의 공유 리소스는 eDTU(Elastic Database 트랜잭션 단위)로 측정됩니다. 탄력적 풀은 매우 다양하고 예측할 수 없는 사용 패턴을 지닌 여러 데이터베이스에 대한 성능 목표를 관리하기 위한 간단하고 비용 효율적인 솔루션을 제공합니다. 탄력적 풀은 풀의 한 데이터베이스에서 리소스를 모두 사용할 수 없도록 하는 동시에 풀의 각 데이터베이스에서 항상 필요한 최소량의 리소스를 사용할 수 있도록 합니다. 

![SQL Database 소개: 계층 및 수준별 eDTU](./media/sql-database-what-is-a-dtu/sqldb_elastic_pools.png)

풀에는 정해진 가격으로 정해진 개수의 eDTU가 제공됩니다. 탄력적 풀에 속한 개별 데이터베이스는 구성된 경계 내에서 자동 크기 조정할 수 있습니다. 부하가 높은 데이터베이스는 요구를 충족하기 위해 더 많은 eDTU를 사용합니다. 부하가 낮은 데이터베이스는 더 적은 eDTU를 사용합니다. 부하가 없는 데이터베이스는 eDTU를 사용하지 않습니다. 데이터베이스 단위가 아니라 전체 풀에 대한 리소스를 프로비전하면 관리 작업이 간소화되고 풀 예산을 예측할 수 있습니다.

추가 eDTU는 데이터베이스 가동 중지 시간 없이 풀의 데이터베이스에 영향을 주지 않은 채 기존 풀에 추가할 수 있습니다. 마찬가지로 더 이상 필요하지 않은 추가 eDTU는 언제든지 기존 풀에서 제거할 수 있습니다. 풀에 데이터베이스를 추가 또는 제거하거나 한 데이터베이스에서 부하가 높을 때 사용할 수 있는 eDTU 양을 제한하여 다른 데이터베이스를 위한 eDTU를 확보할 수 있습니다. 데이터베이스에서 예측 가능한 방식으로 리소스를 과소 사용하는 경우 풀 외부로 데이터베이스를 이동하고 예측 가능한 필수 리소스 양을 할당하여 단일 데이터베이스로 구성할 수 있습니다.

### <a name="how-can-i-determine-the-number-of-dtus-needed-by-my-workload"></a>내 워크로드에 필요한 DTU의 수를 결정하려면 어떻게 해야 하나요?
기존 온-프레미스 또는 SQL Server 가상 머신 워크로드를 Azure SQL Database에 마이그레이션하려는 경우 [DTU 계산기](http://dtucalculator.azurewebsites.net/) 를 사용하여 필요한 DTU의 수를 대략적으로 계산할 수 있습니다. 기존 Azure SQL Database 워크로드의 경우, 워크로드 최적화 방법에 대한 심도 깊은 인사이트를 얻기 위해 [SQL Database Query Performance Insight](sql-database-query-performance.md)를 사용하여 데이터베이스 리소스 사용량(DTU)을 해석할 수 있습니다. [sys.dm_db_ resource_stats](https://msdn.microsoft.com/library/dn800981.aspx) DMV를 사용하여 지난 1시간 동안의 리소스 사용량을 확인할 수도 있습니다. 또는 카탈로그 뷰 [sys.resource_stats](http://msdn.microsoft.com/library/dn269979.aspx)에서 지난 14일 동안의 리소스 사용량을 표시하지만 충실도가 평균 5분으로 더 낮습니다.

### <a name="how-do-i-know-if-i-could-benefit-from-an-elastic-pool-of-resources"></a>리소스의 탄력적 풀의 이점이 있다면 어떻게 알 수 있나요?
풀은 특정 사용 패턴을 가진 많은 데이터베이스에 적합합니다. 지정된 데이터베이스에서 이 패턴은 평균 사용률이 낮고, 사용률 급증이 비교적 드문 데이터베이스를 나타냅니다. SQL Database는 기존 SQL Database 서버에서 데이터베이스의 기록 리소스 사용률을 자동으로 평가하고 Azure Portal의 적절한 풀 구성을 권장합니다. 자세한 내용은 [탄력적 풀을 사용해야 하는 경우](sql-database-elastic-pool.md)를 참조하세요.

### <a name="what-happens-when-i-hit-my-maximum-dtus"></a>내 최대 DTU에 도달한 경우 어떻게 되나요?
선택한 서비스 계층/성능 수준에 허용되는 최댓값까지 데이터베이스 워크로드를 실행하는 데 필요한 리소스를 제공하도록 성능 수준이 보정 및 제어됩니다. 워크로드가 CPU/데이터 IO/로그 IO 제한 중 하나에 도달할 경우, 허용 가능한 최대 수준의 리소스를 계속 받지만, 쿼리 대기 시간이 증가할 가능성이 큽니다. 속도 저하가 너무 심해서 쿼리 시간 초과가 시작되지 않으면 이러한 한도에 오류가 발생하지는 않지만 워크로드에서 작업 속도가 느려집니다. 허용되는 최대 동시 사용자 세션/요청(작업자 스레드)에 도달하면 명시적 오류가 표시됩니다. CPU, 메모리, 데이터 IO 또는 트랜잭션 로그 IO와 관련이 없는 리소스 제한에 대한 자세한 내용은 [Azure SQL Database 리소스 제한]( sql-database-resource-limits.md#what-happens-when-database-resource-limits-are-reached)을 참조하세요.

### <a name="correlating-benchmark-results-to-real-world-database-performance"></a>벤치마크 결과와 실제 데이터베이스 성능 간 상관 관계 분석
모든 벤치마크는 대표적, 암시적 수치임을 이해하는 것이 중요합니다. 벤치마크 응용 프로그램에서 달성한 트랜잭션 속도는 다른 응용 프로그램에서 달성할 수 있는 속도와 동일하지 않습니다. 벤치마크는 다양한 테이블 및 데이터 유형이 포함된 스키마에 대해 실행되는 다양한 트랜잭션 유형의 컬렉션으로 구성되어 있습니다. 벤치마크는 모든 OLTP 워크로드에 공통적이고 동일한 기본 작업을 실행하며 특정 클래스의 데이터베이스 또는 응용 프로그램을 나타내지 않습니다. 벤치마크의 목표는 성능 수준 사이에서 확장 또는 축소할 경우 예상할 수 있는 데이터베이스의 상대적 성능에 대한 합리적 지침을 제공하는 것입니다. 실제로, 각 데이터베이스는 크기와 복잡성이 다르고 다양하게 혼합된 워크로드를 처리할 수 있으며 각각 다른 방식으로 대응합니다. 예를 들어, IO를 많이 사용하는 응용 프로그램은 IO 임계값에 빠르게 도달할 수 있고 CPU를 많이 사용하는 응용 프로그램은 CPU 한도에 빠르게 도달할 수 있습니다. 부하가 증가할 때 특정 데이터베이스가 벤치마크와 동일하게 확장된다는 보장이 없습니다.

벤치마크와 그 방법론은 아래에서 더 자세히 설명합니다.

### <a name="benchmark-summary"></a>벤치마크 요약
ASDB는 OLTP(온라인 트랜잭션 처리) 워크로드에서 가장 빈번하게 발생하는 기본 데이터베이스 작업의 성능을 측정합니다. 클라우드 컴퓨팅을 예상하고 벤치마크를 설계했지만, 데이터베이스 스키마, 데이터 채우기, 트랜잭션은 OLTP 워크로드에서 가장 일반적으로 사용되는 기본 요소를 광범위하게 나타내도록 설계되었습니다.

### <a name="schema"></a>스키마
스키마는 다양한 작업을 지원하도록 다양하고 복잡하게 설계되었습니다. 벤치마크는 6개의 테이블로 구성된 데이터베이스에 실행합니다. 테이블은 고정 크기, 확장, 증가의 세 범주로 구분됩니다. 2개의 고정 크기 테이블, 3개의 확장 테이블, 1개의 증가 테이블이 있습니다. 고정 크기 테이블에는 고정된 수의 행이 있습니다. 확장 테이블에는 데이터베이스 성능에 비례하는 카디널리티가 있지만 벤치마크 중에는 변경되지 않습니다. 증가 테이블은 초기 로드 시 확장 테이블과 같은 크기이지만, 행을 삽입 및 증가하면서 벤치마크를 실행하는 동안 카디널리티가 변경됩니다.

스키마에는 정수, 숫자, 문자, 날짜/시간 등 혼합된 데이터 유형이 포함되어 있습니다. 스키마에는 기본 및 보조 키가 포함되어 있지만 외부 키가 없습니다. 즉, 테이블 간 참조 무결성 제약 조건이 없습니다.

데이터 생성 프로그램은 초기 데이터베이스의 데이터를 생성합니다. 정수 및 숫자 데이터는 다양한 전략으로 생성됩니다. 값이 범위에 무작위로 분포되는 경우도 있습니다. 또한 특정 분포를 유지하기 위해 값 집합을 무작위로 변경하는 경우도 있습니다. 가중치를 적용한 단어 목록에서 텍스트 필드를 생성하여 현실적 데이터를 만듭니다.

데이터베이스는 "배율"을 기준으로 크기를 조정합니다. 배율(약어: SF)은 확장 및 증가 테이블의 카디널리티를 결정합니다. 아래의 사용자 및 속도 섹션에 설명된 대로 데이터베이스 크기, 사용자 수, 최대 성능은 모두 서로에 비례하여 확장됩니다.

### <a name="transactions"></a>트랜잭션
워크로드는 아래 표와 같이 9가지 트랜잭션 유형으로 구성되어 있습니다. 각 트랜잭션은 다른 트랜잭션과 크게 대비되도록 데이터베이스 엔진 및 시스템 하드웨어에서 특정 시스템 집합의 특성을 강조하도록 설계되었습니다. 이 방식에서는 다양한 구성 요소가 전반적 성능에 미치는 영향을 쉽게 평가할 수 있습니다. 예를 들어 "읽기 작업이 많은" 트랜잭션은 디스크에서 많은 읽기 작업을 만듭니다.

| 트랜잭션 유형 | 설명 |
| --- | --- |
| 적은 읽기 작업 |SELECT, 메모리 내, 읽기 전용 |
| 중간 읽기 작업 |SELECT, 대부분 메모리 내, 읽기 전용 |
| 많은 읽기 작업 |SELECT, 대부분 메모리 외, 읽기 전용 |
| 적은 업데이트 작업 |UPDATE, 메모리 내, 읽기-쓰기 |
| 많은 업데이트 작업 |UPDATE, 대부분 메모리 외, 읽기-쓰기 |
| 적은 삽입 작업 |INSERT, 메모리 내, 읽기-쓰기 |
| 많은 삽입 작업 |INSERT, 대부분 메모리 외, 읽기-쓰기 |
| 삭제 |DELETE, 메모리 내 및 메모리 외 혼합, 읽기-쓰기 |
| 많은 CPU 사용 |SELECT, 메모리 내, 상대적으로 많은 CPU 부하, 읽기 전용 |

### <a name="workload-mix"></a>워크로드 혼합
가중치를 적용한 분포에서 다음과 같은 전반적 혼합을 적용하여 무작위로 트랜잭션을 선택합니다. 전반적 혼합은 읽기/쓰기 비율이 약 2:1입니다.

| 트랜잭션 유형 | 혼합 비율 |
| --- | --- |
| 적은 읽기 작업 |35 |
| 중간 읽기 작업 |20 |
| 많은 읽기 작업 |5 |
| 적은 업데이트 작업 |20 |
| 많은 업데이트 작업 |3 |
| 적은 삽입 작업 |3 |
| 많은 삽입 작업 |2 |
| 삭제 |2 |
| 많은 CPU 사용 |10 |

### <a name="users-and-pacing"></a>사용자 및 속도
벤치마크 워크로드는 연결 집합에 트랜잭션을 제출하는 도구를 기반으로 많은 동시 사용자의 동작을 시뮬레이션합니다. 모든 연결과 트랜잭션이 시스템에서 생성된 것이지만, 간단히 이러한 연결을 "사용자"로 지칭합니다. 각 사용자는 나머지 사용자와 독립적으로 운영하지만, 모든 사용자는 아래와 같이 동일한 단계의 주기를 수행합니다.

1. 데이터베이스에 연결합니다.
2. 끝내라는 메시지가 표시될 때까지 계속 반복합니다.
   * (가중치가 적용된 분포에서) 무작위로 트랜잭션을 선택합니다.
   * 선택한 트랜잭션을 수행하고 응답 시간을 측정합니다.
   * 속도 지연을 기다립니다.
3. 데이터베이스 연결을 종료합니다.
4. 끝내기를 클릭합니다.

(2c 단계에서) 무작위이지만 평균 1.0초의 분포가 있는 속도 지연을 선택합니다. 따라서 각 사용자는 평균적으로 1초당 최대 1개의 트랜잭션을 생성할 수 있습니다.

### <a name="scaling-rules"></a>확장 규칙
사용자 수는 데이터베이스 크기로 결정됩니다(배율 단위). 5개의 배율 단위당 1명의 사용자가 있습니다. 속도 지연으로 인해 1명의 사용자는 평균적으로 초당 최대 1개의 트랜잭션을 생성할 수 있습니다.

예를 들어, 배율이 500(SF=500)인 데이터베이스는 사용자가 100명이며 최대 100TPS의 속도를 달성할 수 있습니다. TPS 속도를 높이려면 더 많은 사용자와 더 큰 데이터베이스가 필요합니다.

아래 표는 각 서비스 계층 및 성능 수준에서 실제로 유지된 사용자 수를 보여줍니다.

| 서비스 계층(성능 수준) | 사용자 | 데이터베이스 크기 |
| --- | --- | --- |
| Basic |5 |720MB |
| Standard(S0) |10 |1 GB |
| Standard(S1) |20 |2.1GB |
| Standard(S2) |50 |7.1GB |
| Premium(P1) |100 |14 GB |
| Premium(P2) |200 |28GB |
| Premium(P6) |800 |114GB |

### <a name="measurement-duration"></a>측정 기간
유효한 벤치마크를 실행하려면 한 시간 이상의 안정적 측정 기간이 필요합니다.

### <a name="metrics"></a>메트릭
벤치마크의 핵심 메트릭은 처리량과 응답 시간입니다.

* 처리량은 벤치마크의 필수 성능 측정값입니다. 처리량은 모든 트랜잭션 유형을 세는 단위 시간당 트랜잭션 수로 보고됩니다.
* 응답 시간은 성능 예측 가능성에 대한 측정값입니다. 응답 시간 제약 조건은 서비스 클래스에 따라 달라지며, 다음과 같이 서비스 클래스가 높을수록 응답 시간 요구 사항이 더욱 까다로워집니다.

| 서비스 클래스 | 처리량 측정 | 응답 시간 요구 사항 |
| --- | --- | --- |
| Premium |초당 트랜잭션 수 |0.5초에서 95 백분위수 |
| Standard |분당 트랜잭션 수 |1.0초에서 90 백분위수 |
| Basic |시간당 트랜잭션 수 |2.0초에서 80 백분위수 |

## <a name="next-steps"></a>다음 단계

- vCore 기반 구매 모델의 경우, [vCore 기반 구매 모델](sql-database-service-tiers-vcore.md)을 참조하세요.
- DTU 기반 구매 모델은 [DTU 기반 구매 모델](sql-database-service-tiers-dtu.md)을 참조하세요.
