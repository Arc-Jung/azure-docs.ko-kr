---
title: Azure Database for PostgreSQL – 하이퍼스케일 (Citus) (미리 보기)에서 분산 열 선택
description: 일반적인 하이퍼스케일 시나리오에서 분산 열에 대한 적절한 선택
author: jonels-msft
ms.author: jonels
ms.service: postgresql
ms.subservice: hyperscale-citus
ms.topic: conceptual
ms.date: 05/06/2019
ms.openlocfilehash: e9fba14b8979f739fd29bc277e32fb544221d08a
ms.sourcegitcommit: 0ae3139c7e2f9d27e8200ae02e6eed6f52aca476
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/06/2019
ms.locfileid: "65078987"
---
# <a name="choose-distribution-columns-in-azure-database-for-postgresql--hyperscale-citus-preview"></a>Azure Database – 하이퍼스케일 (Citus) (미리 보기) 용 Azure Database에서 분산 열 선택

각 테이블의 분산 열을 선택 하는 것은 모델링 의사결정에서 **가장 중요한 중 하나**입니다. 하이퍼스케일은 분산 열 행의 값을 기반으로 하는 분할에 행을 저장 합니다.

올바른 선택은 동일한 물리적 노드에서 관련 데이터를 함께 그룹핑하여, 모든 SQL 기능에 대한 지원을 추가하고 쿼리를 빠르게  합니다. 잘못된 선택은 시스템을 느리게 하며 노드에 걸쳐 모든 SQL 기능을 지원 하지 않습니다.

이 섹션에서는 가장 일반적인 두 가지 하이퍼스케일 시나리오에 대한 분산 열 팁을 제공 합니다.

### <a name="multi-tenant-apps"></a>다중 테넌트 앱

다중 테넌트 아키텍처는 서버 그룹의 노드 간에 쿼리를 분산하기 위해 계층적인 데이터베이스 모델링의 형태를 사용 합니다. 데이터 계층의 최상위는 *테넌트 ID* 라고 하며, 각 테이블의 열에 저장 되어야 합니다.

하이퍼스케일은 일치 하는 테이블 분할을 찾고 참가하는 테넌트 ID를 보기 위해 쿼리를 검사 합니다. 쿼리가 분할을 포함 하는 단일 작업자 노드에 라우팅합니다. 동일한 노드에 배치 되는 모든 관련 데이터를 사용 하여 쿼리를 실행 하는 것을 공동 배치라고 합니다.

다음 다이어그램에서는 다중 테넌트 데이터 모델에 공동 배치를 보여 줍니다. Accounts 및 Campaigns두 개의 테이블을 포함하며, 각각 `account_id`로 분산됩니다. 회색 상자는 분할을 포함 하는 작업자 노드를 나타내는 해당 색의 분할을 나타냅니다. 녹색 분할은 하나의 작업자 노드에 함께 저장되고 파란색은 다른 노드에 저장 됩니다. 동일한 account_id로 두 테이블을 제한 하는 경우 Accounts 및 Campaigns 간의 join 쿼리가 한 노드에서 필요한 모든 데이터를 함께 포함하는 방법에 주목하십시오.

![다중 테 넌 트 공동 배치](media/concepts-hyperscale-choosing-distribution-column/multi-tenant-colocation.png)

이 디자인에서 사용자 고유의 스키마를 적용 하려면 응용 프로그램에서 테넌트 구성 요소를 식별 합니다. 일반적인 인스턴스는 회사, 계정, 조직 또는 고객을 포함합니다. 열 이름은 `company_id` 또는 `customer_id` 같이 표시 됩니다. 각 쿼리를 검토 하고 자신에게 질문합니다:동일한 테넌트 ID를 사용하여 행 관련된 모든 테이블을 제한하는 WHERE 절을 추가한다면 잘 동작될까?
다중 테넌트 모델에서 쿼리는 한 테넌트로 범위가 지정되어,  예를 들어 Sales 또는 inventory에 대한 쿼리는 특정 저장소 내에서 범위가 지정됩니다.

#### <a name="best-practices"></a>모범 사례

-   **공통 tenant_id 열로 분산된 테이블을 파티션 합니다.** 예를 들어, 테넌트가 회사들인 SaaS 응용 프로그램에서  tenant_id가 company_id가 될 것입니다.
-   **작은 테넌트 간 테이블을 참조 테이블로 변환 합니다.** 여러 테넌트가 작은 테이블의 정보를 공유 하는 경우 참조 테이블로 분산 합니다.
-   **tenant_id로 모든 응용 프로그램 쿼리를 필터하여 제한합니다.** 각 쿼리는 한 번에 하나의 테넌트에 대한 정보를 요청 해야 합니다.

이 종류의 응용 프로그램을 구축 하는 예제에 대한 [다중 테 넌 트 자습서](./tutorial-design-database-hyperscale-multi-tenant.md)를 확인합니다.

### <a name="real-time-apps"></a>실시간 앱

다중 테넌트 아키텍처는 계층 구조를 소개 하고 테넌트 당 쿼리를 라우팅하도록  데이터 공동 배치를 사용 합니다. 반면, 실시간 아키텍처는 높은 병렬 처리를 위해 해당 데이터의 특정 분산 속성에 따라 달라 집니다.

실시간 모델에서 분산 열에 대한 측면으로 "엔터티 ID"를 사용합니다. 일반적인 엔터티는 사용자, 호스트 또는 장치입니다.

실시간 쿼리는 일반적으로 날짜 또는 범주별으로 그룹화 하는 숫자 집계에 대해 요청 합니다. 하이퍼스케일은 부분 결과에 대한 각 분할에 이러한 쿼리를 보내고 코디네이터 노드에서 최종 해답을 조합 합니다. 쿼리는 최대한 많은 노드가 참여를 하는 경우와 불균형한 양의 작업을 수행하는 단일 노드가 없는 경우 가장 빠르게 실행됩니다.

#### <a name="best-practices"></a>모범 사례

-   **분산 열으로 카디널리티가 높은 열을 선택 합니다.** 비교를 위해,  "신규","유료","배송"을 값을 가지는 주문 테이블의 "상태" 필드는  잘못된 분산 열 선택입니다. 데이터를 보유할 수 있는 분할 수와 처리할 수 있는 노드의 수를 제한 하는 몇 가지 값만을 가정 합니다. 카디널리티가 높은 열 간에 조인 키 또는 group by 절에서 자주 사용 되는 것을 선택 하는 것이 좋습니다.
-   **균등한 분산을 사용하여 열을 선택 합니다.** 특정 공통 값에 비대칭 열에 테이블을 분산하려는 경우, 테이블의 데이터는 특정 분할에 누적되는 경향이 있습니다. 다른 노드보다 더 많은 작업을 수행 하는 해당 분할을 보유 하는 노드는 종료 됩니다.
-   **공통 열 기준 팩트 테이블과 차원 테이블을 분산 합니다.**
    팩트 테이블은 하나의 분산 키만 있을 수 있습니다. 다른 키에 조인 하는 테이블은 팩트 테이블을 사용하여 공동 배치 되지 않습니다. 조인 되는 빈도와 조인 하는 행의 크기에 따라 공동 배치할 수 있는 하나 이상의 차원을 선택 합니다.
-   **일부 차원 테이블을 참조 테이블로 변경 합니다.** 차원 테이블은 팩트 테이블을 사용하여 공동 배치할 수 없는 경우 참조 테이블의 형태로 모든 노드의 차원 테이블의 복사본을 분산하여 쿼리 성능을 개선할 수 있습니다.

이 종류의 응용 프로그램을 구축 하는 예제에 대한 [실시간 대시보드 자습서](./tutorial-design-database-hyperscale-realtime.md)를 확인합니다.

### <a name="timeseries-data"></a>시계열 데이터

시계열 워크로드에서 응용 프로그램은 이전 정보를 보관 하는 동안 최신 정보를 쿼리 합니다.

하이퍼스케일의 시계열 정보 모델링에서 가장 일반적인 실수는 분산 열로 자체 타임 스탬프를 사용하는 것입니다. 시간을 기반으로 하는 해시 분산은 분할에 시간 범위를 함께 유지 하는 것이 아니라 다른 분할로 랜덤으로 시간을 분산합니다. 시간과 관련된 쿼리는 일반적으로 시간 범위를 참조하여  (예: 가장 최근의 데이터)  이러한 해시 분산은  네트워크 오버 헤드를 발생합니다.

#### <a name="best-practices"></a>모범 사례

-   **배포 열로 타임 스탬프를 선택 하지 마십시오.** 다른 배포 열을 선택 합니다. 다중 테넌트 앱에서 테넌트 ID를 사용 하거나 실시간 앱에서 엔터티 ID를 사용 합니다.
-   **시간 대신 PostgreSQL 테이블 분할 사용 합니다.** 큰 테이블의 시간 정렬 데이터를 각각 다른 시간 범위를 포함 하는 여러 상속 된 테이블로 쪼개기위해 테이블 분할을 사용합니다.  하이퍼스케일에서 Postgres 분할된 테이블의 분산은 상속된 테이블에 대한 분할을 만듭니다.

이 종류의 응용 프로그램을 구축 하는 예제에 대한 [시계열 자습서](https://aka.ms/hyperscale-tutorial-timeseries)를 확인합니다.

## <a name="next-steps"></a>다음 단계
- 분산된 데이터 쿼리 간의 [공동 배치](concepts-hyperscale-colocation.md)가 쿼리를 빠르게 실행 하는 방법에 대해 알아봅니다.
