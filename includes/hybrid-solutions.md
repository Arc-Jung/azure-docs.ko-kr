# Azure 서비스 버스

소프트웨어가 클라우드에서 실행되든 또는 온-프레미스에서 실행되든 간에 다른 소프트웨어와 상호 작용해야 하는 경우가 많습니다. 유용한 상호 작용 방법을 제공하기 위해 Azure는 서비스 버스를 제공합니다. 이 문서에서는 이 기술을 살펴보고 기술의 정의와 사용해야 하는 이유를 설명합니다.

## 목차

-   [서비스 버스 기본 사항][서비스 버스 기본 사항]
-   [큐][큐]
-   [토픽][토픽]
-   [릴레이][릴레이]

## <a name="fundamentals"></a>서비스 버스 기본 사항

각 상황에 따라 다른 스타일의 통신이 요청됩니다. 때로는 응용 프로그램이 단순한 큐를 통해 메시지를 보내고 받도록 하는 것이 최상의 솔루션입니다. 다른 상황에서는 일반적인 큐로 충분하지 않고 게시 및 구독 메커니즘을 사용한 큐가 더 효율적입니다. 실제로 응용 프로그램 간의 연결만 필요하고 큐가 필요하지 않은 경우도 있습니다. 서비스 버스는 세 가지 옵션을 모두 제공하여 응용 프로그램이 여러 다른 방법으로 상호 작용할 수 있게 해 줍니다.

서비스 버스는 다중 테넌트 클라우드 서비스로, 여러 사용자가 서비스를 공유합니다. 응용 프로그램 개발자 등의 각 사용자는 *네임스페이스*를 만든 후 해당 네임스페이스에서 필요한 통신 메커니즘을 정의합니다. [그림 1][그림 1]에서는 표시되는 모양을 보여 줍니다.

<a name="Fig1"></a>![Azure 서비스 버스 다이어그램][Azure 서비스 버스 다이어그램]

**그림 1: 서비스 버스는 클라우드를 통해 응용 프로그램을 연결하기 위한 다중 테넌트 서비스를 제공합니다.**

네임스페이스 내에서 각각 다른 방식으로 응용 프로그램을 연결하는 세 가지 통신 메커니즘 인스턴스를 하나 이상 사용할 수 있습니다. 선택 항목은 다음과 같습니다.

-   *큐* - 단방향 통신을 허용합니다. 각 큐는 수신될 때까지 전송된 메시지를 저장하는 중간자(*브로커*라고도 함) 역할을 합니다.
-   *토픽* - *구독*을 사용하여 단방향 통신을 제공합니다. 큐와 마찬가지로 토픽은 브로커 역할을 하지만 각 구독에서 특정 기준과 일치하는 메시지만 표시할 수 있게 해 줍니다.
-   *릴레이* - 양방향 통신을 제공합니다. 큐 및 토픽과 달리 릴레이는 처리 중인 메시지를 저장하지 않으며 브로커가 아닙니다. 단순히 메시지를 대상 응용 프로그램으로 전달합니다.

큐, 토픽 또는 릴레이를 만들 때 이름을 지정합니다. 이 이름은 네임스페이스 이름과 결합되어 개체의 고유 식별자를 만듭니다. 응용 프로그램은 서비스 버스에 이 이름을 제공한 다음 해당 큐, 토픽 또는 릴레이를 사용하여 서로 통신할 수 있습니다.

이러한 개체를 사용하기 위해 Windows 응용 프로그램은 WCF(Windows Communication Foundation)를 사용할 수 있습니다. 큐와 토픽의 경우 Windows 응용 프로그램이 서비스 버스에서 정의된 메시지 API를 사용할 수도 있습니다. HTTP를 통해 큐와 토픽에 액세스할 수도 있으며, Microsoft는 Windows가 아닌 응용 프로그램에서 큐와 토픽을 사용하기 쉽도록 Java, Node.js 및 기타 언어용 SDK를 제공합니다.

서비스 버스 자체가 클라우드(즉, Microsoft Azure 데이터 센터)에서 실행되는 경우에도 서비스 버스를 사용하는 응용 프로그램은 다른 곳에서 실행될 수 있음을 이해하는 것이 중요합니다. 예를 들어 서비스 버스를 사용하여 Azure에서 실행되는 응용 프로그램이나 고유한 데이터 센터 내부에서 실행되는 응용 프로그램을 연결할 수 있습니다. 서비스 버스를 사용하여 Azure 또는 다른 클라우드 플랫폼에서 실행되는 응용 프로그램을 온-프레미스 응용 프로그램이나 태블릿 및 휴대폰과 연결할 수도 있습니다. 가전 제품, 센서 및 기타 장치를 중앙 응용 프로그램에 연결하거나 서로 연결할 수도 있습니다. 서비스 버스는 거의 모든 곳에서 액세스할 수 있는 클라우드의 일반 통신 메커니즘입니다. 사용 방법은 응용 프로그램에서 수행해야 하는 작업에 따라 달라집니다.

## <a name="queues"></a>큐

서비스 버스 큐를 사용하여 두 개의 응용 프로그램을 연결한다고 가정해 보십시오. [그림 2][그림 2]에서는 이 상황을 보여 줍니다.

<a name="Fig2"></a>![서비스 버스 큐 다이어그램][서비스 버스 큐 다이어그램]

**그림 2: 서비스 버스 큐는 단방향 비동기 큐를 제공합니다.**

프로세스는 간단합니다. 센서가 메시지를 서비스 버스 큐로 보내면 수신기가 나중에 해당 메시지를 확인합니다. 각 큐에 하나의 수신기만 있거나([그림 2][그림 2] 참조) 여러 응용 프로그램이 동일한 큐에서 읽을 수 있습니다. 두 번째 상황에서는 일반적으로 각 메시지가 하나의 수신기에서만 읽혀지며 큐에서 멀티캐스트 서비스를 제공하지 않습니다.

각 메시지는 각각 키/값 쌍인 속성 집합과 이진 메시지 본문의 두 부분으로 이루어져 있습니다. 메시지가 사용되는 방법은 응용 프로그램에서 수행하려는 작업에 따라 달라집니다. 예를 들어 최근 판매에 대한 메시지를 보내는 응용 프로그램은 *Seller="Ava"* 및 *Amount=10000* 속성을 포함할 수 있습니다. 메시지 본문은 서명된 판매 계약의 스캔 이미지를 포함하거나, 이러한 이미지가 없는 경우 비어 있을 수 있습니다.

수신기는 두 가지 방법으로 서비스 버스 큐에서 메시지를 읽을 수 있습니다. 첫 번째 옵션은 ReceiveAndDelete라고 하며, 큐에서 메시지를 제거하고 즉시 삭제합니다. 이 옵션은 간단하지만 수신기에서 메시지 처리를 마치기 전에 크래시가 발생할 경우 메시지가 손실됩니다. 큐에서 제거되었기 때문에 다른 수신기가 메시지에 액세스할 수 없습니다.

두 번째 옵션은 PeekLock이라고 하며, 이 문제를 해결하는 데 도움이 됩니다. ReceiveAndDelete와 마찬가지로 PeekLock 읽기는 큐에서 메시지를 제거합니다. 그러나 메시지를 삭제하지 않습니다. 대신, 메시지를 잠가서 다른 수신기에 표시되지 않도록 하고 다음 세 가지 이벤트 중 하나를 기다립니다.

-   수신기가 메시지 처리에 성공하고 Complete를 호출하면 큐가 메시지를 삭제합니다.
-   수신기가 메시지를 처리할 수 없다고 결정하고 Abandon을 호출하면 큐가 메시지에서 잠금을 제거하고 다른 수신기가 사용할 수 있게 합니다.
-   수신기가 구성 가능한 기간(기본적으로 60초) 내에 둘 다 호출하지 않으면 큐가 수신기에서 실패했다고 가정합니다. 이 경우 수신기가 Abandon을 호출한 것처럼 동작하고 다른 수신기가 메시지를 사용할 수 있게 합니다.

여기서 발생할 수 있는 문제는 동일한 메시지가 두 개의 수신기에 두 번 배달될 수 있다는 것입니다. 서비스 버스 큐를 사용하는 응용 프로그램은 이 문제에 대비해야 합니다. 중복 검색이 용이하도록 각 메시지에는 고유한 MessageID 속성이 있습니다. 기본적으로 이 속성은 큐에서 메시지를 읽는 횟수에 관계없이 동일하게 유지됩니다.

큐는 다양한 상황에서 유용합니다. 큐를 사용하면 응용 프로그램이 동시에 실행되지 않는 경우에도 서로 통신할 수 있으므로 일괄 처리 및 모바일 응용 프로그램에서 특히 유용합니다. 여러 수신기가 있는 큐는 전송된 메시지가 이러한 수신기에 분산되므로 자동 부하 분산 기능도 제공합니다.

## <a name="topics"></a>토픽

유용하긴 하지만 큐가 항상 올바른 솔루션인 것은 아닙니다. 때로는 서비스 버스 토픽이 더 효율적입니다. [그림 3][그림 3]에서는 이 아이디어를 보여 줍니다.

<a name="Fig3"></a>![서비스 버스 토픽 및 구독 다이어그램][서비스 버스 토픽 및 구독 다이어그램]

**그림 3: 구독 응용 프로그램에서 지정한 필터를 기준으로 서비스 버스 토픽에 전송된 메시지를 일부 또는 모두 받을 수 있습니다.**

토픽은 여러 측면에서 큐와 유사합니다. 보낸 사람은 메시지를 큐에 제출하는 것과 동일한 방식으로 메시지를 토픽에 제출하며, 이러한 메시지는 큐와 동일하게 표시됩니다. 큰 차이점은 토픽을 사용할 경우 각 수신 응용 프로그램이 *필터*를 정의하여 고유한 구독을 만들 수 있다는 것입니다. 그러면 구독자가 해당 필터와 일치하는 메시지만 볼 수 있습니다. 예를 들어 [그림 3][그림 3]에서는 각각 고유한 필터가 있는 세 명의 구독자가 포함된 토픽과 보낸 사람을 보여 줍니다.

-   구독자 1은 *Seller="Ava"* 속성이 포함된 메시지만 받습니다.
-   구독자 2는 *Seller="Ruby"* 속성과 값이 100,000보다 큰 *Amount* 속성이 포함된 메시지를 받습니다. Ruby는 판매 관리자이므로 자신의 매출과 판매자에 관계없이 모든 대규모 매출을 보려고 합니다.
-   구독자 3은 해당 필터를 *True*로 설정합니다. 이렇게 하면 모든 메시지를 받습니다. 예를 들어 이 응용 프로그램에서 감사 내역을 유지 관리하므로 모든 메시지를 확인해야 할 수도 있습니다.

큐와 마찬가지로 토픽 구독자는 ReceiveAndDelete 또는 PeekLock을 사용하여 메시지를 읽을 수 있습니다. 그러나 큐와 달리 토픽으로 전송된 단일 메시지를 여러 구독자가 받을 수 있습니다. 흔히 *게시 및 구독*이라고 불리는 이 접근 방법은 여러 응용 프로그램이 동일한 메시지에 관련된 경우에 유용합니다. 올바른 필터를 정의하면 각 구독자가 확인해야 하는 메시지 스트림 부분만 볼 수 있습니다.

## <a name="relays"></a>릴레이

큐와 토픽은 둘 다 브로커를 통해 단방향 비동기 통신을 제공합니다. 트래픽이 한 방향으로만 진행되며, 보낸 사람과 받는 사람 간에 직접 연결이 없습니다. 그러나 이런 방식을 원하지 않는 경우 어떻게 해야 할까요? 응용 프로그램이 보내기와 받기를 모두 수행해야 하거나, 그 사이에 메시지를 저장할 장소가 필요하지 않도록 직접 연결을 사용하려 한다고 가정해 보십시오. 이러한 문제를 처리하기 위해 서비스 버스는 [그림 4][그림 4]와 같은 릴레이를 제공합니다.

<a name="Fig4"></a>![서비스 버스 릴레이 다이어그램][서비스 버스 릴레이 다이어그램]

**그림 4: 서비스 버스 릴레이는 응용 프로그램 간에 양방향 동기 통신을 제공합니다.**

릴레이와 관련해서 제기되는 질문은 릴레이를 사용해야 하는 이유입니다. 큐가 필요하지 않다고 해도 왜 응용 프로그램이 직접 상호 작용하는 대신 클라우드 서비스를 통해 통신해야 할까요? 그 대답은 직접 통신하는 것이 생각보다 어려울 수 있기 때문입니다.

회사 데이터 센터 내부에서 실행되는 두 개의 온-프레미스 응용 프로그램을 연결하려 한다고 가정해 보십시오. 각 응용 프로그램은 방화벽 뒤에 있고, 각 데이터 센터에서 NAT(Network Address Translation)를 사용합니다. 방화벽은 몇 개의 포트를 제외한 모든 포트에서 들어오는 데이터를 차단하며, NAT는 각 응용 프로그램이 실행되는 컴퓨터에 고정 IP 주소가 없음을 암시합니다. 추가 도움이 없으면 공용 인터넷을 통해 이러한 응용 프로그램을 연결하는 데 문제가 있습니다.

서비스 버스 릴레이는 이 도움을 제공합니다. 릴레이를 통해 양방향으로 통신하기 위해 각 응용 프로그램은 서비스 버스와 아웃바운드 TCP 연결을 설정한 다음 열어 둡니다. 두 응용 프로그램 간의 모든 통신은 이러한 연결을 통해 전송됩니다. 각 연결이 데이터 센터 내부에서 설정되었으므로 새 포트를 열지 않고도 방화벽에서 들어오는 트래픽, 즉 "릴레이를 통해 전송된 데이터"를 각 응용 프로그램으로 허용합니다. 이 접근 방식을 사용할 경우 통신 전체 과정에서 각 응용 프로그램에 일관된 끝점이 있으므로 NAT 문제도 해결됩니다. 릴레이를 통해 데이터를 교환하면 응용 프로그램에서 통신을 어렵게 만드는 문제를 피할 수 있습니다.

서비스 버스 릴레이를 사용하기 위해 응용 프로그램은 WCF(Windows Communication Foundation)를 사용합니다. 서비스 버스는 Windows 응용 프로그램이 릴레이를 통해 간단하게 상호 작용할 수 있게 해 주는 WCF 바인딩을 제공합니다. 이미 WCF를 사용하는 응용 프로그램은 일반적으로 이러한 바인딩 중 하나만 지정한 다음 릴레이를 통해 서로 통신할 수 있습니다. 그러나 큐 및 토픽과 달리 Windows가 아닌 응용 프로그램에서 릴레이를 사용할 수는 있지만 이 경우 약간의 프로그래밍이 필요하며 표준 라이브러리가 제공되지 않습니다.

큐 및 토픽과 달리 응용 프로그램에서 명시적으로 릴레이를 만들지는 않습니다. 대신, 메시지를 받으려는 응용 프로그램이 서비스 버스와 TCP 연결을 설정하면 릴레이가 자동으로 만들어집니다. 연결을 삭제하면 릴레이가 삭제됩니다. 응용 프로그램이 특정 수신기에서 만든 릴레이를 찾을 수 있도록 서비스 버스는 이름으로 특정 릴레이를 찾을 수 있게 해 주는 레지스트리를 제공합니다.

릴레이는 직접 통신이 필요한 경우에 올바른 솔루션입니다. 예를 들어 온-프레미스 데이터 센터에서 실행되는 항공 예약 시스템을 생각해 보십시오. 이 시스템은 체크 인 키오스크, 모바일 장치 및 기타 컴퓨터에서 액세스해야 합니다. 어디서 실행되든 관계없이 이러한 모든 시스템에서 실행되는 응용 프로그램은 클라우드의 서비스 버스 릴레이를 사용하여 통신할 수 있습니다.

응용 프로그램 연결은 항상 전체 솔루션 빌드의 일부였으며, 이 문제가 완전히 사라지기는 어렵습니다. 이 큐, 토픽 및 릴레이를 통해 이를 수행하기 위한 클라우드 기반 기술을 제공함으로써 서비스 버스는 이 필수 기능을 더 쉽고 보다 광범위하게 사용할 수 있게 하려고 합니다.

  [서비스 버스 기본 사항]: #fundamentals
  [큐]: #queues
  [토픽]: #topics
  [릴레이]: #relays
  [그림 1]: #Fig1
  [Azure 서비스 버스 다이어그램]: ./media/hybrid-solutions/SvcBus_01_architecture.png
  [그림 2]: #Fig2
  [서비스 버스 큐 다이어그램]: ./media/hybrid-solutions/SvcBus_02_queues.png
  [그림 3]: #Fig3
  [서비스 버스 토픽 및 구독 다이어그램]: ./media/hybrid-solutions/SvcBus_03_topicsandsubscriptions.png
  [그림 4]: #Fig4
  [서비스 버스 릴레이 다이어그램]: ./media/hybrid-solutions/SvcBus_04_relay.png
